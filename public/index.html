<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SignalK Parquet Data Interface</title>
    <link rel="icon" type="image/png" href="parquet.png">
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #2BB5D6 0%, #013542 100%);
            color: white;
            padding: 20px 0;
            margin-bottom: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        button {
            background: #667eea;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #5a6fd8;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .results {
            margin-top: 20px;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
        }

        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            word-wrap: break-word;
        }
        
        th:nth-child(1), td:nth-child(1) { min-width: 180px; } /* Path */
        th:nth-child(2), td:nth-child(2) { width: 60px; } /* Enabled */
        th:nth-child(3), td:nth-child(3) { min-width: 100px; } /* Regimen */
        th:nth-child(4), td:nth-child(4) { min-width: 120px; } /* Source */
        th:nth-child(5), td:nth-child(5) { width: 90px; } /* Context */
        th:nth-child(6), td:nth-child(6) { min-width: 120px; } /* Exclude MMSI */
        th:nth-child(7), td:nth-child(7) { width: 140px; } /* Actions */

        th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        tr:hover {
            background-color: #f8f9fa;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .path-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .path-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }

        .path-item h4 {
            margin-bottom: 5px;
            color: #495057;
        }

        .path-item p {
            font-size: 0.9rem;
            color: #666;
        }

        .path-item button {
            margin-top: 10px;
            padding: 5px 10px;
            font-size: 12px;
        }


        .query-examples {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .query-examples h4 {
            margin-bottom: 10px;
            color: #495057;
        }

        .query-examples ul {
            list-style: none;
            padding: 0;
        }

        .query-examples li {
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .query-examples li:hover {
            background: #e9ecef;
        }

        .query-examples code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
        }

        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            margin: -20px -20px 15px -20px;
            background: #f8f9fa;
            border-radius: 10px 10px 0 0;
            transition: background-color 0.3s;
        }

        .collapsible-header:hover {
            background: #e9ecef;
        }

        .collapsible-header h2 {
            margin: 0;
        }

        .collapse-icon {
            font-size: 1.2rem;
            transition: transform 0.3s;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }

        .collapsible-content.expanded {
            max-height: 2000px;
        }

        /* Tab Navigation Styles */
        .tab-navigation {
            display: flex;
            background: white;
            border-radius: 10px 10px 0 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 0;
            overflow-x: auto;
        }

        .tab-button {
            background: #f8f9fa;
            border: none;
            padding: 15px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            border-radius: 0;
            transition: all 0.3s;
            white-space: nowrap;
            border-bottom: 3px solid transparent;
            margin: 0;
        }

        .tab-button:first-child {
            border-radius: 10px 0 0 0;
        }

        .tab-button:last-child {
            border-radius: 0 10px 0 0;
        }

        .tab-button:hover {
            background: #e9ecef;
            color: #333;
        }

        .tab-button.active {
            background: white;
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            background: white;
            border-radius: 0 0 10px 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .tab-panel .section {
            margin-bottom: 0;
            box-shadow: none;
            border-radius: 0 0 10px 10px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .stats {
                flex-direction: column;
                gap: 10px;
            }

            .tab-navigation {
                flex-wrap: wrap;
            }

            .tab-button {
                flex: 1;
                min-width: 120px;
                padding: 12px 15px;
                font-size: 13px;
            }

            .tab-button:first-child,
            .tab-button:last-child {
                border-radius: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <img src="parquet.png" alt="Parquet" style="height: 80px; vertical-align: middle; margin-right: 10px; border-radius: 5px;"> 
                SignalK Parquet Data Store</h1>
            <p>Export, query, and explore your SignalK data archived as Parquet files</p>
        </div>

        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-button active" onclick="showTab('pathConfig')">⚙️ Path Configuration</button>
            <button class="tab-button" onclick="showTab('commandManager')">🎮 Regimen/Commands Manager</button>
            <button class="tab-button" onclick="showTab('liveConnections')" style="display: none;">🔴 Live Connections</button>
            <button class="tab-button" onclick="showTab('dataPaths')">🗄️ Query Database</button>
            <button class="tab-button" onclick="showTab('aiAnalysis')">🧠 AI Analysis <small>(EXPERIMENTAL)</small></button>
            <button class="tab-button" onclick="showTab('dataValidation')">🔍 Data Validation</button>
            <button class="tab-button" onclick="showTab('s3Config')">☁️ Cloud Status</button>
        </div>

        <!-- Tab Content Panels -->
        <div class="tab-content">
            <!-- Path Configuration Tab -->
            <div id="pathConfig" class="tab-panel active">
                <div class="section">
                    <h2>⚙️ Path Configuration</h2>
                <p>Manage which SignalK paths to collect data from:</p>
                <button onclick="loadPathConfigurations()">🔄 Refresh Paths</button>
                <button onclick="showAddPathForm()">➕ Add New Path</button>
                <button id="toggleCommandsBtn" onclick="toggleCommandPaths()">👁️ Show Commands</button>
                
                <!-- Add Path Form (hidden by default) -->
                <div id="addPathForm" style="display: none; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 5px; min-height: 400px; overflow: visible;">
                    <h4>Add New Path Configuration</h4>
                    <div class="form-group">
                        <label for="pathSignalK">SignalK Path:</label>
                        <div style="margin-bottom: 8px; display: flex; align-items: center; gap: 15px;">
                            <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer; white-space: nowrap;">
                                <span style="margin-right: 5px;">🏠 Self paths</span>
                                <input type="radio" id="pathFilterSelf" name="pathFilter" value="self" checked onchange="updatePathFilter()">
                            </label>
                            <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer; white-space: nowrap;">
                                <span style="margin-right: 5px;">🚢 Other vessel paths</span>
                                <input type="radio" id="pathFilterOthers" name="pathFilter" value="others" onchange="updatePathFilter()">
                            </label>
                        </div>
                        <select id="pathSignalK" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="">-- Select SignalK Path --</option>
                            <option value="custom">🖊️ Enter Custom Path</option>
                        </select>
                        <input type="text" id="pathSignalKCustom" placeholder="Enter custom SignalK path (e.g., navigation.position)" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px; display: none;">
                    </div>
                    <div class="form-group">
                        <label for="pathEnabled" style="display: inline !important; margin-bottom: 0 !important;">Always Enabled:</label>
                        <input type="checkbox" id="pathEnabled" style="display: inline !important; width: auto !important; margin-left: 10px;">
                    </div>
                    <div class="form-group">
                        <label for="pathRegimen">Regimen Control:</label>
                        <div style="border: 1px solid #ddd; border-radius: 4px; padding: 10px; max-height: 150px; overflow-y: auto; background: white;">
                            <div id="regimenCheckboxes">
                                <!-- Regimen checkboxes will be populated here -->
                            </div>
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">
                                <label for="customRegimen" style="font-size: 0.9em; color: #666;">Custom Regimen:</label>
                                <input type="text" id="customRegimen" placeholder="Enter custom regimen name" style="width: 100%; padding: 6px; margin-top: 5px; border: 1px solid #ddd; border-radius: 3px;">
                                <button type="button" onclick="addCustomRegimen()" style="margin-top: 5px; padding: 4px 8px; background: #28a745; color: white; border: none; border-radius: 3px; font-size: 0.8em;">➕ Add</button>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="pathContext">Context:</label>
                        <input type="text" id="pathContext" placeholder="e.g., vessels.self or vessels.*" value="vessels.self">
                    </div>
                    <div class="form-group">
                        <label for="pathSource">Source Filter (optional):</label>
                        <input type="text" id="pathSource" placeholder="e.g., mqtt-weatherflow-udp">
                        <small style="color: #666; display: block; margin-top: 5px;">
                            Filter by specific data source. Leave empty to accept all sources.
                        </small>
                    </div>
                    <div class="form-group">
                        <label for="pathExcludeMMSI">Exclude MMSI (for vessels.* context):</label>
                        <input type="text" id="pathExcludeMMSI" placeholder="e.g., 123456789, 987654321 (comma-separated)">
                        <small style="color: #666; display: block; margin-top: 5px;">
                            Only applicable when context is "vessels.*". Leave empty to include all vessels.
                        </small>
                    </div>
                    <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd; min-height: 60px; display: flex; gap: 10px; align-items: center;">
                        <button onclick="addPathConfiguration()">✅ Add Path</button>
                        <button class="btn-secondary" onclick="hideAddPathForm()">❌ Cancel</button>
                    </div>
                </div>
                
                    <div id="pathConfigContainer">
                        <div class="loading">Loading path configurations...</div>
                    </div>
                </div>
            </div>

            <!-- Command Manager Tab -->
            <div id="commandManager" class="tab-panel">
                <div class="section">
                    <h2>🎮 Regimen/Commands Manager</h2>
                    <p>Register and manage SignalK commands for remote control:</p>
                    <button onclick="showAddCommandForm()">➕ Add New Command</button>
                    
                    <!-- Add Command Form (hidden by default) -->
                    <div id="addCommandForm" style="display: none; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 5px;">
                        <h4>Register New Command</h4>
                        <div class="form-group">
                            <label for="commandName">Command Name:</label>
                            <input type="text" id="commandName" placeholder="e.g., captureWeather, startLogging">
                        </div>
                        <div class="form-group">
                            <label for="commandDescription">Description (optional):</label>
                            <input type="text" id="commandDescription" placeholder="e.g., Start weather data capture">
                        </div>
                        <div class="form-group">
                            <label for="commandKeywords">Keywords (for Claude context matching):</label>
                            <input type="text" id="commandKeywords" placeholder="e.g., anchor, anchoring, drag, swing">
                            <small style="color: #666; font-size: 11px;">Separate multiple keywords with commas</small>
                        </div>
                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd;">
                            <button onclick="registerCommand()">✅ Register Command</button>
                            <button class="btn-secondary" onclick="hideAddCommandForm()">❌ Cancel</button>
                        </div>
                    </div>
                    
                    <!-- Edit Command Form (hidden by default) -->
                    <div id="editCommandForm" style="display: none; margin: 20px 0; padding: 20px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px;">
                        <h4>Edit Command</h4>
                        <div class="form-group">
                            <label for="editCommandName">Command Name:</label>
                            <input type="text" id="editCommandName" readonly style="background: #f8f9fa;">
                        </div>
                        <div class="form-group">
                            <label for="editCommandDescription">Description:</label>
                            <input type="text" id="editCommandDescription" placeholder="e.g., Start weather data capture">
                        </div>
                        <div class="form-group">
                            <label for="editCommandKeywords">Keywords (for Claude context matching):</label>
                            <input type="text" id="editCommandKeywords" placeholder="e.g., anchor, anchoring, drag, swing">
                            <small style="color: #666; font-size: 11px;">Separate multiple keywords with commas</small>
                        </div>
                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd;">
                            <button onclick="updateCommand()">✅ Update Command</button>
                            <button class="btn-secondary" onclick="hideEditCommandForm()">❌ Cancel</button>
                        </div>
                    </div>
                    
                    <div id="commandContainer">
                        <div class="loading">Loading commands...</div>
                    </div>
                    
                    <!-- Command History -->
                    <div style="margin-top: 30px;">
                        <h3>📋 Command History</h3>
                        <button onclick="loadCommandHistory()">🔄 Refresh History</button>
                        <div id="commandHistoryContainer" style="margin-top: 15px;">
                            <div class="loading">Loading command history...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Live Connections Tab -->
            <div id="liveConnections" class="tab-panel">
                <div class="section" style="display: none;">
                    <h2>🔴 Live Connections - DISABLED</h2>
                    <p>Streaming functionality has been disabled.</p>
                    
                    <div style="margin-bottom: 20px;">
                        <button onclick="loadStreams()">🔄 Refresh Streams</button>
                        <button onclick="showAddStreamForm()">➕ Create New Stream</button>
                    </div>

                    <!-- Add Stream Form (hidden by default) -->
                    <div id="addStreamForm" style="display: none; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 5px;">
                        <h4>Create New Historical Stream</h4>
                        
                        <div class="form-group">
                            <label for="streamName">Stream Name:</label>
                            <input type="text" id="streamName" placeholder="e.g., Navigation History">
                        </div>
                        
                        <div class="form-group">
                            <label for="streamPath">SignalK Path:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="streamPath" style="flex: 1;">
                                    <option value="">Loading available paths...</option>
                                </select>
                                <button type="button" onclick="refreshSignalKPaths()" style="padding: 8px; background: #007bff; color: white; border: none; border-radius: 3px;" title="Refresh path list">🔄</button>
                            </div>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Available paths from historical data. Click refresh if you don't see your path.
                            </small>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamTimeRange">Time Range:</label>
                            <select id="streamTimeRange">
                                <option value="1h">Last 1 Hour</option>
                                <option value="6h">Last 6 Hours</option>
                                <option value="24h">Last 24 Hours</option>
                                <option value="7d">Last 7 Days</option>
                                <option value="30d">Last 30 Days</option>
                                <option value="custom">Custom Range</option>
                            </select>
                        </div>
                        
                        <div class="form-group" id="customTimeRange" style="display: none;">
                            <label>Custom Time Range:</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <input type="datetime-local" id="streamStartTime" placeholder="Start time">
                                <input type="datetime-local" id="streamEndTime" placeholder="End time">
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamResolution">Data Resolution:</label>
                            <select id="streamResolution">
                                <option value="1000">1 second</option>
                                <option value="5000">5 seconds</option>
                                <option value="15000">15 seconds</option>
                                <option value="30000" selected>30 seconds</option>
                                <option value="60000">1 minute</option>
                                <option value="300000">5 minutes</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamRate">Streaming Rate:</label>
                            <select id="streamRate">
                                <option value="100">Fast (100ms intervals)</option>
                                <option value="500" selected>Normal (500ms intervals)</option>
                                <option value="1000">Slow (1 second intervals)</option>
                                <option value="5000">Very Slow (5 second intervals)</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamAggregateMethod">Statistical Function:</label>
                            <select id="streamAggregateMethod">
                                <option value="average" selected>Average - arithmetic mean of values</option>
                                <option value="min">Minimum - lowest value in time window</option>
                                <option value="max">Maximum - highest value in time window</option>
                                <option value="first">First - earliest value in time window</option>
                                <option value="last">Last - most recent value in time window</option>
                                <option value="mid">Median - middle value when sorted</option>
                                <option value="middle_index">Middle Index - middle value by position</option>
                            </select>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Statistical function applied to data within each time window
                            </small>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamWindowSize">Rolling Window Size:</label>
                            <select id="streamWindowSize">
                                <option value="5">5 data points</option>
                                <option value="10" selected>10 data points</option>
                                <option value="20">20 data points</option>
                                <option value="50">50 data points</option>
                                <option value="100">100 data points</option>
                            </select>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Number of recent values used for real-time statistical calculations
                            </small>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamAutoStart">Auto-start stream:</label>
                            <input type="checkbox" id="streamAutoStart" checked>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Start streaming immediately after creation
                            </small>
                        </div>
                        
                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd;">
                            <button onclick="createStream()">✅ Create Stream</button>
                            <button class="btn-secondary" onclick="hideAddStreamForm()">❌ Cancel</button>
                        </div>
                    </div>

                    <!-- Active Streams Display -->
                    <div id="streamsContainer">
                        <div class="loading">Loading streams...</div>
                    </div>
                    
                    <!-- Stream Statistics -->
                    <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                        <h3>📊 Stream Statistics</h3>
                        <div id="streamStats" style="margin-top: 15px;">
                            <div class="loading">Loading statistics...</div>
                        </div>
                    </div>

                    <!-- Live Data Display -->
                    <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                        <h3>📡 Live Data Stream</h3>
                        <p style="margin-bottom: 15px;">Real-time time-bucketed statistical streaming data (newest first, max 100 entries):</p>
                        
                        <!-- Data Interpretation Guide -->
                        <div style="background: #f0f8ff; padding: 15px; border-radius: 5px; margin-bottom: 15px; font-size: 13px;">
                            <strong>📊 How to Read This Data:</strong><br/>
                            • <strong>📊 INITIAL</strong>: Full time window data (first load with many buckets)<br/>
                            • <strong>📈 INCREMENTAL</strong>: New data points since last update (sliding window - fewer buckets)<br/>
                            • <strong>Statistical Method</strong>: MAX, AVG, MIN, FIRST, LAST, MID applied to each time bucket<br/>
                            • <strong>Buckets</strong>: Number of time intervals processed (e.g., 30-second time buckets)<br/>
                            • <strong>Value</strong>: Result of statistical calculation for that time bucket<br/>
                            • <strong>EMA/SMA</strong>: Moving averages (10-period) calculated for numeric values - EMA responds faster to changes<br/>
                            • <strong>Time</strong>: Timestamp of the time bucket (not delivery time)
                        </div>
                        
                        <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px;">
                            <table id="liveDataTable" style="width: 100%; border-collapse: collapse; font-size: 12px;">
                                <thead style="position: sticky; top: 0; background: #f8f9fa; z-index: 1;">
                                    <tr>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Bucket Time</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Stream Type & Statistical Method</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Path</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Statistical Value</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">EMA (10)</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">SMA (10)</th>
                                    </tr>
                                </thead>
                                <tbody id="liveDataBody">
                                    <tr>
                                        <td colspan="6" style="padding: 20px; text-align: center; color: #666;">
                                            No data streaming yet. Start a stream to see live data.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div style="margin-top: 10px; font-size: 11px; color: #666;">
                            <span id="liveDataCount">0</span> time-bucketed entries • 
                            <button onclick="clearLiveData()" style="font-size: 11px; padding: 2px 8px;">🗑️ Clear</button>
                            <button onclick="toggleLiveDataPause()" id="pauseDataBtn" style="font-size: 11px; padding: 2px 8px; margin-left: 5px;">⏸️ Pause</button>
                            <button onclick="showDataSummary()" style="font-size: 11px; padding: 2px 8px; margin-left: 5px;">📊 Summary</button>
                        </div>
                        
                        <!-- Data Summary Panel -->
                        <div id="dataSummaryPanel" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                            <h4>📊 Data Summary & Trends</h4>
                            <div id="dataSummaryContent"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- AI Analysis Tab -->
            <div id="aiAnalysis" class="tab-panel">
                <div class="section">
                    <h2>🧠 AI Analysis with Claude</h2><small>EXPERIMENTAL</small>
                    <p>Analyze your maritime data using Claude AI for insights, patterns, and recommendations.</p>
                    
                    <!-- Connection Test -->
                    <div style="margin-bottom: 20px;">
                        <button onclick="testClaudeConnection()" id="testConnectionBtn">🔗 Test Claude Connection</button>
                        <div id="claudeConnectionResult" style="margin-top: 10px;"></div>
                    </div>

                    <!-- Vessel Context Section -->
                    <div style="margin-bottom: 30px; border: 2px solid #e3f2fd; border-radius: 8px; background: #fafbfc;">
                        <div onclick="toggleVesselContext()" style="padding: 15px 20px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; user-select: none;">
                            <div>
                                <h3 style="margin: 0;">⚓ Vessel Context Document</h3>
                                <p style="margin: 5px 0 0 0; color: #555; font-size: 0.9em;">Click to expand - context automatically included with every AI analysis</p>
                            </div>
                            <span id="vesselContextToggleIcon" style="font-size: 1.2em; color: #667eea;">▶</span>
                        </div>
                        <div id="vesselContextContent" style="display: none; padding: 0 20px 20px 20px; border-top: 1px solid #e3f2fd;">
                        
                        <!-- Auto-extracted vessel info -->
                        <div style="margin-bottom: 20px;">
                            <h4 style="margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;">
                                <span>📊 Auto-Extracted Vessel Information</span>
                                <button onclick="refreshVesselInfo()" style="font-size: 0.9em; padding: 6px 12px;">🔄 Refresh from SignalK</button>
                            </h4>
                            <div id="autoVesselInfo" style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #ddd;">
                                <div style="color: #666; font-style: italic;">Loading vessel information...</div>
                            </div>
                        </div>

                        <!-- Custom context -->
                        <div style="margin-bottom: 20px;">
                            <h4 style="margin-bottom: 10px;">✏️ Custom Context & Notes</h4>
                            <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Add any additional context about your vessel, operations, or specific information you want Claude to consider during analysis:</p>
                            <textarea id="customVesselContext" 
                                placeholder="e.g., 'This is a racing sailboat primarily used for coastal sailing. The vessel has recently had engine maintenance. We're particularly interested in wind performance analysis...'"
                                style="width: 100%; min-height: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 5px; resize: vertical; font-family: inherit;"></textarea>
                        </div>

                        <!-- Context preview and actions -->
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <button onclick="saveVesselContext()" style="background: #4CAF50; padding: 8px 16px;">💾 Save Context</button>
                            <button onclick="previewClaudeContext()" style="background: #2196F3; padding: 8px 16px;">👁️ Preview Claude Context</button>
                            <div id="vesselContextStatus" style="margin-left: 10px; font-size: 0.9em;"></div>
                        </div>

                        <!-- Context preview modal -->
                        <div id="contextPreviewModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">
                            <div style="max-width: 800px; margin: 50px auto; background: white; border-radius: 10px; padding: 20px; max-height: 80vh; overflow-y: auto;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h3>👁️ Claude Context Preview</h3>
                                    <button onclick="closeContextPreview()" style="background: #f44336; color: white; padding: 5px 10px; border-radius: 3px;">&times;</button>
                                </div>
                                <p style="color: #666; margin-bottom: 15px;">This is the context that will be sent to Claude with every analysis:</p>
                                <pre id="contextPreviewContent" style="background: #f8f9fa; padding: 15px; border-radius: 5px; border: 1px solid #ddd; white-space: pre-wrap; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 0.9em; line-height: 1.4; max-height: 400px; overflow-y: auto;"></pre>
                                <div style="margin-top: 15px; padding: 10px; background: #e8f5e8; border-radius: 5px; border-left: 4px solid #4CAF50;">
                                    <small><strong>💡 Tip:</strong> A good vessel context helps Claude provide more accurate and relevant insights for your specific vessel and operations.</small>
                                </div>
                            </div>
                        </div>

                        </div>
                    </div>
                    
                    <!-- Custom Analysis -->
                    <div style="margin-bottom: 30px;">
                        <h3>🎯 Custom Analysis</h3>
                        <div style="margin-top: 15px;">
                            <!-- Analysis Mode Toggle with Model Selector -->
                            <div style="margin-bottom: 20px; padding: 15px; border: 2px solid #e3f2fd; border-radius: 8px; background: #f8f9ff;">
                                <div style="margin-bottom: 10px;">
                                    <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; font-weight: bold;">
                                        <span>🚀 Direct Database Access</span>
                                        <input type="checkbox" id="enableDatabaseAccess" checked onchange="toggleAnalysisMode()" style="transform: scale(1.2);">
                                    </label>
                                </div>
                                <div style="font-size: 0.9em; color: #555;">
                                    <div id="legacyModeDesc" style="color: #666; display: none;">
                                        <strong>Legacy:</strong> Pre-load data samples for analysis (faster, limited scope)
                                    </div>
                                    <div id="databaseModeDesc" style="color: #1976d2;">
                                        <strong>Enhanced:</strong> Claude explores your database interactively (more powerful, complete historical access)
                                    </div>
                                </div>
                                
                                <!-- Claude Model Selection - moved here -->
                                <div style="margin-top: 15px;">
                                    <label for="claudeModelMain">Claude Model:</label>
                                    <select id="claudeModelMain" style="width: 100%; padding: 8px; margin-top: 5px;">
                                        <option value="claude-sonnet-4-20250514" selected>Claude Sonnet 4 - Latest Sonnet model (recommended)</option>
                                        <option value="claude-opus-4-1-20250805">Claude Opus 4.1 - Most powerful model (premium)</option>
                                        <option value="claude-opus-4-20250514">Claude Opus 4 - High performance model (premium)</option>
                                    </select>
                                    <p style="font-size: 0.9em; color: #666; margin: 5px 0 0 0;">Choose the Claude model for analysis. Sonnet provides the most detailed insights.</p>
                                </div>
                            </div>

                            <!-- Collapsible Selection Options -->
                            <div id="selectionOptionsSection" style="margin-bottom: 20px;">
                                <div onclick="toggleSelectionOptions()" style="cursor: pointer; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; user-select: none;">
                                    <span id="selectionToggleIcon" style="margin-right: 8px;">▶</span>
                                    <strong>Selection Options</strong>
                                    <span id="selectionToggleSubtext" style="font-size: 0.9em; color: #666; margin-left: 10px;">(Advanced options for legacy mode)</span>
                                </div>
                                <div id="selectionOptionsContainer" style="display: none; border: 1px solid #dee2e6; border-top: none; border-radius: 0 0 5px 5px; padding: 15px; background: #f9f9f9;">
                                    <!-- Data Path Selection -->
                                    <div style="margin-bottom: 15px;">
                                        <label>Data Paths (select one or more):</label>
                                        <div id="analysisDataPathContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-top: 5px; background: white;">
                                            <div style="color: #666; font-style: italic;">Loading available paths...</div>
                                        </div>
                                        <style>
                                            .path-checkbox-row {
                                                display: flex;
                                                align-items: center;
                                                padding: 8px 8px 8px 5px;
                                                margin: 2px 0;
                                                border-radius: 4px;
                                            }
                                            .path-checkbox-row:nth-child(odd) {
                                                background-color: #f8f9fa;
                                            }
                                            .path-checkbox-row:nth-child(even) {
                                                background-color: white;
                                            }
                                            .path-checkbox-row:hover {
                                                background-color: #e3f2fd;
                                            }
                                            .path-info {
                                                display: flex;
                                                align-items: center;
                                                flex-grow: 1;
                                            }
                                            .path-icon {
                                                margin-right: 8px;
                                                font-size: 16px;
                                            }
                                            .path-checkbox {
                                                margin-left: auto;
                                                width: 16px;
                                                height: 16px;
                                                flex-shrink: 0;
                                            }
                                        </style>
                                        <div style="margin-top: 5px; font-size: 0.9em; color: #666; display: flex; justify-content: space-between; align-items: center;">
                                            <span><span id="selectedPathCount">0</span> path(s) selected</span>
                                            <div>
                                                <button onclick="selectAllPaths()" style="font-size: 0.8em; padding: 2px 6px; margin-right: 5px;">Select All</button>
                                                <button onclick="clearAllPaths()" style="font-size: 0.8em; padding: 2px 6px;">Clear All</button>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Date Range Selection -->
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                        <div>
                                            <label for="analysisStartDate">Start Date:</label>
                                            <input type="datetime-local" id="analysisStartDate" style="width: 100%; padding: 8px; margin-top: 5px;">
                                        </div>
                                        <div>
                                            <label for="analysisEndDate">End Date:</label>
                                            <input type="datetime-local" id="analysisEndDate" style="width: 100%; padding: 8px; margin-top: 5px;">
                                        </div>
                                    </div>
                                    
                                    <!-- Aggregation Method -->
                                    <div style="margin-bottom: 15px;">
                                        <label for="aggregationMethod">Aggregation Method:</label>
                                        <select id="aggregationMethod" style="width: 100%; padding: 8px; margin-top: 5px;">
                                            <option value="average" selected>Average - Mean values over time buckets</option>
                                            <option value="min">Min - Minimum values over time buckets</option>
                                            <option value="max">Max - Maximum values over time buckets</option>
                                            <option value="first">First - First value in each time bucket</option>
                                            <option value="last">Last - Last value in each time bucket</option>
                                            <option value="mid">Median - Middle values over time buckets</option>
                                            <option value="multiple">Multiple - Get min, max, and average</option>
                                        </select>
                                    </div>
                                    
                                    <!-- Time Resolution -->
                                    <div style="margin-bottom: 15px;">
                                        <label for="resolution">Time Resolution:</label>
                                        <select id="resolution" style="width: 100%; padding: 8px; margin-top: 5px;">
                                            <option value="" selected>Auto - Automatically determine best resolution</option>
                                            <option value="1m">1 minute - Fine-grained data</option>
                                            <option value="5m">5 minutes - Detailed data</option>
                                            <option value="15m">15 minutes - Regular sampling</option>
                                            <option value="1h">1 hour - Hourly summaries</option>
                                            <option value="1d">1 day - Daily summaries</option>
                                        </select>
                                    </div>
                                    
                                </div>
                            </div>

                            <div style="margin-bottom: 15px;">
                                <label for="customPrompt">Custom Analysis Request (optional):</label>
                                <textarea id="customPrompt" placeholder="What specific insights are you looking for? Leave blank for general analysis..." style="width: 100%; padding: 8px; margin-top: 5px; min-height: 180px; resize: vertical;"></textarea>
                            </div>

                            <button onclick="runCustomAnalysis()" style="padding: 12px 25px; margin-top: 15px;">🚀 Run Custom Analysis</button>
                        </div>
                    </div>
                    
                    <!-- Analysis Results -->
                    <div id="analysisResults" style="display: none;">
                        <h3>📊 Analysis Results</h3>
                        <div id="analysisContent" style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 15px;">
                            <!-- Results will appear here -->
                        </div>
                        
                        <!-- Follow-up Questions -->
                        <div id="followUpSection" style="display: none; margin-top: 20px; padding: 15px; border: 2px solid #e8f4f8; border-radius: 8px; background: #f8fdff;">
                            <h4 style="margin: 0 0 10px 0; color: #1976d2;">💬 Ask Follow-up Questions</h4>
                            <p style="font-size: 0.9em; color: #666; margin: 0 0 15px 0;">Continue the conversation to explore your data deeper.</p>
                            <div style="display: flex; gap: 10px; align-items: flex-end;">
                                <div style="flex: 1;">
                                    <textarea id="followUpQuestion" placeholder="Ask Claude to explore further... (e.g., 'Show me wind patterns during high waves' or 'What happened around 3 PM?')" style="width: 100%; padding: 8px; min-height: 40px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
                                </div>
                                <button id="askFollowUpBtn" onclick="askFollowUpQuestion()" style="padding: 8px 15px; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">💬 Ask</button>
                            </div>
                        </div>
                    </div>
                    

                    <!-- Analysis History -->
                    <div style="margin-top: 30px;">
                        <h3>📈 Analysis History</h3>
                        <button onclick="openAnalysisHistoryModal()" id="loadHistoryBtn">📈 View Analysis History</button>
                        <p style="font-size: 0.9em; color: #666; margin-top: 10px;">View and manage your previous Claude AI analyses.</p>
                    </div>
                </div>
            </div>

            <!-- Data Validation Tab -->
            <div id="dataValidation" class="tab-panel">
                <div class="section">
                    <h2>🔍 Data Validation</h2>
                    <p>Validate parquet file schemas against SignalK metadata and schema guidelines:</p>
                    <div style="margin-bottom: 10px;">
                        <button onclick="runDataValidation()" id="validateBtn">🔍 Run Schema Validation</button>
                        <button onclick="repairSchemas()" id="repairBtn" style="margin-left: 10px;">🔧 Repair Schema Violations</button>
                    </div>
                    <div id="processTimer" style="background: rgb(227, 242, 253); border: 1px solid rgb(33, 150, 243); border-radius: 5px; padding: 10px; margin-bottom: 15px; text-align: center; font-family: monospace; display: none;">
                        <strong id="processIcon">🔍 Validation Timer</strong><br>
                        <span id="processStartTime">Process started: --:--:--</span><br>
                        <span id="processElapsed">Elapsed: 0.0s</span><br>
                        <span id="processProgress">Files processed: 0 of 0 (0%)</span>
                    </div>
                    <div id="validationStatus" style="margin-top: 10px;"></div>

                    <div id="validationResults" style="margin-top: 15px; display: none;">
                        <h3 id="validationSummaryHeader">Validation Summary</h3>
                        <div id="validationSummary" style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;"></div>

                        <h3 id="validationDetailsHeader">Schema Violations</h3>
                        <div id="validationDetails" style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background: white; font-family: monospace; font-size: 12px;"></div>
                    </div>
                </div>
            </div>

            <!-- S3 Configuration Tab -->
            <div id="s3Config" class="tab-panel">
                <div class="section">
                    <h2>☁️ Cloud Status</h2>
            <p>Test your S3 connection and understand the Key Prefix functionality:</p>
            <button onclick="testS3Connection()">🔗 Test S3 Connection</button>
            <div id="s3TestResult" style="margin-top: 10px;"></div>
            
            <div style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                <h4>📋 S3 Key Prefix Explanation</h4>
                <p><strong>S3 Key Prefix</strong> organizes your uploaded files in the S3 bucket with a directory structure:</p>
                <ul style="margin: 10px 0; padding-left: 20px;">
                    <li><strong>Without prefix:</strong> Files upload as <code>vessels/self/navigation/position/2025-07-12.parquet</code></li>
                    <li><strong>With prefix "marine-data":</strong> Files upload as <code>marine-data/vessels/self/navigation/position/2025-07-12.parquet</code></li>
                    <li><strong>With prefix "boat-123/":</strong> Files upload as <code>boat-123/vessels/self/navigation/position/2025-07-12.parquet</code></li>
                </ul>
                    <p>This allows organizing multiple vessels or data sources in the same S3 bucket.</p>
                </div>
                </div>
            </div>

            <!-- Data Paths Tab -->
            <div id="dataPaths" class="tab-panel">
                <div class="section">
                    <h2>🗄️ Query Database</h2>
                <p>Available SignalK data paths with Parquet files:</p>
                    <div id="availablePaths">
                        <div class="loading">Loading available paths...</div>
                    </div>
                    
                    <!-- Query Section for Data Paths -->
                    <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                        <h3>Query Data</h3>
                        <div class="form-group">
                            <label for="dataPathsQueryInput">DuckDB SQL Query:</label>
                            <textarea id="dataPathsQueryInput" placeholder="SELECT * FROM read_parquet('path/to/file.parquet', union_by_name=true) LIMIT 10"></textarea>
                        </div>
                        <button onclick="executeDataPathsQuery()">▶️ Execute Query</button>
                        <button class="btn-secondary" onclick="clearDataPathsQuery()">🗑️ Clear</button>
                        
                        <div id="dataPathsResultsContainer" class="results">
                            <p>Run a query to see results here...</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        let availablePaths = [];
        let dataDirectory = '';
        let showCommandPaths = false; // Default to hiding command paths
        let currentAnalysisId = null; // Track current analysis for follow-up questions

        // Get the plugin path dynamically
        function getPluginPath() {
            // Get the current script's path to determine the plugin name
            const currentPath = window.location.pathname;
            const pathParts = currentPath.split('/');
            const pluginIndex = pathParts.indexOf('plugins');
            
            if (pluginIndex !== -1 && pathParts[pluginIndex + 1]) {
                return `/plugins/${pathParts[pluginIndex + 1]}`;
            }
            
            // Fallback to the plugin name from package.json
            return '/plugins/signalk-parquet';
        }

        // Load available paths on page load
        window.addEventListener('load', async function() {
            await loadAvailablePaths();
            await loadPathConfigurations();
            generateExampleQueries();
        });

        async function loadAvailablePaths() {
            try {
                const response = await fetch(`${getPluginPath()}/api/paths`);
                const result = await response.json();
                
                if (result.success) {
                    availablePaths = result.paths;
                    dataDirectory = result.dataDirectory;
                    displayAvailablePaths();
                } else {
                    document.getElementById('availablePaths').innerHTML = 
                        `<div class="error">Error loading paths: ${result.error}</div>`;
                }
            } catch (error) {
                document.getElementById('availablePaths').innerHTML = 
                    `<div class="error">Network error: ${error.message}</div>`;
            }
        }

        function displayAvailablePaths() {
            const container = document.getElementById('availablePaths');

            if (availablePaths.length === 0) {
                container.innerHTML = '<p>No Parquet data files found. Start collecting data first.</p>';
                return;
            }

            let html = `
                <div class="path-dropdown-container">
                    <div style="margin-bottom: 15px;">
                        <label for="pathDropdown" style="display: block; margin-bottom: 5px; font-weight: 500;">Select Data Path:</label>
                        <select id="pathDropdown" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;" onchange="updateSelectedPath()">
                            <option value="">-- Select a data path --</option>
            `;

            availablePaths.forEach((pathInfo, index) => {
                html += `<option value="${index}">${pathInfo.path} (${pathInfo.fileCount} files)</option>`;
            });

            html += `
                        </select>
                    </div>

                    <div id="pathActions" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                        <div style="margin-bottom: 10px;">
                            <strong id="selectedPathName"></strong>
                            <span id="selectedPathFiles" style="color: #666; margin-left: 10px;"></span>
                        </div>
                        <button id="generateQueryBtn" onclick="generateQueryForSelectedPath()" style="background: #28a745; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; margin-right: 10px;">📋 Generate Query</button>
                        <button id="analyzeBtn" onclick="analyzeSelectedPath()" style="background: #667eea; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer;">🧠 Analyze</button>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        // Dropdown-related functions
        function updateSelectedPath() {
            const dropdown = document.getElementById('pathDropdown');
            const actionsDiv = document.getElementById('pathActions');
            const pathNameSpan = document.getElementById('selectedPathName');
            const pathFilesSpan = document.getElementById('selectedPathFiles');

            if (dropdown.value === '') {
                actionsDiv.style.display = 'none';
                return;
            }

            const selectedIndex = parseInt(dropdown.value);
            const pathInfo = availablePaths[selectedIndex];

            pathNameSpan.textContent = pathInfo.path;
            pathFilesSpan.textContent = `(${pathInfo.fileCount} files)`;
            actionsDiv.style.display = 'block';
        }

        function generateQueryForSelectedPath() {
            const dropdown = document.getElementById('pathDropdown');
            if (dropdown.value === '') return;

            const selectedIndex = parseInt(dropdown.value);
            const pathInfo = availablePaths[selectedIndex];
            generateQueryForPath(pathInfo.path, pathInfo.directory);
        }

        function analyzeSelectedPath() {
            const dropdown = document.getElementById('pathDropdown');
            if (dropdown.value === '') return;

            const selectedIndex = parseInt(dropdown.value);
            const pathInfo = availablePaths[selectedIndex];
            analyzeDataPath(pathInfo.path, pathInfo.directory);
        }

        function generateQueryForPath(signalkPath, directory) {
            const query = `SELECT * FROM read_parquet('${directory}/*.parquet', union_by_name=true) ORDER BY received_timestamp DESC LIMIT 10`;
            setDataPathsQuery(query);
        }


        function generateExampleQueries() {
            const container = document.getElementById('queryExamples');
            
            if (availablePaths.length === 0) {
                container.innerHTML = '<li><em>No data paths available yet. Start collecting data first.</em></li>';
                return;
            }

            let html = '';
            
            // Generate examples based on available paths
            availablePaths.slice(0, 4).forEach(pathInfo => {
                const examples = [
                    `SELECT * FROM read_parquet('${pathInfo.directory}/*.parquet', union_by_name=true) ORDER BY received_timestamp DESC LIMIT 10`,
                    `SELECT COUNT(*) as total_records FROM read_parquet('${pathInfo.directory}/*.parquet', union_by_name=true)`,
                    `SELECT received_timestamp, value, source_label FROM read_parquet('${pathInfo.directory}/*.parquet', union_by_name=true) WHERE value IS NOT NULL ORDER BY received_timestamp DESC LIMIT 10`
                ];
                
                examples.forEach(query => {
                    html += `<li onclick="setQuery(this.textContent)"><code>${query}</code></li>`;
                });
            });

            container.innerHTML = html;
        }

        async function executeQuery() {
            const query = document.getElementById('queryInput').value.trim();
            if (!query) {
                alert('Please enter a query');
                return;
            }

            const resultsContainer = document.getElementById('customQueryResultsContainer');
            resultsContainer.innerHTML = '<div class="loading">Executing query...</div>';

            try {
                const response = await fetch('/plugins/signalk-parquet/api/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query })
                });

                const result = await response.json();

                if (result.success) {
                    displayResults(result, 'customQueryResultsContainer');
                } else {
                    resultsContainer.innerHTML = `<div class="error">Query error: ${result.error}</div>`;
                }
            } catch (error) {
                resultsContainer.innerHTML = `<div class="error">Network error: ${error.message}</div>`;
            }
        }

        async function executeDataPathsQuery() {
            const query = document.getElementById('dataPathsQueryInput').value.trim();
            if (!query) {
                alert('Please enter a query');
                return;
            }

            const resultsContainer = document.getElementById('dataPathsResultsContainer');
            resultsContainer.innerHTML = '<div class="loading">Executing query...</div>';

            try {
                const response = await fetch('/plugins/signalk-parquet/api/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query })
                });

                const result = await response.json();

                if (result.success) {
                    displayResults(result, 'dataPathsResultsContainer');
                } else {
                    resultsContainer.innerHTML = `<div class="error">Query error: ${result.error}</div>`;
                }
            } catch (error) {
                resultsContainer.innerHTML = `<div class="error">Network error: ${error.message}</div>`;
            }
        }

        function displayResults(result, containerId = 'resultsContainer') {
            const container = document.getElementById(containerId);
            
            if (!result.data || result.data.length === 0) {
                container.innerHTML = '<p>No data returned from query.</p>';
                return;
            }

            // Stats
            let statsHtml = `
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value">${result.rowCount}</div>
                        <div class="stat-label">Rows</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${Object.keys(result.data[0]).length}</div>
                        <div class="stat-label">Columns</div>
                    </div>
                </div>
            `;

            // Table
            const columns = Object.keys(result.data[0]);
            let tableHtml = '<div class="table-container"><table><thead><tr>';
            
            columns.forEach(col => {
                tableHtml += `<th>${col}</th>`;
            });
            tableHtml += '</tr></thead><tbody>';

            result.data.forEach(row => {
                tableHtml += '<tr>';
                columns.forEach(col => {
                    let value = row[col];
                    if (value === null || value === undefined) {
                        value = '';
                    } else if (typeof value === 'object') {
                        value = JSON.stringify(value);
                    }
                    tableHtml += `<td>${value}</td>`;
                });
                tableHtml += '</tr>';
            });

            tableHtml += '</tbody></table></div>';

            container.innerHTML = statsHtml + tableHtml;
        }

        function setQuery(query) {
            document.getElementById('queryInput').value = query;
        }

        function setDataPathsQuery(query) {
            document.getElementById('dataPathsQueryInput').value = query;
        }

        function clearQuery() {
            document.getElementById('queryInput').value = '';
            document.getElementById('customQueryResultsContainer').innerHTML = '<p>Run a query to see results here...</p>';
        }

        function clearDataPathsQuery() {
            document.getElementById('dataPathsQueryInput').value = '';
            document.getElementById('dataPathsResultsContainer').innerHTML = '<p>Run a query to see results here...</p>';
        }

        function showTab(tabId) {
            // Hide all tab panels
            const tabPanels = document.querySelectorAll('.tab-panel');
            tabPanels.forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Show the selected tab panel
            const selectedPanel = document.getElementById(tabId);
            if (selectedPanel) {
                selectedPanel.classList.add('active');
            }
            
            // Add active class to the clicked tab button
            const clickedButton = document.querySelector(`[onclick="showTab('${tabId}')"]`);
            if (clickedButton) {
                clickedButton.classList.add('active');
            }
            
            // Initialize AI Analysis tab when it becomes active
            if (tabId === 'aiAnalysis') {
                initializeAIAnalysisTab();
            }

            // Auto-refresh commands when Command Manager tab becomes active
            if (tabId === 'commandManager') {
                loadCommands();
            }
        }

        // Global variables for validation cancellation
        let currentValidationController = null;
        let currentRepairController = null;
        let currentValidationJobId = null;
        let validationCancelRequested = false;
        let currentRepairJobId = null;
        let repairCancelRequested = false;

        // Cancel current validation
        function cancelValidation() {
            if (validationCancelRequested) {
                return;
            }

            const cancelBtn = document.getElementById('cancelValidationBtn');
            const validateBtn = document.getElementById('validateBtn');

            if (currentValidationJobId) {
                validationCancelRequested = true;
                if (cancelBtn) {
                    cancelBtn.disabled = true;
                    cancelBtn.textContent = 'Cancelling...';
                }
                if (validateBtn) {
                    validateBtn.textContent = '⏳ Cancelling validation...';
                    validateBtn.disabled = true;
                }

                fetch(`/plugins/signalk-parquet/api/validate-schemas/cancel/${currentValidationJobId}`, {
                    method: 'POST'
                }).then(response => {
                    if (!response.ok) {
                        console.error('Cancel validation request failed:', response.status);
                    }
                }).catch(error => {
                    console.error('Cancel validation request error:', error);
                });
            } else if (currentValidationController) {
                validationCancelRequested = true;
                currentValidationController.abort();
                currentValidationController = null;
                if (cancelBtn) {
                    cancelBtn.disabled = true;
                    cancelBtn.textContent = 'Cancelling...';
                }
                if (validateBtn) {
                    validateBtn.textContent = '⏳ Cancelling validation...';
                    validateBtn.disabled = true;
                }
            }
        }

        // Cancel current repair
        function cancelRepair() {
            if (repairCancelRequested) {
                return;
            }

            repairCancelRequested = true;

            const repairBtn = document.getElementById('repairBtn');
            if (repairBtn) {
                repairBtn.textContent = '⏳ Cancelling repair...';
                repairBtn.disabled = true;
            }

            if (currentRepairJobId) {
                fetch(`/plugins/signalk-parquet/api/repair-schemas/cancel/${currentRepairJobId}`, {
                    method: 'POST'
                }).catch(error => {
                    console.error('Cancel repair request error:', error);
                });
            }
        }

        // Poll for validation progress
        async function pollValidationProgress(jobId, timerElement, startTime, abortSignal) {
            let polling = true;
            let lastProgress = null;

            while (polling) {
                try {
                    if (abortSignal?.aborted) {
                        throw new DOMException('Validation polling aborted', 'AbortError');
                    }

                    const response = await fetch(`/plugins/signalk-parquet/api/validate-schemas/progress/${jobId}`, {
                        signal: abortSignal,
                        cache: 'no-store'
                    });

                    if (!response.ok) {
                        console.error('Failed to get progress:', response.status);
                        break;
                    }

                    const progress = await response.json();
                    lastProgress = progress;

                    const processed = progress.processed ?? 0;
                    const total = progress.total ?? 0;
                    const percent = progress.percent ?? (total > 0 ? Math.round((processed / total) * 100) : 0);
                    const elapsed = (new Date() - startTime) / 1000;

                    const vessel = progress.currentVessel || 'Detecting vessel...';
                    const contextPath = progress.currentRelativePath || progress.currentFile || 'Processing...';
                    const isCancelling = progress.status === 'cancelling' || progress.cancelRequested;
                    const statusText = progress.status === 'cancelled'
                        ? 'Status: Cancelled'
                        : isCancelling
                            ? 'Status: Cancelling...'
                            : 'Status: Running';
                    const statusColor = progress.status === 'cancelled'
                        ? '#d32f2f'
                        : isCancelling
                            ? '#b36b00'
                            : '#666';

                    if (isCancelling) {
                        validationCancelRequested = true;
                    }

                    timerElement.innerHTML = `
                        <strong>⏱️ Validation Progress</strong><br>
                        Started: ${startTime.toLocaleTimeString()}<br>
                        Elapsed: ${elapsed.toFixed(1)}s<br>
                        <strong>Files: ${processed.toLocaleString()} / ${total.toLocaleString()} (${percent}%)</strong><br>
                        <span style="font-size: 0.9em; color: #666;">Vessel: ${vessel}</span><br>
                        <span style="font-size: 0.9em; color: #666;">Current: ${contextPath}</span><br>
                        <span style="font-size: 0.9em; color: ${statusColor};">${statusText}</span>
                    `;

                    if (progress.status === 'completed' || progress.status === 'cancelled' || progress.status === 'error') {
                        polling = false;

                        const endTime = new Date();
                        const totalTime = (endTime - startTime) / 1000;

                        if (progress.status === 'completed') {
                            timerElement.innerHTML = `
                                <strong>⏱️ Validation Complete</strong><br>
                                Started: ${startTime.toLocaleTimeString()}<br>
                                Completed: ${endTime.toLocaleTimeString()}<br>
                                <strong>Total Time: ${totalTime.toFixed(1)}s</strong><br>
                                <strong>📁 Files: ${total.toLocaleString()} (100%)</strong>
                            `;
                            timerElement.style.background = '#e8f5e8';
                            timerElement.style.borderColor = '#4caf50';
                        } else if (progress.status === 'cancelled') {
                            timerElement.innerHTML = `
                                <strong>❌ Validation Cancelled</strong><br>
                                Started: ${startTime.toLocaleTimeString()}<br>
                                Cancelled: ${endTime.toLocaleTimeString()}<br>
                                <strong>Time: ${totalTime.toFixed(1)}s</strong>
                            `;
                            timerElement.style.background = '#fff3cd';
                            timerElement.style.borderColor = '#ffc107';
                        } else if (progress.status === 'error') {
                            timerElement.innerHTML = `
                                <strong>⏱️ Validation Failed</strong><br>
                                Started: ${startTime.toLocaleTimeString()}<br>
                                Failed: ${endTime.toLocaleTimeString()}<br>
                                <strong>Total Time: ${totalTime.toFixed(1)}s</strong>
                            `;
                            timerElement.style.background = '#ffeaea';
                            timerElement.style.borderColor = '#f44336';
                        }
                    }

                    await new Promise(resolve => setTimeout(resolve, 500));

                } catch (error) {
                    if (error.name === 'AbortError') {
                        return lastProgress;
                    }
                    console.error('Progress polling error:', error);
                    break;
                }
            }

            return lastProgress;
        }

        // Poll for repair progress
        async function pollRepairProgress(jobId, timerElement, startTime, abortSignal) {
            let polling = true;
            let lastProgress = null;

            while (polling) {
                try {
                    if (abortSignal?.aborted) {
                        throw new DOMException('Repair polling aborted', 'AbortError');
                    }

                    const response = await fetch(`/plugins/signalk-parquet/api/repair-schemas/progress/${jobId}`, {
                        signal: abortSignal,
                        cache: 'no-store'
                    });

                    if (!response.ok) {
                        console.error('Failed to get repair progress:', response.status);
                        break;
                    }

                    const progress = await response.json();
                    lastProgress = progress;

                    const processed = progress.processed ?? 0;
                    const total = progress.total ?? 0;
                    const percent = progress.percent ?? (total > 0 ? Math.round((processed / total) * 100) : 0);
                    const elapsed = (new Date() - startTime) / 1000;
                    const statusText = progress.message || 'Repair in progress';
                    const statusColor = progress.status === 'cancelled'
                        ? '#d32f2f'
                        : progress.status === 'cancelling'
                            ? '#b36b00'
                            : '#666';

                    timerElement.innerHTML = [
                        '<strong>🔧 Repair Progress</strong><br>',
                        `Started: ${startTime.toLocaleTimeString()}<br>`,
                        `Elapsed: ${elapsed.toFixed(1)}s<br>`,
                        `<strong>Files: ${processed.toLocaleString()} / ${total.toLocaleString()} (${percent}%)</strong><br>`,
                        progress.currentFile ? `<span style="font-size: 0.9em; color: #666;">Current: ${progress.currentFile}</span><br>` : '',
                        `<span style="font-size: 0.9em; color: ${statusColor};">${statusText}</span>`
                    ].filter(Boolean).join('');

                    if (progress.status === 'completed' || progress.status === 'cancelled' || progress.status === 'error') {
                        polling = false;
                        const endTime = new Date();
                        const totalTime = (endTime - startTime) / 1000;
                        lastProgress.completedAt = endTime;

                        if (progress.status === 'completed') {
                            timerElement.innerHTML = [
                                '<strong>✅ Repair Completed</strong><br>',
                                `Started: ${startTime.toLocaleTimeString()}<br>`,
                                `Ended: ${endTime.toLocaleTimeString()}<br>`,
                                `<strong>Total Time: ${totalTime.toFixed(1)}s</strong>`
                            ].join('');
                            timerElement.style.background = '#e8f5e8';
                            timerElement.style.borderColor = '#4caf50';
                        } else if (progress.status === 'cancelled') {
                            timerElement.innerHTML = [
                                '<strong>❌ Repair Cancelled</strong><br>',
                                `Started: ${startTime.toLocaleTimeString()}<br>`,
                                `Cancelled: ${endTime.toLocaleTimeString()}<br>`,
                                `<strong>Total Time: ${totalTime.toFixed(1)}s</strong>`
                            ].join('');
                            timerElement.style.background = '#fff3cd';
                            timerElement.style.borderColor = '#ffc107';
                        } else if (progress.status === 'error') {
                            timerElement.innerHTML = [
                                '<strong>⛔ Repair Failed</strong><br>',
                                `Started: ${startTime.toLocaleTimeString()}<br>`,
                                `Ended: ${endTime.toLocaleTimeString()}<br>`,
                                `<strong>Total Time: ${totalTime.toFixed(1)}s</strong>`
                            ].join('');
                            timerElement.style.background = '#ffeaea';
                            timerElement.style.borderColor = '#f44336';
                        }
                    }

                    await new Promise(resolve => setTimeout(resolve, 500));

                } catch (error) {
                    if (error.name === 'AbortError') {
                        return lastProgress;
                    }
                    console.error('Repair progress polling error:', error);
                    break;
                }
            }

            return lastProgress;
        }

        async function runDataValidation() {
            const statusDiv = document.getElementById('validationStatus');
            const resultsDiv = document.getElementById('validationResults');
            const summaryDiv = document.getElementById('validationSummary');
            const detailsDiv = document.getElementById('validationDetails');
            const summaryHeader = document.getElementById('validationSummaryHeader');
            const detailsHeader = document.getElementById('validationDetailsHeader');
            const button = document.getElementById('validateBtn');
            const repairBtn = document.getElementById('repairBtn');

            validationCancelRequested = false;
            currentValidationJobId = null;

            // Show loading state with cancel button and timer
            button.textContent = '⏸️ Running Validation (click to cancel)';
            button.style.background = '#ffc107';
            button.onclick = cancelValidation;
            if (repairBtn) {
                repairBtn.style.display = 'inline-block';
                repairBtn.disabled = true;
            }

            // Start timer
            const startTime = new Date();
            const timerElement = document.createElement('div');
            timerElement.id = 'validationTimer';
            timerElement.style.cssText = 'background: #e3f2fd; border: 1px solid #2196f3; border-radius: 5px; padding: 15px; margin-bottom: 15px; text-align: center; font-family: monospace; box-shadow: 0 2px 4px rgba(0,0,0,0.1);';

            statusDiv.innerHTML = '';
            statusDiv.appendChild(timerElement);
            resultsDiv.style.display = 'none';
            summaryDiv.innerHTML = '';
            detailsDiv.innerHTML = '';
            summaryDiv.style.display = 'none';
            if (summaryHeader) summaryHeader.style.display = 'none';
            if (detailsHeader) detailsHeader.style.display = 'none';

            // Update timer every 100ms - NO FAKE PROGRESS
            const timerInterval = setInterval(() => {
                const elapsed = (new Date() - startTime) / 1000;

                timerElement.innerHTML = `
                    <strong>⏱️ Validation Timer</strong><br>
                    Started: ${startTime.toLocaleTimeString()}<br>
                    Elapsed: ${elapsed.toFixed(1)}s<br>
                    <span id="validationProgress" style="font-size: 0.9em; color: #666;">Running validation...</span>
                `;
            }, 100);

            const controller = new AbortController();
            currentValidationController = controller;

            try {
                // Set flag to track running validation
                currentValidationController = true;

                const response = await fetch('/plugins/signalk-parquet/api/validate-schemas', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    signal: controller.signal
                });
                console.log('✅ Fetch completed, response status:', response.status);

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.message || 'Validation failed');
                }

                let finalProgress = null;

                // Start polling for progress if we got a jobId
                if (result.jobId) {
                    console.log('📋 Starting progress polling for job:', result.jobId);
                    currentValidationJobId = result.jobId;
                    clearInterval(timerInterval); // Stop the basic timer since we're switching to progress polling
                    finalProgress = await pollValidationProgress(result.jobId, timerElement, startTime, controller.signal);
                } else {
                    // Old style response without polling
                    console.log('⚠️ No jobId in response, using old style completion');
                }

                // Stop timer and show final time
                clearInterval(timerInterval);
                const endTime = new Date();
                const totalTime = (endTime - startTime) / 1000;

                const summaryData = finalProgress?.result || result;
                const overallTotal = finalProgress?.total ?? summaryData?.totalFiles ?? 0;

                if (summaryData) {
                    const totalFiles = summaryData.totalFiles ?? 0;
                    const totalVessels = summaryData.totalVessels ?? 0;
                    const correctSchemas = summaryData.correctSchemas ?? 0;
                    const violations = summaryData.violations ?? 0;
                    const isCancelled = Boolean(summaryData.cancelled || summaryData.error === 'Validation cancelled by user');
                    const isSuccess = Boolean(summaryData.success && !isCancelled);
                    const errorMessage = summaryData.error || summaryData.message || '';
                    const header = isCancelled
                        ? '❌ Validation Cancelled'
                        : isSuccess
                            ? '⏱️ Validation Complete'
                            : '⛔ Validation Failed';
                    const background = isCancelled ? '#fff3cd' : (isSuccess ? '#e8f5e8' : '#ffeaea');
                    const border = isCancelled ? '#ffc107' : (isSuccess ? '#4caf50' : '#f44336');
                    const successRate = totalFiles > 0
                        ? ((correctSchemas / totalFiles) * 100).toFixed(1)
                        : '0.0';

                    const filesLabel = isCancelled ? 'Processed files' : 'Total files';
                    const vesselsLabel = isCancelled ? 'Vessels encountered' : 'Total vessels';
                    const correctLabel = isCancelled ? 'Correct schemas (processed)' : 'Correct schemas';
                    const violationsLabel = isCancelled ? 'Detected schema issues' : 'Schema violations';

                    const statsLines = [
                        `<div style="display: flex; justify-content: space-between; margin-bottom: 6px;"><span>📁 <strong>${filesLabel}:</strong></span> <span style="font-weight: bold;">${totalFiles.toLocaleString()}${isCancelled && overallTotal ? ` / ${overallTotal.toLocaleString()}` : isSuccess ? ' (100%)' : ''}</span></div>`,
                        `<div style="display: flex; justify-content: space-between; margin-bottom: 6px;"><span>🚢 <strong>${vesselsLabel}:</strong></span> <span style="font-weight: bold;">${totalVessels.toLocaleString()}</span></div>`,
                        `<div style="display: flex; justify-content: space-between; margin-bottom: 6px;"><span>✅ <strong>${correctLabel}:</strong></span> <span style="font-weight: bold; color: #4caf50;">${correctSchemas.toLocaleString()}</span></div>`,
                        `<div style="display: flex; justify-content: space-between; margin-bottom: 6px;"><span>❌ <strong>${violationsLabel}:</strong></span> <span style="font-weight: bold; color: ${violations > 0 ? '#f44336' : '#4caf50'};">${violations.toLocaleString()}</span></div>`,
                        `<div style="display: flex; justify-content: space-between;"><span>📊 <strong>${isCancelled ? 'Processed success rate' : 'Success rate'}:</strong></span> <span style="font-weight: bold; color: ${parseFloat(successRate) === 100 ? '#4caf50' : '#ff9800'};">${successRate}%</span></div>`
                    ].join('');

                    const statusNote = isCancelled && overallTotal
                        ? '<div style="margin-top: 8px; color: #b36b00;">Cancellation requested during processing. Only partial results are available.</div>'
                        : (!isSuccess && !isCancelled && errorMessage
                            ? `<div style="margin-top: 8px; color: #d32f2f;">${errorMessage}</div>`
                            : '');

                    timerElement.innerHTML = [
                        `<strong>${header}</strong><br>`,
                        `Started: ${startTime.toLocaleTimeString()}<br>`,
                        `Ended: ${endTime.toLocaleTimeString()}<br>`,
                        `<strong>Total Time: ${totalTime.toFixed(1)}s</strong>`,
                        `<div style="margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.3); border-radius: 4px; text-align: left; line-height: 1.8; font-size: 14px;">${statsLines}</div>`,
                        statusNote
                    ].filter(Boolean).join('');
                    timerElement.style.background = background;
                    timerElement.style.borderColor = border;

                    if (isSuccess || isCancelled) {
                        const hasViolations = Array.isArray(summaryData.violationDetails) && summaryData.violationDetails.length > 0;

                        if (hasViolations) {
                            if (summaryHeader) {
                                summaryHeader.style.display = 'none';
                            }
                            summaryDiv.style.display = 'none';
                            summaryDiv.innerHTML = '';

                            if (detailsHeader) {
                                detailsHeader.style.display = 'block';
                                detailsHeader.textContent = `Schema Violations (${violations.toLocaleString()})`;
                            }
                            detailsDiv.innerHTML = summaryData.violationDetails.join('\n');
                            resultsDiv.style.display = 'block';
                        } else {
                            if (summaryHeader) summaryHeader.style.display = 'none';
                            if (detailsHeader) detailsHeader.style.display = 'none';
                            summaryDiv.style.display = 'none';
                            summaryDiv.innerHTML = '';
                            detailsDiv.innerHTML = '';
                            resultsDiv.style.display = 'none';
                        }

                        if (repairBtn) {
                            repairBtn.style.display = 'inline-block';
                            repairBtn.disabled = violations === 0;
                        }
                    } else {
                        if (summaryHeader) {
                            summaryHeader.style.display = 'block';
                            summaryHeader.textContent = 'Validation Summary';
                        }
                        if (detailsHeader) detailsHeader.style.display = 'none';
                        summaryDiv.innerHTML = errorMessage ? `❌ ${errorMessage}` : 'Validation failed.';
                        summaryDiv.style.display = summaryDiv.innerHTML ? 'block' : 'none';
                        detailsDiv.innerHTML = '';
                        resultsDiv.style.display = summaryDiv.innerHTML ? 'block' : 'none';

                        if (repairBtn) {
                            repairBtn.style.display = 'inline-block';
                            repairBtn.disabled = true;
                        }
                    }
                }
            } catch (error) {
                // Stop timer on error
                clearInterval(timerInterval);
                const endTime = new Date();
                const totalTime = (endTime - startTime) / 1000;

                // Check if it was cancelled
                if (error.name === 'AbortError') {
                    // Try to get progress info from the server response if available
                    let progressInfo = '';
                    let violationCount = 0;
                    try {
                        if (currentValidationJobId) {
                            const progressResponse = await fetch(`/plugins/signalk-parquet/api/validate-schemas/progress/${currentValidationJobId}`, {
                                cache: 'no-store'
                            });
                            if (progressResponse.ok) {
                                const cancelData = await progressResponse.json();
                                if (cancelData.result && Array.isArray(cancelData.result.violationFiles)) {
                                    violationCount = cancelData.result.violationFiles.length;
                                }
                                if (cancelData.processed !== undefined && cancelData.total !== undefined) {
                                    const percentage = cancelData.total > 0
                                        ? Math.round((cancelData.processed / cancelData.total) * 100)
                                        : 0;
                                    progressInfo = `<br><strong>Progress: ${cancelData.processed.toLocaleString()}/${cancelData.total.toLocaleString()} files (${percentage}%)</strong>`;
                                }
                            }
                        }
                    } catch (parseError) {
                        // Ignore parse errors, just show basic cancellation
                    }

                    timerElement.innerHTML = `
                        <strong>❌ Validation Cancelled</strong><br>
                        Started: ${startTime.toLocaleTimeString()}<br>
                        Cancelled: ${endTime.toLocaleTimeString()}<br>
                        <strong>Time: ${totalTime.toFixed(1)}s</strong>${progressInfo}
                    `;
                    timerElement.style.background = '#fff3cd';
                    timerElement.style.borderColor = '#ffc107';

                    if (repairBtn) {
                        repairBtn.style.display = 'inline-block';
                        repairBtn.disabled = violationCount === 0;
                    }
                } else {
                    timerElement.innerHTML = `
                        <strong>⏱️ Validation Failed</strong><br>
                        Started: ${startTime.toLocaleTimeString()}<br>
                        Failed: ${endTime.toLocaleTimeString()}<br>
                        <strong>Total Time: ${totalTime.toFixed(1)}s</strong>
                    `;
                    timerElement.style.background = '#ffeaea';
                    timerElement.style.borderColor = '#f44336';
                    console.error('Validation error:', error);
                }

                if (repairBtn) {
                    repairBtn.style.display = 'inline-block';
                    repairBtn.disabled = true;
                }
            } finally {
                currentValidationJobId = null;
                validationCancelRequested = false;
                currentValidationController = null;
                button.onclick = runDataValidation;
                button.disabled = false;
                button.textContent = '🔍 Run Schema Validation';
                button.style.background = '';
            }
        }

        async function repairSchemas() {
            const statusDiv = document.getElementById('validationStatus');
            const repairBtn = document.getElementById('repairBtn');
            const validateBtn = document.getElementById('validateBtn');

            // If a job is already running, treat the click as a cancel request
            if (currentRepairJobId || currentRepairController) {
                cancelRepair();
                return;
            }

            repairCancelRequested = false;
            currentRepairJobId = null;

            repairBtn.textContent = '⏸️ Repairing Schemas (click to cancel)';
            repairBtn.style.background = '#ffc107';
            repairBtn.onclick = cancelRepair;
            repairBtn.disabled = false;

            const startTime = new Date();
            const timerElement = document.createElement('div');
            timerElement.id = 'repairTimer';
            timerElement.style.cssText = 'background: #e3f2fd; border: 1px solid #2196f3; border-radius: 5px; padding: 10px; margin-bottom: 15px; text-align: center; font-family: monospace;';
            timerElement.innerHTML = `
                <strong>🔧 Repair Timer</strong><br>
                Started: ${startTime.toLocaleTimeString()}<br>
                Elapsed: 0.0s<br>
                <span style="font-size: 0.9em; color: #666;">Preparing repair job...</span>
            `;

            statusDiv.innerHTML = '';
            statusDiv.appendChild(timerElement);

            const timerInterval = setInterval(() => {
                const elapsed = (new Date() - startTime) / 1000;
                timerElement.innerHTML = `
                    <strong>🔧 Repair Timer</strong><br>
                    Started: ${startTime.toLocaleTimeString()}<br>
                    Elapsed: ${elapsed.toFixed(1)}s<br>
                    <span style="font-size: 0.9em; color: #666;">Preparing repair job...</span>
                `;
            }, 100);

            let finalProgress = null;

            try {
                // Set flag to track running repair
                currentRepairController = true;

                const response = await fetch('/plugins/signalk-parquet/api/repair-schemas', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.message || 'Repair failed');
                }

                if (!result.jobId) {
                    timerElement.innerHTML = '<strong>❌ Repair response missing job ID</strong>';
                    timerElement.style.background = '#ffeaea';
                    timerElement.style.borderColor = '#f44336';
                    return;
                }

                currentRepairJobId = result.jobId;
                currentRepairController = new AbortController();

                clearInterval(timerInterval);
                finalProgress = await pollRepairProgress(result.jobId, timerElement, startTime, currentRepairController.signal);

                if (finalProgress && finalProgress.result) {
                    const { repairedFiles, backedUpFiles, skippedFiles, quarantinedFiles, errors, message } = finalProgress.result;
                    const summaryLines = [
                        `<strong>${message || 'Repair summary'}</strong>`,
                        `✅ Repaired: ${repairedFiles.toLocaleString()}`,
                        `📦 Backups created: ${backedUpFiles.toLocaleString()}`,
                        `⏭️ Skipped (already clean): ${skippedFiles.length.toLocaleString()}`,
                        `🚫 Quarantined: ${quarantinedFiles.length.toLocaleString()}`,
                        `⚠️ Errors: ${errors.length.toLocaleString()}`
                    ];

                    timerElement.innerHTML = summaryLines.join('<br>');

                    if (errors.length > 0) {
                        const errorList = document.createElement('div');
                        errorList.style.cssText = 'margin-top: 10px; background: #fff3f3; border: 1px solid #f44336; padding: 10px; font-size: 12px; max-height: 150px; overflow-y: auto;';
                        errorList.innerHTML = errors.map(err => `❌ ${err}`).join('<br>');
                        timerElement.appendChild(errorList);
                    }

                    if (finalProgress.status === 'completed') {
                        timerElement.style.background = '#e8f5e8';
                        timerElement.style.borderColor = '#4caf50';
                    } else if (finalProgress.status === 'cancelled') {
                        timerElement.style.background = '#fff3cd';
                        timerElement.style.borderColor = '#ffc107';
                    } else if (finalProgress.status === 'error') {
                        timerElement.style.background = '#ffeaea';
                        timerElement.style.borderColor = '#f44336';
                    }

                }

            } catch (error) {
                clearInterval(timerInterval);
                timerElement.innerHTML = `<strong>❌ Repair Error</strong><br>${error.message}`;
                timerElement.style.background = '#ffeaea';
                timerElement.style.borderColor = '#f44336';
                console.error('Repair error:', error);
            } finally {
                clearInterval(timerInterval);
                currentRepairJobId = null;
                repairCancelRequested = false;

                if (currentRepairController) {
                    currentRepairController.abort();
                    currentRepairController = null;
                }

                repairBtn.textContent = '🔧 Repair Schema Violations';
                repairBtn.style.background = '';
                repairBtn.onclick = repairSchemas;
                repairBtn.disabled = false;
            }
        }

        async function testS3Connection() {
            const resultDiv = document.getElementById('s3TestResult');
            const button = document.querySelector('button[onclick="testS3Connection()"]');
            
            // Show loading state
            button.disabled = true;
            button.textContent = '🔄 Testing...';
            resultDiv.innerHTML = '<div class="loading">Testing S3 connection...</div>';

            try {
                const response = await fetch('/plugins/signalk-parquet/api/test-s3', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const result = await response.json();

                if (result.success) {
                    resultDiv.innerHTML = `
                        <div class="success">
                            ✅ ${result.message}<br>
                            <strong>Bucket:</strong> ${result.bucket}<br>
                            <strong>Region:</strong> ${result.region}<br>
                            <strong>Key Prefix:</strong> ${result.keyPrefix}
                        </div>
                    `;
                } else {
                    resultDiv.innerHTML = `<div class="error">❌ ${result.error}</div>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<div class="error">❌ Network error: ${error.message}</div>`;
            } finally {
                // Reset button
                button.disabled = false;
                button.textContent = '🔗 Test S3 Connection';
            }
        }

        // Path Configuration Management Functions
        async function loadPathConfigurations() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/config/paths');
                const result = await response.json();
                
                if (result.success) {
                    displayPathConfigurations(result.paths);
                } else {
                    document.getElementById('pathConfigContainer').innerHTML = 
                        `<div class="error">Error loading path configurations: ${result.error}</div>`;
                }
            } catch (error) {
                document.getElementById('pathConfigContainer').innerHTML = 
                    `<div class="error">Network error: ${error.message}</div>`;
            }
        }

        function displayPathConfigurations(paths) {
            const container = document.getElementById('pathConfigContainer');
            
            if (!paths || paths.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 5px; margin: 20px 0;">
                        <h3 style="color: #666; margin-bottom: 10px;">No Path Configurations Found</h3>
                        <p style="color: #666; margin-bottom: 20px;">You need to configure SignalK paths to start collecting data.</p>
                        <button onclick="showAddPathForm()">➕ Add Your First Path</button>
                    </div>
                `;
                return;
            }

            // Filter paths based on showCommandPaths setting
            const filteredPaths = showCommandPaths ? paths : paths.filter(path => !path.path || !path.path.startsWith('commands.'));
            
            if (filteredPaths.length === 0) {
                const commandCount = paths.filter(path => path.path && path.path.startsWith('commands.')).length;
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 5px; margin: 20px 0;">
                        <h3 style="color: #666; margin-bottom: 10px;">No Data Paths Found</h3>
                        <p style="color: #666; margin-bottom: 20px;">
                            ${commandCount > 0 ? `${commandCount} command path${commandCount > 1 ? 's' : ''} hidden. ` : ''}
                            Add data paths to start collecting SignalK data.
                        </p>
                        <button onclick="showAddPathForm()">➕ Add Your First Data Path</button>
                    </div>
                `;
                return;
            }

            let html = '<div class="table-container"><table><thead><tr>';
            html += '<th>Path</th><th>Always Enabled</th><th>Regimen</th><th>Source</th><th>Context</th><th>Exclude MMSI</th><th>Actions</th>'
            html += '</tr></thead><tbody>';

            filteredPaths.forEach((path, filteredIndex) => {
                // Find the original index in the full paths array
                const originalIndex = paths.findIndex(p => p === path);
                const excludeMMSI = path.excludeMMSI && path.excludeMMSI.length > 0 ? path.excludeMMSI.join(', ') : '';
                const isCommand = path.path && path.path.startsWith('commands.');
                const rowClass = isCommand ? 'style="background-color: #fff3cd;"' : '';
                
                html += `<tr data-index="${originalIndex}" ${rowClass}>
                    <td><code>${path.path || ''}</code>${isCommand ? ' <span style="color: #856404; font-size: 11px;">(Command)</span>' : ''}</td>
                    <td>${path.enabled ? '✅' : '❌'}</td>
                    <td>${path.regimen || ''}</td>
                    <td><code>${path.source || ''}</code></td>
                    <td>${path.context || 'vessels.self'}</td>
                    <td>${excludeMMSI}</td>
                    <td>
                        <button onclick="editPathConfiguration(${originalIndex})" style="padding: 5px 10px; font-size: 12px;">✏️ Edit</button>
                        <button onclick="removePathConfiguration(${originalIndex})" style="padding: 5px 10px; font-size: 12px; background: #dc3545;">🗑️ Remove</button>
                    </td>
                </tr>`;
            });

            html += '</tbody></table></div>';
            
            // Add summary info
            const totalPaths = paths.length;
            const commandPaths = paths.filter(path => path.path && path.path.startsWith('commands.')).length;
            const dataPaths = totalPaths - commandPaths;
            
            const summaryHtml = `
                <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-size: 14px; color: #666;">
                    Showing ${filteredPaths.length} of ${totalPaths} paths 
                    (${dataPaths} data path${dataPaths !== 1 ? 's' : ''}, ${commandPaths} command path${commandPaths !== 1 ? 's' : ''})
                </div>
            `;
            
            container.innerHTML = html + summaryHtml;
        }

        function toggleCommandPaths() {
            showCommandPaths = !showCommandPaths;
            const button = document.getElementById('toggleCommandsBtn');
            button.textContent = showCommandPaths ? '🙈 Hide Commands' : '👁️ Show Commands';
            
            // Re-display the paths with the new filter
            loadPathConfigurations();
        }

        async function showAddPathForm() {
            document.getElementById('addPathForm').style.display = 'block';
            populateSignalKPaths();
            await populateAvailableRegimens();
        }

        function hideAddPathForm() {
            document.getElementById('addPathForm').style.display = 'none';
            clearAddPathForm();
        }

        function clearAddPathForm() {
            document.getElementById('pathSignalK').value = '';
            document.getElementById('pathSignalKCustom').value = '';
            document.getElementById('pathSignalKCustom').style.display = 'none';
            document.getElementById('pathEnabled').checked = false;
            document.getElementById('pathSource').value = '';
            document.getElementById('pathContext').value = 'vessels.self';
            document.getElementById('pathExcludeMMSI').value = '';
            document.getElementById('customRegimen').value = '';

            // Clear regimen checkboxes
            const checkboxes = document.querySelectorAll('#regimenCheckboxes input[type="checkbox"]');
            checkboxes.forEach(checkbox => checkbox.checked = false);
        }

        // Populate SignalK paths dropdown
        async function populateSignalKPaths() {
            const dropdown = document.getElementById('pathSignalK');
            const filterType = document.querySelector('input[name="pathFilter"]:checked')?.value || 'self';

            try {
                const response = await fetch('/signalk/v1/api/');
                const data = await response.json();

                // Extract paths from SignalK API with filter
                const allPaths = extractPathsFromSignalK(data, filterType);

                // Get defined commands to exclude
                const commandsResponse = await fetch('/plugins/signalk-parquet/api/commands');
                const commandsData = await commandsResponse.json();

                const definedCommands = new Set();
                if (commandsData.success && commandsData.commands) {
                    commandsData.commands.forEach(cmd => {
                        definedCommands.add(`commands.${cmd.command}`);
                    });
                }

                // Filter out defined command paths
                const availablePaths = allPaths.filter(path => !definedCommands.has(path));

                // Clear existing options (except default ones)
                while (dropdown.children.length > 2) {
                    dropdown.removeChild(dropdown.lastChild);
                }

                // Add available paths
                availablePaths.forEach(path => {
                    const option = document.createElement('option');
                    option.value = path;
                    option.textContent = path;
                    dropdown.appendChild(option);
                });

            } catch (error) {
                console.log('Could not load real-time SignalK paths:', error);
            }
        }

        // Update path filter
        function updatePathFilter() {
            populateSignalKPaths();
        }

        // Extract distinct paths from SignalK data, separating self vs non-self
        function extractPathsFromSignalK(obj, filterType = 'self') {
            const selfPaths = new Set();
            const nonSelfPaths = new Set();

            function extractRecursive(obj, prefix = '') {
                if (!obj || typeof obj !== 'object') return;

                for (const key in obj) {
                    if (key === 'meta' || key === 'timestamp' || key === 'source') continue;

                    const currentPath = prefix ? `${prefix}.${key}` : key;

                    if (obj[key] && typeof obj[key] === 'object') {
                        if (obj[key].value !== undefined) {
                            // This is a data path with a value
                            selfPaths.add(currentPath);
                        } else {
                            extractRecursive(obj[key], currentPath);
                        }
                    }
                }
            }

            // Get the self vessel ID to distinguish self from other vessels
            const selfVesselId = obj.self;
            // Remove 'vessels.' prefix if present to get the actual vessel ID
            const actualSelfId = selfVesselId && selfVesselId.startsWith('vessels.') ?
                selfVesselId.replace('vessels.', '') : selfVesselId;

            // Process vessels if they exist
            if (obj.vessels) {
                // Process self vessel
                if (actualSelfId && obj.vessels[actualSelfId]) {
                    extractRecursive(obj.vessels[actualSelfId], '');
                }

                // Process other vessels and extract generic paths
                for (const vesselId in obj.vessels) {
                    if (vesselId !== actualSelfId) {
                        const tempPaths = new Set();
                        function extractOtherVessel(obj, prefix = '') {
                            if (!obj || typeof obj !== 'object') return;
                            for (const key in obj) {
                                if (key === 'meta' || key === 'timestamp' || key === 'source') continue;
                                const currentPath = prefix ? `${prefix}.${key}` : key;
                                if (obj[key] && typeof obj[key] === 'object') {
                                    if (obj[key].value !== undefined) {
                                        tempPaths.add(currentPath);
                                    } else {
                                        extractOtherVessel(obj[key], currentPath);
                                    }
                                }
                            }
                        }
                        extractOtherVessel(obj.vessels[vesselId], '');
                        tempPaths.forEach(path => nonSelfPaths.add(path));
                    }
                }
            }

            // Process top-level paths (non-vessel specific data like environment)
            for (const key in obj) {
                if (key !== 'vessels' && key !== 'self' && key !== 'version' && key !== 'sources' && key !== 'meta' && key !== 'timestamp') {
                    extractRecursive(obj[key], key);
                }
            }


            // Return the appropriate set based on filter
            const targetPaths = filterType === 'self' ? selfPaths : nonSelfPaths;
            return Array.from(targetPaths).sort();
        }

        // Populate available regimens
        async function populateAvailableRegimens() {
            const container = document.getElementById('regimenCheckboxes');

            try {
                // Get defined commands to use as regimens
                const commandsResponse = await fetch('/plugins/signalk-parquet/api/commands');
                const commandsData = await commandsResponse.json();

                const availableRegimens = [];
                if (commandsData.success && commandsData.commands) {
                    commandsData.commands.forEach(cmd => {
                        availableRegimens.push(cmd.command);
                    });
                }

                container.innerHTML = '';

                availableRegimens.forEach(regimen => {
                    const label = document.createElement('label');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.marginBottom = '5px';
                    label.style.cursor = 'pointer';
                    label.style.fontSize = '0.9em';

                    const span = document.createElement('span');
                    span.textContent = regimen;
                    span.style.flex = '1';
                    span.style.marginRight = '8px';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `regimen_${regimen}`;
                    checkbox.value = regimen;
                    checkbox.style.width = '16px';
                    checkbox.style.height = '16px';

                    label.appendChild(span);
                    label.appendChild(checkbox);
                    container.appendChild(label);
                });
            } catch (error) {
                console.log('Could not load regimens:', error);
            }
        }

        // Handle SignalK path dropdown change
        document.addEventListener('DOMContentLoaded', function() {
            document.addEventListener('change', function(e) {
                if (e.target.id === 'pathSignalK') {
                    const customInput = document.getElementById('pathSignalKCustom');
                    if (e.target.value === 'custom') {
                        customInput.style.display = 'block';
                        customInput.focus();
                    } else {
                        customInput.style.display = 'none';
                    }
                }
            });
        });

        // Add custom regimen
        function addCustomRegimen() {
            const customInput = document.getElementById('customRegimen');
            const regimenName = customInput.value.trim();

            if (!regimenName) {
                alert('Please enter a regimen name');
                return;
            }

            // Check if already exists
            if (document.getElementById(`regimen_${regimenName}`)) {
                alert('This regimen already exists');
                return;
            }

            const container = document.getElementById('regimenCheckboxes');
            const div = document.createElement('div');
            div.style.marginBottom = '5px';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `regimen_${regimenName}`;
            checkbox.value = regimenName;
            checkbox.checked = true; // Auto-select custom regimens
            checkbox.style.marginRight = '8px';

            const label = document.createElement('label');
            label.htmlFor = `regimen_${regimenName}`;
            label.textContent = `${regimenName} (custom)`;
            label.style.fontSize = '0.9em';
            label.style.fontStyle = 'italic';

            div.appendChild(checkbox);
            div.appendChild(label);
            container.appendChild(div);

            customInput.value = '';
        }

        async function addPathConfiguration() {
            const excludeMMSIInput = document.getElementById('pathExcludeMMSI').value.trim();
            const excludeMMSI = excludeMMSIInput ? excludeMMSIInput.split(',').map(mmsi => mmsi.trim()).filter(mmsi => mmsi) : [];

            // Get path value (either from dropdown or custom input)
            const pathDropdown = document.getElementById('pathSignalK');
            const pathCustom = document.getElementById('pathSignalKCustom');
            const selectedPath = pathDropdown.value === 'custom' ? pathCustom.value.trim() : pathDropdown.value.trim();

            // Get selected regimens
            const selectedRegimens = [];
            const checkboxes = document.querySelectorAll('#regimenCheckboxes input[type="checkbox"]:checked');
            checkboxes.forEach(checkbox => {
                selectedRegimens.push(checkbox.value);
            });

            const pathConfig = {
                path: selectedPath,
                enabled: document.getElementById('pathEnabled').checked,
                regimen: selectedRegimens.join(','), // Join multiple regimens with comma
                source: document.getElementById('pathSource').value.trim() || undefined,
                context: document.getElementById('pathContext').value.trim() || 'vessels.self',
                excludeMMSI: excludeMMSI.length > 0 ? excludeMMSI : undefined
            };

            if (!pathConfig.path) {
                alert('SignalK path is required');
                return;
            }

            try {
                const response = await fetch('/plugins/signalk-parquet/api/config/paths', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(pathConfig)
                });

                const result = await response.json();

                if (result.success) {
                    hideAddPathForm();
                    await loadPathConfigurations();
                    alert('Path configuration added successfully');
                } else {
                    alert(`Error adding path configuration: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }

        async function removePathConfiguration(index) {
            if (!confirm('Are you sure you want to remove this path configuration?')) {
                return;
            }

            try {
                const response = await fetch(`/plugins/signalk-parquet/api/config/paths/${index}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (result.success) {
                    await loadPathConfigurations();
                    alert('Path configuration removed successfully');
                } else {
                    alert(`Error removing path configuration: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }

        let editingIndex = -1;

        async function editPathConfiguration(index) {
            // Cancel any existing edit
            if (editingIndex !== -1) {
                cancelEdit();
            }
            
            editingIndex = index;
            
            // Get the current path configuration
            const response = await fetch('/plugins/signalk-parquet/api/config/paths');
            const result = await response.json();
            
            if (!result.success || !result.paths[index]) {
                alert('Error loading path configuration');
                return;
            }
            
            const path = result.paths[index];
            
            // Replace the row with edit form
            const row = document.querySelector(`tr[data-index="${index}"]`);
            if (row) {
                const excludeMMSIValue = path.excludeMMSI && path.excludeMMSI.length > 0 ? path.excludeMMSI.join(', ') : '';
                const currentRegimens = path.regimen ? path.regimen.split(',').map(r => r.trim()) : [];

                row.innerHTML = `
                    <td>
                        <div style="margin-bottom: 4px; font-size: 0.8em; display: flex; align-items: center; gap: 10px;">
                            <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer; white-space: nowrap;">
                                <span style="margin-right: 3px;">🏠 Self</span>
                                <input type="radio" id="editPathFilterSelf${index}" name="editPathFilter${index}" value="self" checked onchange="updateEditPathFilter(${index})">
                            </label>
                            <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer; white-space: nowrap;">
                                <span style="margin-right: 3px;">🚢 Others</span>
                                <input type="radio" id="editPathFilterOthers${index}" name="editPathFilter${index}" value="others" onchange="updateEditPathFilter(${index})">
                            </label>
                        </div>
                        <select id="editPath${index}" style="width: 100%; padding: 4px;">
                            <option value="">-- Select SignalK Path --</option>
                            <option value="custom">🖊️ Enter Custom Path</option>
                        </select>
                        <input type="text" id="editPathCustom${index}" placeholder="Enter custom SignalK path" style="width: 100%; padding: 4px; margin-top: 2px; display: none;">
                    </td>
                    <td><input type="checkbox" id="editEnabled${index}" ${path.enabled ? 'checked' : ''}></td>
                    <td>
                        <div style="max-height: 120px; overflow-y: auto; border: 1px solid #ddd; padding: 5px; background: white;">
                            <div id="editRegimenCheckboxes${index}">
                                <!-- Regimen checkboxes will be populated here -->
                            </div>
                        </div>
                    </td>
                    <td><input type="text" id="editSource${index}" value="${path.source || ''}" style="width: 100%;" placeholder="e.g., mqtt-weatherflow-udp"></td>
                    <td><input type="text" id="editContext${index}" value="${path.context || 'vessels.self'}" style="width: 100%;"></td>
                    <td><input type="text" id="editExcludeMMSI${index}" value="${excludeMMSIValue}" style="width: 100%;" placeholder="123456789, 987654321"></td>
                    <td>
                        <button onclick="saveEdit(${index})" style="padding: 5px 10px; font-size: 12px; background: #28a745;">💾 Save</button>
                        <button onclick="cancelEdit()" style="padding: 5px 10px; font-size: 12px; background: #6c757d;">❌ Cancel</button>
                    </td>
                `;

                // Populate the edit form with enhanced dropdowns
                populateEditSignalKPaths(index, path.path);
                await populateEditRegimens(index, currentRegimens);
            }
        }

        // Populate SignalK paths dropdown for edit form
        async function populateEditSignalKPaths(index, currentPath) {
            const dropdown = document.getElementById(`editPath${index}`);
            const customInput = document.getElementById(`editPathCustom${index}`);
            const filterType = document.querySelector(`input[name="editPathFilter${index}"]:checked`)?.value || 'self';

            try {
                const response = await fetch('/signalk/v1/api/');
                const data = await response.json();

                const allPaths = extractPathsFromSignalK(data, filterType);

                // Get defined commands to exclude
                const commandsResponse = await fetch('/plugins/signalk-parquet/api/commands');
                const commandsData = await commandsResponse.json();

                const definedCommands = new Set();
                if (commandsData.success && commandsData.commands) {
                    commandsData.commands.forEach(cmd => {
                        definedCommands.add(`commands.${cmd.command}`);
                    });
                }

                // Filter out defined command paths
                const availablePaths = allPaths.filter(path => !definedCommands.has(path));

                // Clear existing options (except default ones)
                while (dropdown.children.length > 2) {
                    dropdown.removeChild(dropdown.lastChild);
                }

                // Add available paths
                availablePaths.forEach(path => {
                    const option = document.createElement('option');
                    option.value = path;
                    option.textContent = path;
                    dropdown.appendChild(option);
                });

                // Set current value and determine appropriate filter
                if (currentPath) {
                    // Determine if current path is self or other vessel path
                    const isSelfPath = !currentPath.includes('vessels.') || currentPath.startsWith('vessels.self.');
                    const targetFilter = isSelfPath ? 'self' : 'others';

                    // Set appropriate radio button
                    const selfRadio = document.getElementById(`editPathFilterSelf${index}`);
                    const othersRadio = document.getElementById(`editPathFilterOthers${index}`);
                    if (targetFilter === 'self') {
                        selfRadio.checked = true;
                    } else {
                        othersRadio.checked = true;
                    }

                    // Clean path for comparison (remove vessels.self. prefix if present)
                    const cleanCurrentPath = currentPath.replace('vessels.self.', '');

                    // Refresh paths with correct filter if needed
                    if (targetFilter !== filterType) {
                        updateEditPathFilter(index);
                        return;
                    }

                    if (paths.includes(cleanCurrentPath)) {
                        dropdown.value = cleanCurrentPath;
                    } else if (paths.includes(currentPath)) {
                        dropdown.value = currentPath;
                    } else {
                        dropdown.value = 'custom';
                        customInput.style.display = 'block';
                        customInput.value = currentPath;
                    }
                }

                // Add change listener
                dropdown.addEventListener('change', function() {
                    if (this.value === 'custom') {
                        customInput.style.display = 'block';
                        customInput.focus();
                    } else {
                        customInput.style.display = 'none';
                    }
                });

            } catch (error) {
                console.log('Could not load real-time SignalK paths for edit:', error);
                // Fallback to custom input
                dropdown.value = 'custom';
                customInput.style.display = 'block';
                customInput.value = currentPath || '';
            }
        }

        // Update path filter for edit form
        function updateEditPathFilter(index) {
            const dropdown = document.getElementById(`editPath${index}`);
            const currentValue = dropdown.value;

            // Get current path from either dropdown or custom input
            const customInput = document.getElementById(`editPathCustom${index}`);
            const currentPath = currentValue === 'custom' ? customInput.value : currentValue;

            populateEditSignalKPaths(index, currentPath);
        }

        // Populate regimens for edit form
        async function populateEditRegimens(index, currentRegimens) {
            const container = document.getElementById(`editRegimenCheckboxes${index}`);

            try {
                // Get defined commands to use as regimens
                const commandsResponse = await fetch('/plugins/signalk-parquet/api/commands');
                const commandsData = await commandsResponse.json();

                const availableRegimens = [];
                if (commandsData.success && commandsData.commands) {
                    commandsData.commands.forEach(cmd => {
                        availableRegimens.push(cmd.command);
                    });
                }

            container.innerHTML = '';

                // Add available regimens
                availableRegimens.forEach(regimen => {
                    const label = document.createElement('label');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.marginBottom = '3px';
                    label.style.cursor = 'pointer';
                    label.style.fontSize = '0.8em';

                    const span = document.createElement('span');
                    span.textContent = regimen;
                    span.style.flex = '1';
                    span.style.marginRight = '6px';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `editRegimen_${index}_${regimen}`;
                    checkbox.value = regimen;
                    checkbox.checked = currentRegimens.includes(regimen);
                    checkbox.style.width = '14px';
                    checkbox.style.height = '14px';

                    label.appendChild(span);
                    label.appendChild(checkbox);
                    container.appendChild(label);
                });

                // Add custom regimens that aren't in the available list
                currentRegimens.forEach(regimen => {
                    if (!availableRegimens.includes(regimen)) {
                        const label = document.createElement('label');
                        label.style.display = 'flex';
                        label.style.alignItems = 'center';
                        label.style.marginBottom = '3px';
                        label.style.cursor = 'pointer';
                        label.style.fontSize = '0.8em';
                        label.style.fontStyle = 'italic';

                        const span = document.createElement('span');
                        span.textContent = `${regimen} (custom)`;
                        span.style.flex = '1';
                        span.style.marginRight = '6px';

                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `editRegimen_${index}_${regimen}`;
                        checkbox.value = regimen;
                        checkbox.checked = true;
                        checkbox.style.width = '14px';
                        checkbox.style.height = '14px';

                        label.appendChild(span);
                        label.appendChild(checkbox);
                        container.appendChild(label);
                    }
                });
            } catch (error) {
                console.log('Could not load regimens for edit:', error);
            }
        }

        async function saveEdit(index) {
            const excludeMMSIInput = document.getElementById(`editExcludeMMSI${index}`).value.trim();
            const excludeMMSI = excludeMMSIInput ? excludeMMSIInput.split(',').map(mmsi => mmsi.trim()).filter(mmsi => mmsi) : [];

            // Get path value (either from dropdown or custom input)
            const pathDropdown = document.getElementById(`editPath${index}`);
            const pathCustom = document.getElementById(`editPathCustom${index}`);
            const selectedPath = pathDropdown.value === 'custom' ? pathCustom.value.trim() : pathDropdown.value.trim();

            // Get selected regimens
            const selectedRegimens = [];
            const checkboxes = document.querySelectorAll(`#editRegimenCheckboxes${index} input[type="checkbox"]:checked`);
            checkboxes.forEach(checkbox => {
                selectedRegimens.push(checkbox.value);
            });

            const updatedPath = {
                path: selectedPath,
                enabled: document.getElementById(`editEnabled${index}`).checked,
                regimen: selectedRegimens.join(','), // Join multiple regimens with comma
                source: document.getElementById(`editSource${index}`).value.trim() || undefined,
                context: document.getElementById(`editContext${index}`).value.trim() || 'vessels.self',
                excludeMMSI: excludeMMSI.length > 0 ? excludeMMSI : undefined
            };

            if (!updatedPath.path) {
                alert('SignalK path is required');
                return;
            }

            try {
                const response = await fetch(`/plugins/signalk-parquet/api/config/paths/${index}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(updatedPath)
                });

                const result = await response.json();

                if (result.success) {
                    editingIndex = -1;
                    await loadPathConfigurations();
                    alert('Path configuration updated successfully');
                } else {
                    alert(`Error updating path configuration: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }

        function cancelEdit() {
            editingIndex = -1;
            loadPathConfigurations();
        }

        // Command Management Functions
        async function loadCommands() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/commands');
                const result = await response.json();
                
                if (result.success) {
                    displayCommands(result.commands || []);
                } else {
                    document.getElementById('commandContainer').innerHTML = `<div class="error">Error loading commands: ${result.error}</div>`;
                }
            } catch (error) {
                document.getElementById('commandContainer').innerHTML = `<div class="error">Error loading commands: ${error.message}</div>`;
            }
        }
        
        function displayCommands(commands) {
            const container = document.getElementById('commandContainer');
            
            if (!commands || commands.length === 0) {
                container.innerHTML = '<div class="info">No commands registered yet.</div>';
                return;
            }
            
            let html = '<div class="table-container"><table><thead><tr>';
            html += '<th>Command</th><th>Path</th><th>Description</th><th>Keywords</th><th>Status</th><th>Registered</th><th>Actions</th>';
            html += '</tr></thead><tbody>';
            
            commands.forEach(command => {
                const status = command.active ? '🟢 Active' : '🔴 Inactive';
                const registeredDate = new Date(command.registered).toLocaleString();
                const keywords = command.keywords ? command.keywords.join(', ') : '<em style="color: #999;">No keywords</em>';
                html += `<tr>
                    <td><strong>${command.command}</strong></td>
                    <td><code>vessels.self.commands.${command.command}</code></td>
                    <td>${command.description || 'No description'}</td>
                    <td>${keywords}</td>
                    <td>${status}</td>
                    <td>${registeredDate}</td>
                    <td>
                        <button onclick="executeCommand('${command.command}', true)" style="margin-right: 5px;">▶️ Start</button>
                        <button onclick="executeCommand('${command.command}', false)" style="margin-right: 5px;">⏹️ Stop</button>
                        <button onclick="showEditCommandForm('${command.command}')" class="btn-secondary" style="margin-right: 5px;">✏️ Edit</button>
                        <button onclick="unregisterCommand('${command.command}')" class="btn-danger">❌ Remove</button>
                    </td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            container.innerHTML = html;
        }
        
        function showAddCommandForm() {
            document.getElementById('addCommandForm').style.display = 'block';
        }
        
        function hideAddCommandForm() {
            document.getElementById('addCommandForm').style.display = 'none';
            clearAddCommandForm();
        }
        
        function clearAddCommandForm() {
            document.getElementById('commandName').value = '';
            document.getElementById('commandDescription').value = '';
            document.getElementById('commandKeywords').value = '';
        }
        
        // Edit command functions
        async function showEditCommandForm(commandName) {
            try {
                // Find the command in the current commands list
                const response = await fetch('/plugins/signalk-parquet/api/commands').then(r => r.json());
                const command = response.commands.find(cmd => cmd.command === commandName);
                
                if (!command) {
                    alert('Command not found');
                    return;
                }
                
                // Populate the form
                document.getElementById('editCommandName').value = command.command;
                document.getElementById('editCommandDescription').value = command.description || '';
                document.getElementById('editCommandKeywords').value = command.keywords ? command.keywords.join(', ') : '';
                
                // Show the form
                document.getElementById('editCommandForm').style.display = 'block';
                
            } catch (error) {
                alert('Failed to load command details: ' + error.message);
            }
        }
        
        function hideEditCommandForm() {
            document.getElementById('editCommandForm').style.display = 'none';
        }
        
        async function updateCommand() {
            try {
                const command = document.getElementById('editCommandName').value.trim();
                const description = document.getElementById('editCommandDescription').value.trim();
                const keywordsInput = document.getElementById('editCommandKeywords').value.trim();
                
                // Parse keywords from comma-separated string
                const keywords = keywordsInput ? keywordsInput.split(',').map(k => k.trim()).filter(k => k.length > 0) : undefined;
                
                const response = await fetch(`/plugins/signalk-parquet/api/commands/${command}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        description: description || undefined,
                        keywords: keywords
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    hideEditCommandForm();
                    await loadCommands();
                    alert('Command updated successfully!');
                } else {
                    alert('Failed to update command: ' + result.error);
                }
                
            } catch (error) {
                alert('Error updating command: ' + error.message);
            }
        }
        
        async function registerCommand() {
            try {
                const command = document.getElementById('commandName').value.trim();
                const description = document.getElementById('commandDescription').value.trim();
                const keywordsInput = document.getElementById('commandKeywords').value.trim();
                
                if (!command) {
                    alert('Command name is required');
                    return;
                }
                
                // Parse keywords from comma-separated string
                const keywords = keywordsInput ? keywordsInput.split(',').map(k => k.trim()).filter(k => k.length > 0) : undefined;
                
                const response = await fetch('/plugins/signalk-parquet/api/commands', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        command: command,
                        description: description || undefined,
                        keywords: keywords
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    hideAddCommandForm();
                    await loadCommands();
                    await loadPathConfigurations(); // Refresh paths to show the auto-created path
                    alert(`Command '${command}' registered successfully!\n\nA path configuration has been automatically created and enabled for this command.`);
                } else {
                    alert(`Error registering command: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }
        
        async function executeCommand(commandName, value) {
            try {
                const response = await fetch(`/plugins/signalk-parquet/api/commands/${commandName}/execute`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        value: value
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    await loadCommands();
                    await loadCommandHistory();
                    alert(`Command '${commandName}' ${value ? 'started' : 'stopped'} successfully`);
                } else {
                    alert(`Error executing command: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }
        
        async function unregisterCommand(commandName) {
            if (!confirm(`Are you sure you want to unregister command '${commandName}'?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/plugins/signalk-parquet/api/commands/${commandName}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    await loadCommands();
                    await loadCommandHistory();
                    await loadPathConfigurations(); // Refresh paths to show the removed path
                    alert(`Command '${commandName}' unregistered successfully!\n\nThe associated path configuration has been automatically removed.`);
                } else {
                    alert(`Error unregistering command: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }
        
        async function loadCommandHistory() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/commands/history');
                const result = await response.json();
                
                if (result.success) {
                    displayCommandHistory(result.data || []);
                } else {
                    document.getElementById('commandHistoryContainer').innerHTML = `<div class="error">Error loading command history: ${result.error}</div>`;
                }
            } catch (error) {
                document.getElementById('commandHistoryContainer').innerHTML = `<div class="error">Error loading command history: ${error.message}</div>`;
            }
        }
        
        function displayCommandHistory(history) {
            const container = document.getElementById('commandHistoryContainer');
            
            if (!history || history.length === 0) {
                container.innerHTML = '<div class="info">No command history available.</div>';
                return;
            }
            
            let html = '<div class="table-container"><table><thead><tr>';
            html += '<th>Command</th><th>Action</th><th>Value</th><th>Status</th><th>Time</th><th>Error</th>';
            html += '</tr></thead><tbody>';
            
            history.forEach(entry => {
                const status = entry.success ? '✅ Success' : '❌ Failed';
                const timestamp = new Date(entry.timestamp).toLocaleString();
                const value = entry.value !== undefined ? (entry.value ? 'true' : 'false') : '-';
                html += `<tr>
                    <td><strong>${entry.command}</strong></td>
                    <td>${entry.action}</td>
                    <td>${value}</td>
                    <td>${status}</td>
                    <td>${timestamp}</td>
                    <td>${entry.error || '-'}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // Live Connections / Stream Management Functions
        let activeStreams = [];

        async function loadStreams() {
            // DISABLED - Streaming functionality has been disabled
            // try {
            //     const response = await fetch('/plugins/signalk-parquet/api/streams');
            //     const result = await response.json();
                
            //     if (result.success) {
            //         activeStreams = result.streams || [];
            //         displayStreams(activeStreams);
            //         loadStreamStats();
            //     } else {
            //         document.getElementById('streamsContainer').innerHTML = `<div class="error">Error loading streams: ${result.error}</div>`;
            //     }
            // } catch (error) {
            //     document.getElementById('streamsContainer').innerHTML = `<div class="error">Network error: ${error.message}</div>`;
            // }
            return;
        }

        function displayStreams(streams) {
            const container = document.getElementById('streamsContainer');
            
            if (!streams || streams.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 5px; margin: 20px 0;">
                        <h3 style="color: #666; margin-bottom: 10px;">No Active Streams</h3>
                        <p style="color: #666; margin-bottom: 20px;">Create your first historical data stream to get started.</p>
                        <button onclick="showAddStreamForm()">➕ Create Your First Stream</button>
                    </div>
                `;
                return;
            }

            let html = '<div class="table-container"><table><thead><tr>';
            html += '<th>Name</th><th>Path</th><th>Status</th><th>Time Range</th><th>Resolution</th><th>Rate</th><th>Statistics</th><th>Progress</th><th>Stream URL</th><th>Actions</th>';
            html += '</tr></thead><tbody>';

            streams.forEach((stream, index) => {
                const isRunning = stream.status === 'running';
                const isPaused = stream.status === 'paused';
                const isStopped = stream.status === 'stopped' || stream.status === 'created';
                
                const status = isRunning ? '🟢 Running' : isPaused ? '⏸️ Paused' : '🔴 Stopped';
                const progress = stream.dataPointsStreamed ? `${stream.dataPointsStreamed} points` : '-';
                const timeRange = `${stream.timeRange || '1h'} (${stream.startTime || 'N/A'} - ${stream.endTime || 'N/A'})`;
                const statistics = stream.aggregateMethod || 'average';
                const streamMode = stream.isIncremental ? '📈' : '📊';
                const lastTimestamp = stream.lastTimestamp ? new Date(stream.lastTimestamp).toLocaleTimeString() : 'Never';
                
                // Generate stream URLs
                const streamName = stream.name.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
                const aggregateMethod = stream.aggregateMethod || 'average';
                const streamPath = `streaming.${streamName}.${aggregateMethod}`;
                const wsUrl = `ws://${window.location.host}/signalk/v1/stream`;
                const restUrl = `http://${window.location.host}/signalk/v1/api/vessels/self/${streamPath}`;
                
                html += `<tr>
                    <td><strong>${stream.name}</strong></td>
                    <td><code>${stream.path}</code></td>
                    <td>${status}</td>
                    <td>${timeRange}</td>
                    <td>${stream.resolution || 30000}ms</td>
                    <td>${stream.rate || 5000}ms</td>
                    <td><small>${statistics} ${streamMode}<br/>Last: ${lastTimestamp}</small></td>
                    <td>${progress}</td>
                    <td>
                        ${isRunning ? 
                            `<div style="font-size: 11px;">
                                <strong>Path:</strong> <code style="font-size: 10px;">${streamPath}</code><br/>
                                <strong>REST:</strong> <a href="${restUrl}" target="_blank" style="font-size: 10px; color: #007bff;">API Link</a><br/>
                                <strong>WS:</strong> <code style="font-size: 10px;">${wsUrl}</code>
                            </div>` : 
                            '<small style="color: #666;">Stream not running</small>'
                        }
                    </td>
                    <td>
                        ${isStopped ? 
                            `<button onclick="startStream('${stream.id}')" style="padding: 5px 10px; font-size: 12px; background: #28a745;">▶️ Start</button>` : 
                            `<button onclick="pauseStream('${stream.id}')" style="padding: 5px 10px; font-size: 12px; background: #ffc107;">${isPaused ? '▶️ Resume' : '⏸️ Pause'}</button>
                             <button onclick="stopStream('${stream.id}')" style="padding: 5px 10px; font-size: 12px; background: #dc3545;">⏹️ Stop</button>`
                        }
                        <button onclick="editStream('${stream.id}')" style="padding: 5px 10px; font-size: 12px;">✏️ Edit</button>
                        <button onclick="deleteStream('${stream.id}')" style="padding: 5px 10px; font-size: 12px; background: #dc3545;">🗑️ Delete</button>
                    </td>
                </tr>`;
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
            
            // Update live connection icon based on active streams
            updateLiveConnectionIcon(streams);
        }

        function updateLiveConnectionIcon(streams) {
            const hasActiveStreams = streams && streams.some(stream => stream.status === 'running');
            const icon = hasActiveStreams ? '🟢' : '🔴';
            
            // Update tab button
            const tabButton = document.querySelector('.tab-button[onclick="showTab(\'liveConnections\')"]');
            if (tabButton) {
                tabButton.innerHTML = `${icon} Live Connections`;
            }
            
            // Update section header
            const sectionHeader = document.querySelector('#liveConnections h2');
            if (sectionHeader) {
                sectionHeader.innerHTML = `${icon} Live Connections`;
            }
        }

        async function loadStreamStats() {
            // DISABLED - Streaming functionality has been disabled
            // try {
            //     const response = await fetch('/plugins/signalk-parquet/api/streams/stats');
            //     const result = await response.json();
                
            //     if (result.success) {
            //         displayStreamStats(result.stats);
            //     } else {
            //         document.getElementById('streamStats').innerHTML = `<div class="error">Error loading stats: ${result.error}</div>`;
            //     }
            // } catch (error) {
            //     document.getElementById('streamStats').innerHTML = `<div class="error">Network error: ${error.message}</div>`;
            // }
            return;
        }

        function displayStreamStats(stats) {
            const container = document.getElementById('streamStats');
            
            const html = `
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value">${stats.totalStreams || 0}</div>
                        <div class="stat-label">Total Streams</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.runningStreams || 0}</div>
                        <div class="stat-label">Active</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.totalDataPointsStreamed || 0}</div>
                        <div class="stat-label">Data Points Streamed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.connectedClients || 0}</div>
                        <div class="stat-label">Connected Clients</div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        function showAddStreamForm() {
            document.getElementById('addStreamForm').style.display = 'block';
            
            // Show/hide custom time range based on selection
            const timeRangeSelect = document.getElementById('streamTimeRange');
            timeRangeSelect.addEventListener('change', function() {
                const customDiv = document.getElementById('customTimeRange');
                customDiv.style.display = this.value === 'custom' ? 'block' : 'none';
            });
        }

        function hideAddStreamForm() {
            document.getElementById('addStreamForm').style.display = 'none';
            clearAddStreamForm();
        }

        function clearAddStreamForm() {
            document.getElementById('streamName').value = '';
            
            // Reset path field to dropdown if it was converted to manual input
            const pathField = document.getElementById('streamPath');
            if (pathField.tagName === 'INPUT') {
                // Recreate the select element
                const pathContainer = pathField.parentNode;
                const pathSelect = document.createElement('select');
                pathSelect.id = 'streamPath';
                pathSelect.style.cssText = 'flex: 1;';
                pathSelect.innerHTML = '<option value="">Select a SignalK path...</option>';
                
                pathContainer.replaceChild(pathSelect, pathField);
                
                // Reload paths
                loadSignalKPaths();
            } else {
                pathField.value = '';
            }
            
            document.getElementById('streamTimeRange').value = '1h';
            document.getElementById('streamResolution').value = '30000';
            document.getElementById('streamRate').value = '500';
            document.getElementById('streamAutoStart').checked = true;
            document.getElementById('customTimeRange').style.display = 'none';
            document.getElementById('streamStartTime').value = '';
            document.getElementById('streamEndTime').value = '';
        }

        async function loadSignalKPaths() {
            const pathSelect = document.getElementById('streamPath');
            const originalHTML = pathSelect.innerHTML;
            
            try {
                pathSelect.innerHTML = '<option value="">Loading paths...</option>';
                
                // Use the same endpoint as the Available Paths tab
                const response = await fetch('/plugins/signalk-parquet/api/paths');
                const result = await response.json();
                
                if (result.success && Array.isArray(result.paths) && result.paths.length > 0) {
                    // Clear loading message and add paths
                    pathSelect.innerHTML = '<option value="">Select a SignalK path...</option>';
                    
                    // Sort paths alphabetically for better UX
                    const sortedPaths = result.paths.sort((a, b) => a.path.localeCompare(b.path));
                    
                    sortedPaths.forEach(pathInfo => {
                        const option = document.createElement('option');
                        option.value = pathInfo.path;
                        option.textContent = `${pathInfo.path} (${pathInfo.fileCount} files)`;
                        pathSelect.appendChild(option);
                    });
                    
                } else {
                    // No paths found - provide manual entry option
                    pathSelect.innerHTML = '<option value="">No historical paths found</option>';
                    const manualOption = document.createElement('option');
                    manualOption.value = 'manual';
                    manualOption.textContent = '✏️ Enter path manually';
                    pathSelect.appendChild(manualOption);
                }
            } catch (error) {
                console.error('Error loading SignalK paths:', error);
                
                // Provide manual entry option as fallback
                pathSelect.innerHTML = '<option value="">Select or enter a SignalK path...</option>';
                const manualOption = document.createElement('option');
                manualOption.value = 'manual';
                manualOption.textContent = '✏️ Enter path manually';
                pathSelect.appendChild(manualOption);
            }
        }

        async function loadVersionInfo() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/version');
                if (response.ok) {
                    const versionData = await response.json();
                    const headerElement = document.querySelector('.header h1');
                    if (headerElement) {
                        const versionSpan = document.createElement('span');
                        versionSpan.style.fontSize = '0.4em';
                        versionSpan.style.color = '#666';
                        versionSpan.style.fontWeight = 'normal';
                        versionSpan.style.marginLeft = '10px';
                        versionSpan.textContent = `v${versionData.version}`;
                        headerElement.appendChild(versionSpan);
                    }
                }
            } catch (error) {
                console.log('Could not load version information:', error);
            }
        }

        async function refreshSignalKPaths() {
            await loadSignalKPaths();
        }

        // Initialize page when DOM is loaded
        document.addEventListener('DOMContentLoaded', async function() {
            // Load and display version information
            await loadVersionInfo();

            // Load SignalK paths for the dropdown
            await loadSignalKPaths();

            // Check if any process is currently running
            await checkProcessStatus();
            
            // Set up auto-refresh for streams and stats - DISABLED
            // setInterval(() => {
            //     loadStreams();
            // }, 5000); // Refresh every 5 seconds
            
            // Add event listener for path selection to handle manual entry
            const pathSelect = document.getElementById('streamPath');
            let manualInput = null;
            
            pathSelect.addEventListener('change', function() {
                if (this.value === 'manual') {
                    // Replace select with text input for manual entry
                    manualInput = document.createElement('input');
                    manualInput.type = 'text';
                    manualInput.id = 'streamPath';
                    manualInput.placeholder = 'Enter SignalK path manually (e.g., navigation.position)';
                    manualInput.style.cssText = this.style.cssText;
                    
                    this.parentNode.replaceChild(manualInput, this);
                    manualInput.focus();
                }
            });
        });

        async function createStream() {
            const streamConfig = {
                name: document.getElementById('streamName').value.trim(),
                path: document.getElementById('streamPath').value.trim(),
                timeRange: document.getElementById('streamTimeRange').value,
                resolution: parseInt(document.getElementById('streamResolution').value),
                rate: parseInt(document.getElementById('streamRate').value),
                aggregateMethod: document.getElementById('streamAggregateMethod').value,
                windowSize: parseInt(document.getElementById('streamWindowSize').value),
                autoStart: document.getElementById('streamAutoStart').checked
            };

            // Handle custom time range
            if (streamConfig.timeRange === 'custom') {
                streamConfig.startTime = document.getElementById('streamStartTime').value;
                streamConfig.endTime = document.getElementById('streamEndTime').value;
                
                if (!streamConfig.startTime || !streamConfig.endTime) {
                    alert('Custom time range requires both start and end times');
                    return;
                }
            }

            if (!streamConfig.name || !streamConfig.path) {
                alert('Stream name and path are required');
                return;
            }

            // Streaming functionality has been disabled
            alert('Streaming functionality has been disabled');
        }

        async function startStream(streamId) {
            await streamAction(streamId, 'start');
        }

        async function pauseStream(streamId) {
            await streamAction(streamId, 'pause');
        }

        async function stopStream(streamId) {
            await streamAction(streamId, 'stop');
        }

        async function deleteStream(streamId) {
            if (!confirm('Are you sure you want to delete this stream? This action cannot be undone.')) {
                return;
            }
            await streamAction(streamId, 'delete');
        }

        async function streamAction(streamId, action) {
            try {
                const method = action === 'delete' ? 'DELETE' : 'PUT';
                const url = action === 'delete' ? 
                    `/plugins/signalk-parquet/api/streams/${streamId}` :
                    `/plugins/signalk-parquet/api/streams/${streamId}/${action}`;
                
                const response = await fetch(url, { method });
                const result = await response.json();

                if (result.success) {
                    // Streaming disabled - no need to refresh
                    const actionMsg = action === 'delete' ? 'deleted' : `${action}ed`;
                    // Don't show alert for successful actions, just refresh the display
                } else {
                    alert(`Error ${action}ing stream: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }

        async function editStream(streamId) {
            try {
                // Get the current stream configuration
                // Streaming functionality has been disabled
                alert('Streaming functionality has been disabled');
                return;
                
                if (!result.success) {
                    alert('Error loading stream data');
                    return;
                }
                
                const stream = result.streams.find(s => s.id === streamId);
                if (!stream) {
                    alert('Stream not found');
                    return;
                }
                
                // Populate the form with current values
                document.getElementById('streamName').value = stream.name || '';
                
                // Handle path selection - check if it exists in dropdown
                const pathSelect = document.getElementById('streamPath');
                const streamPath = stream.path || '';
                let pathFound = false;
                
                for (let option of pathSelect.options) {
                    if (option.value === streamPath) {
                        pathSelect.value = streamPath;
                        pathFound = true;
                        break;
                    }
                }
                
                // If path not found in dropdown, convert to manual input
                if (!pathFound && streamPath) {
                    const manualInput = document.createElement('input');
                    manualInput.type = 'text';
                    manualInput.id = 'streamPath';
                    manualInput.value = streamPath;
                    manualInput.placeholder = 'Enter SignalK path manually (e.g., navigation.position)';
                    manualInput.style.cssText = pathSelect.style.cssText;
                    
                    pathSelect.parentNode.replaceChild(manualInput, pathSelect);
                }
                
                document.getElementById('streamTimeRange').value = stream.timeRange || '1h';
                document.getElementById('streamResolution').value = stream.resolution || 30000;
                document.getElementById('streamRate').value = stream.rate || 1000;
                document.getElementById('streamAggregateMethod').value = stream.aggregateMethod || 'average';
                document.getElementById('streamWindowSize').value = stream.windowSize || 50;
                document.getElementById('streamAutoStart').checked = false; // Don't auto-start on edit
                
                // Handle custom time range
                if (stream.timeRange === 'custom') {
                    document.getElementById('customTimeRange').style.display = 'block';
                    document.getElementById('streamStartTime').value = stream.startTime || '';
                    document.getElementById('streamEndTime').value = stream.endTime || '';
                } else {
                    document.getElementById('customTimeRange').style.display = 'none';
                }
                
                // Show the form and change the create button to update
                document.getElementById('addStreamForm').style.display = 'block';
                document.getElementById('addStreamButton').style.display = 'none';
                
                // Change form title and button
                const formTitle = document.querySelector('#addStreamForm h4');
                formTitle.textContent = `Edit Stream: ${stream.name}`;
                
                // Replace create button with update/cancel buttons
                const buttonContainer = document.querySelector('#addStreamForm .form-group:last-child > div');
                buttonContainer.innerHTML = `
                    <button onclick="updateStream('${streamId}')">✅ Update Stream</button>
                    <button class="btn-secondary" onclick="cancelEditStream()">❌ Cancel</button>
                `;
                
            } catch (error) {
                alert(`Error loading stream for editing: ${error.message}`);
            }
        }

        async function updateStream(streamId) {
            const streamConfig = {
                name: document.getElementById('streamName').value.trim(),
                path: document.getElementById('streamPath').value.trim(),
                timeRange: document.getElementById('streamTimeRange').value,
                resolution: parseInt(document.getElementById('streamResolution').value),
                rate: parseInt(document.getElementById('streamRate').value),
                aggregateMethod: document.getElementById('streamAggregateMethod').value,
                windowSize: parseInt(document.getElementById('streamWindowSize').value),
                autoRestart: true // Restart if it was running
            };

            // Handle custom time range
            if (streamConfig.timeRange === 'custom') {
                streamConfig.startTime = document.getElementById('streamStartTime').value;
                streamConfig.endTime = document.getElementById('streamEndTime').value;
                
                if (!streamConfig.startTime || !streamConfig.endTime) {
                    alert('Custom time range requires both start and end times');
                    return;
                }
            }

            if (!streamConfig.name || !streamConfig.path) {
                alert('Stream name and path are required');
                return;
            }

            // Streaming functionality has been disabled
            alert('Streaming functionality has been disabled');
        }

        function cancelEditStream() {
            // Hide the form and reset it
            hideAddStreamForm();
            
            // Reset form title and buttons
            const formTitle = document.querySelector('#addStreamForm h4');
            formTitle.textContent = 'Add New Stream Configuration';
            
            const buttonContainer = document.querySelector('#addStreamForm .form-group:last-child > div');
            buttonContainer.innerHTML = `
                <button onclick="createStream()">✅ Create Stream</button>
                <button class="btn-secondary" onclick="hideAddStreamForm()">❌ Cancel</button>
            `;
        }

        // Live Data Display Functions
        let liveDataEntries = [];
        let liveDataPaused = false;
        const MAX_LIVE_ENTRIES = 100;

        function addLiveDataEntry(streamId, streamName, path, value, timestamp, ema = null, sma = null) {
            if (liveDataPaused) return;

            // Check for duplicates using streamId (which now includes timestamp)
            const existingEntry = liveDataEntries.find(entry => entry.streamId === streamId);
            if (existingEntry) {
                return; // Skip duplicate entry
            }

            const entry = {
                timestamp: timestamp || new Date().toISOString(),
                streamId: streamId,
                streamName: streamName,
                path: path,
                value: value,
                ema: ema,
                sma: sma
            };

            // Add entry to array
            liveDataEntries.push(entry);
            
            // Sort by timestamp (newest first)
            liveDataEntries.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

            // Keep only max entries
            if (liveDataEntries.length > MAX_LIVE_ENTRIES) {
                liveDataEntries = liveDataEntries.slice(0, MAX_LIVE_ENTRIES);
            }

            updateLiveDataDisplay();
        }

        function updateLiveDataDisplay() {
            const tbody = document.getElementById('liveDataBody');
            const countElement = document.getElementById('liveDataCount');

            countElement.textContent = liveDataEntries.length;

            if (liveDataEntries.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" style="padding: 20px; text-align: center; color: #666;">
                            No data streaming yet. Start a stream to see live data.
                        </td>
                    </tr>
                `;
                return;
            }

            let html = '';
            liveDataEntries.forEach((entry, index) => {
                // Create date object and handle UTC timestamps properly
                const date = new Date(entry.timestamp);
                const now = new Date();
                
                // Check if timestamp is from today
                const isToday = date.toDateString() === now.toDateString();
                
                let timeStr;
                if (isToday) {
                    // Today: just show time
                    timeStr = date.toLocaleTimeString();
                } else {
                    // Not today: show "Aug 21, 6:25 PM" format
                    const options = { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: 'numeric', 
                        minute: '2-digit',
                        hour12: true 
                    };
                    timeStr = date.toLocaleString(undefined, options);
                }
                const valueStr = formatValue(entry.value);
                const emaStr = entry.ema !== null ? entry.ema.toFixed(3) : '-';
                const smaStr = entry.sma !== null ? entry.sma.toFixed(3) : '-';
                const rowClass = index % 2 === 0 ? 'background: #f9f9f9;' : '';
                

                html += `
                    <tr style="${rowClass}">
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee; font-family: monospace;">${timeStr}</td>
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee;"><strong>${entry.streamName}</strong></td>
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee;"><code style="font-size: 11px;">${entry.path}</code></td>
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee; font-family: monospace;">${valueStr}</td>
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee; font-family: monospace; color: #007bff;">${emaStr}</td>
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee; font-family: monospace; color: #28a745;">${smaStr}</td>
                    </tr>
                `;
            });

            tbody.innerHTML = html;
        }

        function formatValue(value) {
            if (value === null || value === undefined) {
                return '<em>null</em>';
            }
            
            if (typeof value === 'object') {
                if (value.latitude !== undefined && value.longitude !== undefined) {
                    // Position object
                    return `${value.latitude.toFixed(6)}, ${value.longitude.toFixed(6)}`;
                }
                // Other objects - show as JSON
                return JSON.stringify(value);
            }
            
            if (typeof value === 'number') {
                return value.toFixed(3);
            }
            
            return String(value);
        }

        function clearLiveData() {
            if (confirm('Clear all live data entries?')) {
                liveDataEntries = [];
                updateLiveDataDisplay();
            }
        }

        function toggleLiveDataPause() {
            liveDataPaused = !liveDataPaused;
            const btn = document.getElementById('pauseDataBtn');
            btn.textContent = liveDataPaused ? '▶️ Resume' : '⏸️ Pause';
            btn.style.background = liveDataPaused ? '#28a745' : '#ffc107';
        }

        function showDataSummary() {
            const panel = document.getElementById('dataSummaryPanel');
            const content = document.getElementById('dataSummaryContent');
            
            if (panel.style.display === 'none') {
                // Analyze the data
                const pathStats = {};
                const streamTypes = {initial: 0, incremental: 0};
                let totalBuckets = 0;
                
                liveDataEntries.forEach(entry => {
                    // Extract path and value
                    const path = entry.path;
                    const value = parseFloat(entry.value);
                    const streamName = entry.streamName;
                    
                    if (!isNaN(value)) {
                        if (!pathStats[path]) {
                            pathStats[path] = {
                                values: [],
                                methods: new Set(),
                                bucketCounts: []
                            };
                        }
                        pathStats[path].values.push(value);
                        
                        // Extract method and bucket count from stream name
                        const methodMatch = streamName.match(/(INITIAL|INCREMENTAL): (\w+)/);
                        if (methodMatch) {
                            const [, type, method] = methodMatch;
                            pathStats[path].methods.add(method);
                            streamTypes[type.toLowerCase()]++;
                        }
                        
                        // Extract bucket count
                        const bucketMatch = streamName.match(/\((\d+) buckets\)/);
                        if (bucketMatch) {
                            const bucketCount = parseInt(bucketMatch[1]);
                            pathStats[path].bucketCounts.push(bucketCount);
                            totalBuckets += bucketCount;
                        }
                    }
                });
                
                let summaryHtml = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">';
                
                // Stream Statistics
                summaryHtml += '<div><strong>📈 Stream Activity:</strong><br/>';
                summaryHtml += `Initial Loads: ${streamTypes.initial}<br/>`;
                summaryHtml += `Incremental Updates: ${streamTypes.incremental}<br/>`;
                summaryHtml += `Total Time Buckets: ${totalBuckets}</div>`;
                
                // Path Analysis
                summaryHtml += '<div><strong>🎯 Path Analysis:</strong><br/>';
                Object.entries(pathStats).forEach(([path, stats]) => {
                    const values = stats.values;
                    const min = Math.min(...values).toFixed(3);
                    const max = Math.max(...values).toFixed(3);
                    const avg = (values.reduce((a, b) => a + b, 0) / values.length).toFixed(3);
                    const latest = values[0]?.toFixed(3) || 'N/A';
                    const methods = Array.from(stats.methods).join(', ');
                    const avgBuckets = stats.bucketCounts.length > 0 ? 
                        (stats.bucketCounts.reduce((a, b) => a + b, 0) / stats.bucketCounts.length).toFixed(0) : 'N/A';
                    
                    summaryHtml += `<strong>${path}:</strong><br/>`;
                    summaryHtml += `• Methods: ${methods}<br/>`;
                    summaryHtml += `• Range: ${min} - ${max}<br/>`;
                    summaryHtml += `• Average: ${avg}<br/>`;
                    summaryHtml += `• Latest: ${latest}<br/>`;
                    summaryHtml += `• Avg Buckets: ${avgBuckets}<br/><br/>`;
                });
                summaryHtml += '</div></div>';
                
                // Data Trends
                summaryHtml += '<div style="margin-top: 15px;"><strong>📊 Data Interpretation:</strong><br/>';
                summaryHtml += 'This shows your time-bucketed statistical streaming in action!<br/>';
                summaryHtml += '• Each row represents a statistical calculation (MAX, AVG, etc.) for a time bucket<br/>';
                summaryHtml += '• INITIAL = First load with full time window<br/>';
                summaryHtml += '• INCREMENTAL = New buckets from sliding window updates<br/>';
                summaryHtml += '• Values change as new data arrives and statistics are recalculated</div>';
                
                content.innerHTML = summaryHtml;
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        // WebSocket connection for real-time streaming data
        let ws = null;
        let wsReconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        function connectWebSocket() {
            // For now, use polling mode since we need a dedicated WebSocket server
            startLiveDataPolling();
        }

        function handleWebSocketMessage(message) {
            // Handle time-series data from our streaming service
            if (message.type === 'timeSeriesData') {
                handleTimeSeriesData(message);
            }
            // Handle regular SignalK delta messages
            else if (message.updates && Array.isArray(message.updates)) {
                message.updates.forEach(update => {
                    if (update.values && Array.isArray(update.values)) {
                        update.values.forEach(valueUpdate => {
                            addLiveDataEntry(
                                'signalk',
                                'SignalK Stream',
                                valueUpdate.path,
                                valueUpdate.value,
                                update.timestamp || new Date().toISOString()
                            );
                        });
                    }
                });
            }
        }

        function handleTimeSeriesData(message) {
            const { streamId, metadata, data } = message;
            
            
            // Add each time-bucketed data point to the live display
            data.forEach((point, index) => {
                const displayValue = typeof point.value === 'object' ? 
                    JSON.stringify(point.value) : 
                    (typeof point.value === 'number' ? point.value.toFixed(3) : point.value);
                
                const displayName = `${metadata.aggregateMethod.toUpperCase()}: ${metadata.path}`;
                const bucketInfo = `[${point.bucketIndex}/${metadata.totalPoints}]`;
                
                // Extract EMA and SMA if available for numeric values
                const ema = (typeof point.ema === 'number') ? point.ema : null;
                const sma = (typeof point.sma === 'number') ? point.sma : null;
                
                addLiveDataEntry(
                    streamId,
                    `${displayName} ${bucketInfo}`,
                    metadata.path,
                    displayValue,
                    point.timestamp,
                    ema,
                    sma
                );
            });
        }

        // Enhanced polling function that shows real time-bucketed streaming data points
        function startLiveDataPolling() {
            
            let pollCount = 0;
            
            setInterval(async () => {
                if (liveDataPaused) return;

                pollCount++;

                // Streaming functionality has been disabled - no running streams
                return;
            }, 3000); // Check every 3 seconds
        }

        // Initialize WebSocket connection when page loads  
        setTimeout(() => {
            connectWebSocket();
        }, 1000);

        // ===========================================
        // CLAUDE AI INTEGRATION FUNCTIONS
        // ===========================================

        // Test Claude API connection
        async function testClaudeConnection() {
            const btn = document.getElementById('testConnectionBtn');
            const result = document.getElementById('claudeConnectionResult');
            
            btn.disabled = true;
            btn.innerHTML = '🔄 Testing...';
            result.innerHTML = '';
            
            try {
                const response = await fetch('/plugins/signalk-parquet/api/analyze/test-connection', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    result.innerHTML = `<div style="color: green; padding: 10px; background: #d4edda; border-radius: 5px;">
                        ✅ Claude API connection successful!<br>
                        Model: ${data.model}<br>
                        Response time: ${data.responseTime}ms
                    </div>`;
                } else {
                    result.innerHTML = `<div style="color: red; padding: 10px; background: #f8d7da; border-radius: 5px;">
                        ❌ Connection failed: ${data.error}
                    </div>`;
                }
            } catch (error) {
                result.innerHTML = `<div style="color: red; padding: 10px; background: #f8d7da; border-radius: 5px;">
                    ❌ Error: ${error.message}
                </div>`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = '🔗 Test Claude Connection';
            }
        }

        // ===========================================
        // VESSEL CONTEXT FUNCTIONS
        // ===========================================

        // Load vessel context when AI tab is initialized
        async function loadVesselContext() {
            try {
                console.log('Loading vessel context...');
                const response = await fetch('/plugins/signalk-parquet/api/vessel-context');
                console.log('Vessel context response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Vessel context data:', data);
                
                if (data.success && data.data) {
                    const context = data.data;
                    
                    // Update auto-extracted vessel info display
                    displayVesselInfo(context.vesselInfo);
                    
                    // Update custom context textarea
                    const customContextTextarea = document.getElementById('customVesselContext');
                    if (customContextTextarea) {
                        customContextTextarea.value = context.customContext || '';
                    }
                    
                    // Show last updated info
                    updateVesselContextStatus(`Last updated: ${new Date(context.lastUpdated).toLocaleString()}`);
                } else {
                    console.log('No vessel context data found, showing empty state');
                    displayVesselInfo({});
                    updateVesselContextStatus('No vessel context found - click Refresh to extract from SignalK');
                }
            } catch (error) {
                console.error('Error loading vessel context:', error);
                const autoInfoDiv = document.getElementById('autoVesselInfo');
                if (autoInfoDiv) {
                    autoInfoDiv.innerHTML = `<div style="color: red;">Error loading vessel context: ${error.message}</div>`;
                }
                updateVesselContextStatus('Error loading vessel context: ' + error.message, true);
            }
        }

        // Display vessel information in the UI
        function displayVesselInfo(vesselInfo) {
            const autoInfoDiv = document.getElementById('autoVesselInfo');
            if (!autoInfoDiv) return;
            
            if (!vesselInfo || Object.keys(vesselInfo).length === 0) {
                autoInfoDiv.innerHTML = `
                    <div style="color: #666; font-style: italic; text-align: center; padding: 20px;">
                        No vessel information found.<br>
                        <small>Click "Refresh from SignalK" to extract vessel data automatically.</small>
                    </div>`;
                return;
            }
            
            const sections = [];
            
            // Basic identification
            if (vesselInfo.name || vesselInfo.callsign || vesselInfo.mmsi) {
                const items = [];
                if (vesselInfo.name) items.push(`<strong>Name:</strong> ${vesselInfo.name}`);
                if (vesselInfo.callsign) items.push(`<strong>Call Sign:</strong> ${vesselInfo.callsign}`);
                if (vesselInfo.mmsi) items.push(`<strong>MMSI:</strong> ${vesselInfo.mmsi}`);
                if (vesselInfo.flag) items.push(`<strong>Flag:</strong> ${vesselInfo.flag}`);
                sections.push(`<div><strong>🆔 Identification:</strong> ${items.join(', ')}</div>`);
            }
            
            // Physical characteristics
            const physical = [];
            
            // Handle length - could be number or object with overall property
            if (vesselInfo.length) {
                const lengthValue = typeof vesselInfo.length === 'object' && vesselInfo.length.overall 
                    ? vesselInfo.length.overall 
                    : vesselInfo.length;
                if (lengthValue) physical.push(`${lengthValue}m LOA`);
            }
            
            if (vesselInfo.beam) physical.push(`${vesselInfo.beam}m beam`);
            
            // Handle draft - could be number or object with maximum property  
            if (vesselInfo.draft) {
                const draftValue = typeof vesselInfo.draft === 'object' && vesselInfo.draft.maximum
                    ? vesselInfo.draft.maximum
                    : vesselInfo.draft;
                if (draftValue) physical.push(`${draftValue}m draft`);
            }
            
            if (vesselInfo.height) physical.push(`${vesselInfo.height}m height`);
            if (vesselInfo.displacement) physical.push(`${vesselInfo.displacement}t displacement`);
            if (physical.length > 0) {
                sections.push(`<div><strong>📏 Physical:</strong> ${physical.join(', ')}</div>`);
            }
            
            // Vessel type
            if (vesselInfo.vesselType) {
                sections.push(`<div><strong>🚢 Type:</strong> ${vesselInfo.vesselType}</div>`);
            }
            
            // Technical specs
            const technical = [];
            if (vesselInfo.grossTonnage) technical.push(`${vesselInfo.grossTonnage} GT`);
            if (vesselInfo.netTonnage) technical.push(`${vesselInfo.netTonnage} NT`);
            if (vesselInfo.deadWeight) technical.push(`${vesselInfo.deadWeight}t DWT`);
            if (technical.length > 0) {
                sections.push(`<div><strong>⚖️ Tonnage:</strong> ${technical.join(', ')}</div>`);
            }
            
            // Build info
            const build = [];
            if (vesselInfo.builder) build.push(`Built by ${vesselInfo.builder}`);
            if (vesselInfo.buildYear) build.push(`in ${vesselInfo.buildYear}`);
            if (vesselInfo.hullNumber) build.push(`(Hull: ${vesselInfo.hullNumber})`);
            if (build.length > 0) {
                sections.push(`<div><strong>🔨 Build:</strong> ${build.join(' ')}</div>`);
            }
            
            if (sections.length === 0) {
                autoInfoDiv.innerHTML = `<div style="color: #666; font-style: italic;">No vessel details available - try refreshing from SignalK</div>`;
            } else {
                autoInfoDiv.innerHTML = sections.join('<br style="margin: 8px 0;">');
            }
        }

        // Refresh vessel information from SignalK
        async function refreshVesselInfo() {
            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = '🔄 Refreshing...';
            
            try {
                console.log('Refreshing vessel info from SignalK...');
                const response = await fetch('/plugins/signalk-parquet/api/vessel-context/refresh', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                console.log('Refresh response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Refresh data:', data);
                
                if (data.success && data.data) {
                    displayVesselInfo(data.data.vesselInfo);
                    updateVesselContextStatus('Vessel information refreshed from SignalK data');
                } else {
                    console.error('Refresh failed:', data);
                    updateVesselContextStatus('Failed to refresh: ' + (data.error || 'Unknown error'), true);
                }
            } catch (error) {
                console.error('Error refreshing vessel info:', error);
                updateVesselContextStatus('Error refreshing vessel information: ' + error.message, true);
            } finally {
                btn.disabled = false;
                btn.innerHTML = '🔄 Refresh from SignalK';
            }
        }

        // Save vessel context (both auto-extracted and custom)
        async function saveVesselContext() {
            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = '💾 Saving...';
            
            try {
                const customContext = document.getElementById('customVesselContext').value;
                
                const response = await fetch('/plugins/signalk-parquet/api/vessel-context', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        customContext: customContext
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    updateVesselContextStatus('Context saved successfully ✅');
                } else {
                    updateVesselContextStatus('Failed to save: ' + (data.error || 'Unknown error'), true);
                }
            } catch (error) {
                console.error('Error saving vessel context:', error);
                updateVesselContextStatus('Error saving context: ' + error.message, true);
            } finally {
                btn.disabled = false;
                btn.innerHTML = '💾 Save Context';
            }
        }

        // Preview Claude context
        async function previewClaudeContext() {
            try {
                console.log('Generating Claude context preview...');
                const response = await fetch('/plugins/signalk-parquet/api/vessel-context/claude-preview');
                console.log('Preview response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Preview data:', data);
                
                if (data.success && data.data) {
                    const modal = document.getElementById('contextPreviewModal');
                    const content = document.getElementById('contextPreviewContent');
                    
                    content.textContent = data.data.contextText;
                    modal.style.display = 'block';
                } else {
                    console.error('Preview failed:', data);
                    updateVesselContextStatus('Failed to generate preview: ' + (data.error || 'Unknown error'), true);
                }
            } catch (error) {
                console.error('Error previewing context:', error);
                updateVesselContextStatus('Error generating preview: ' + error.message, true);
            }
        }

        // Close context preview modal
        function closeContextPreview() {
            const modal = document.getElementById('contextPreviewModal');
            modal.style.display = 'none';
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const contextModal = document.getElementById('contextPreviewModal');
            const historyModal = document.getElementById('analysisHistoryModal');
            const viewModal = document.getElementById('analysisViewModal');
            
            if (event.target === contextModal) {
                contextModal.style.display = 'none';
            } else if (event.target === historyModal) {
                historyModal.style.display = 'none';
            } else if (event.target === viewModal) {
                viewModal.style.display = 'none';
            }
        }

        // Update vessel context status message
        function updateVesselContextStatus(message, isError = false) {
            const statusDiv = document.getElementById('vesselContextStatus');
            if (statusDiv) {
                statusDiv.innerHTML = `<span style="color: ${isError ? 'red' : 'green'};">${message}</span>`;
                
                // Clear status after 5 seconds
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 5000);
            }
        }

        // Toggle vessel context section
        function toggleVesselContext() {
            const content = document.getElementById('vesselContextContent');
            const icon = document.getElementById('vesselContextToggleIcon');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '▼';
            } else {
                content.style.display = 'none';
                icon.textContent = '▶';
            }
        }

        // ===========================================
        // END VESSEL CONTEXT FUNCTIONS
        // ===========================================

        // Load analysis templates and populate UI
        async function loadAnalysisTemplates() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/analyze/templates');
                const data = await response.json();
                
                if (data.success && data.templates) {
                    // Flatten template categories into a single array
                    const allTemplates = [];
                    data.templates.forEach(category => {
                        if (category.templates) {
                            allTemplates.push(...category.templates);
                        }
                    });
                    populateTemplateCards(allTemplates);
                    populateTemplateDropdown(allTemplates);
                }
            } catch (error) {
                console.error('Error loading analysis templates:', error);
            }
        }


        // Populate template dropdown
        function populateTemplateDropdown(templates) {
            const select = document.getElementById('analysisTemplate');
            select.innerHTML = '<option value="">Select a template...</option>';
            
            templates.forEach(template => {
                const option = document.createElement('option');
                option.value = template.id;
                option.textContent = `${template.icon} ${template.name}`;
                select.appendChild(option);
            });
        }

        // Run quick analysis WITHOUT templates - just analyze data directly
        async function runQuickAnalysis(dataPath) {
            const result = document.getElementById('analysisResults');
            const content = document.getElementById('analysisContent');
            
            result.style.display = 'block';
            content.innerHTML = '<div style="text-align: center; padding: 20px;">🔄 Running direct analysis...</div>';
            
            try {
                // Skip templates entirely - use custom analysis with generic prompt
                const analysisRequest = {
                    dataPath,
                    analysisType: 'custom',
                    customPrompt: `Analyze this maritime sensor data and provide insights. Focus on:
1. Data patterns and trends over time
2. Any anomalies or unusual readings  
3. Statistical summary of the data
4. Practical insights for maritime operations
5. Data quality assessment

Provide actionable insights based on what you observe in the data.`,
                    timeRange: {
                        start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(), // Last 7 days
                        end: new Date().toISOString()
                    }
                };
                
                console.log(`🚀 Running template-free analysis for: ${dataPath}`);
                
                const response = await fetch('/plugins/signalk-parquet/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisRequest)
                });
                
                const data = await response.json();
                
                if (data.success && data.data) {
                    displayAnalysisResult(data.data);
                } else {
                    content.innerHTML = `<div style="color: red;">❌ Analysis failed: ${data.error}</div>`;
                }
                
            } catch (error) {
                content.innerHTML = `<div style="color: red;">❌ Error: ${error.message}</div>`;
            }
        }

        // Get selected data paths
        function getSelectedDataPaths() {
            const checkboxes = document.querySelectorAll('#analysisDataPathContainer input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(checkbox => checkbox.value);
        }

        // Update selected path count
        function updateSelectedPathCount() {
            const selectedPaths = getSelectedDataPaths();
            document.getElementById('selectedPathCount').textContent = selectedPaths.length;
        }

        // Handle path checkbox change
        function handlePathCheckboxChange() {
            updateSelectedPathCount();
        }

        // Select all paths
        function selectAllPaths() {
            const checkboxes = document.querySelectorAll('#analysisDataPathContainer input[type="checkbox"]');
            checkboxes.forEach(checkbox => checkbox.checked = true);
            updateSelectedPathCount();
        }

        // Clear all paths
        function clearAllPaths() {
            const checkboxes = document.querySelectorAll('#analysisDataPathContainer input[type="checkbox"]');
            checkboxes.forEach(checkbox => checkbox.checked = false);
            updateSelectedPathCount();
        }

        // Get path icon based on path name
        function getPathIcon(path) {
            let icon = '📊';
            if (path.includes('wind')) icon = '💨';
            else if (path.includes('navigation')) icon = '🧭';
            else if (path.includes('position')) icon = '📍';
            else if (path.includes('temperature')) icon = '🌡️';
            else if (path.includes('battery') || path.includes('electrical')) icon = '🔋';
            else if (path.includes('command')) icon = '⚙️';
            return icon;
        }

        // Populate analysis path checkboxes
        function populateAnalysisPathCheckboxes(paths) {
            const container = document.getElementById('analysisDataPathContainer');
            
            if (!paths || paths.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic;">No data paths available</div>';
                return;
            }
            
            container.innerHTML = ''; // Clear loading message
            
            paths.forEach((pathInfo, index) => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'path-checkbox-row';
                
                const pathInfoDiv = document.createElement('div');
                pathInfoDiv.className = 'path-info';
                
                const iconSpan = document.createElement('span');
                iconSpan.className = 'path-icon';
                iconSpan.textContent = getPathIcon(pathInfo.path);
                
                const label = document.createElement('label');
                label.htmlFor = `path_${pathInfo.path.replace(/[^a-zA-Z0-9]/g, '_')}`;
                label.textContent = `${pathInfo.path} (${pathInfo.fileCount} files)`;
                label.style.cssText = 'cursor: pointer; margin: 0;';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = pathInfo.path;
                checkbox.id = `path_${pathInfo.path.replace(/[^a-zA-Z0-9]/g, '_')}`;
                checkbox.onchange = handlePathCheckboxChange;
                checkbox.className = 'path-checkbox';
                
                pathInfoDiv.appendChild(iconSpan);
                pathInfoDiv.appendChild(label);
                checkboxDiv.appendChild(pathInfoDiv);
                checkboxDiv.appendChild(checkbox);
                container.appendChild(checkboxDiv);
            });
            
            updateSelectedPathCount();
        }

        // Global variable to track current analysis request
        let currentAnalysisController = null;

        // Cancel current analysis
        function cancelAnalysis() {
            if (currentAnalysisController) {
                currentAnalysisController.abort();
                currentAnalysisController = null;
            }
        }

        // Run custom analysis
        async function runCustomAnalysis() {
            const runButton = document.getElementById('runAnalysisBtn') || document.querySelector('button[onclick="runCustomAnalysis()"]');

            // If already running, cancel the current analysis
            if (currentAnalysisController) {
                cancelAnalysis();
                return;
            }
            const selectedPaths = getSelectedDataPaths();
            const customPrompt = document.getElementById('customPrompt').value;
            const startDate = document.getElementById('analysisStartDate').value;
            const endDate = document.getElementById('analysisEndDate').value;
            const aggregationMethod = document.getElementById('aggregationMethod').value;
            const resolution = document.getElementById('resolution').value;
            const claudeModel = document.getElementById('claudeModelMain').value;
            const enableDatabaseAccess = document.getElementById('enableDatabaseAccess').checked;
            
            // Skip path validation in database access mode - Claude can access all data
            if (!enableDatabaseAccess && (!selectedPaths || selectedPaths.length === 0)) {
                alert('Please select at least one data path');
                return;
            }
            
            const result = document.getElementById('analysisResults');
            const content = document.getElementById('analysisContent');
            
            result.style.display = 'block';
            
            // Start timer
            const startTime = new Date();
            const timerElement = document.createElement('div');
            timerElement.id = 'analysisTimer';
            timerElement.style.cssText = 'background: #e3f2fd; border: 1px solid #2196f3; border-radius: 5px; padding: 10px; margin-bottom: 15px; text-align: center; font-family: monospace;';
            
            content.innerHTML = '';
            content.appendChild(timerElement);
            
            const loadingElement = document.createElement('div');
            loadingElement.style.cssText = 'text-align: center; padding: 20px;';
            loadingElement.innerHTML = ``;
            content.appendChild(loadingElement);
            
            // Update timer every 100ms
            const timerInterval = setInterval(() => {
                const elapsed = (new Date() - startTime) / 1000;
                timerElement.innerHTML = `
                    <strong>⏱️ Analysis Timer</strong><br>
                    Prompt sent: ${startTime.toLocaleTimeString()}<br>
                    Elapsed: ${elapsed.toFixed(1)}s
                `;
            }, 100);
            
            // Update button to show running state
            const originalButtonText = runButton.textContent;
            runButton.textContent = '⏸️ Running Analysis (click to cancel)';
            runButton.style.background = '#ffc107';

            try {
                // Create abort controller for cancellation
                currentAnalysisController = new AbortController();

                const analysisRequest = {
                    dataPath: enableDatabaseAccess ? 'database_access_mode' : selectedPaths.join(','), // REST API supports comma-separated paths
                    analysisType: 'custom',
                    customPrompt: customPrompt || `Analyze this maritime sensor data and provide insights. Focus on:
1. Data patterns and trends over time
2. Any anomalies or unusual readings
3. Statistical summary of the data
4. Practical insights for maritime operations
5. Data quality assessment

Provide actionable insights based on what you observe in the data.`,
                    timeRange: {
                        start: startDate ? new Date(startDate).toISOString() : new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
                        end: endDate ? new Date(endDate).toISOString() : new Date().toISOString()
                    },
                    aggregationMethod: aggregationMethod || 'average',
                    resolution: resolution || '',  // Empty string = Auto
                    claudeModel: claudeModel || 'claude-sonnet-4-20250514',
                    useDatabaseAccess: enableDatabaseAccess,
                };

                console.log(`🚀 Running custom analysis for paths: ${selectedPaths.join(', ')}`);

                const response = await fetch('/plugins/signalk-parquet/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisRequest),
                    signal: currentAnalysisController.signal
                });
                
                const data = await response.json();
                
                // Stop timer and show final time
                clearInterval(timerInterval);
                const endTime = new Date();
                const totalTime = (endTime - startTime) / 1000;
                // Debug what we're actually getting
                console.log('Full response data:', JSON.stringify(data, null, 2));
                
                // Get token usage if available
                let tokenInfo = '';
                if (data.usage) {
                    const usage = data.usage;
                    tokenInfo = `<br><strong>Tokens: ${usage.input_tokens || 0} in + ${usage.output_tokens || 0} out = ${(usage.input_tokens || 0) + (usage.output_tokens || 0)} total</strong>`;
                } else {
                    tokenInfo = `<br><small style="color: #666;">No token usage found in response</small>`;
                }
                
                timerElement.innerHTML = `
                    <strong>⏱️ Analysis Complete</strong><br>
                    Started: ${startTime.toLocaleTimeString()}<br>
                    Completed: ${endTime.toLocaleTimeString()}<br>
                    <strong>Total Time: ${totalTime.toFixed(1)}s</strong>${tokenInfo}
                `;
                timerElement.style.background = data.success ? '#e8f5e8' : '#ffeaea';
                timerElement.style.borderColor = data.success ? '#4caf50' : '#f44336';
                
                // Remove loading message and clear controller
                loadingElement.remove();
                currentAnalysisController = null;

                // Restore button
                runButton.textContent = originalButtonText;
                runButton.style.background = '';

                if (data.success && data.data) {
                    displayAnalysisResult(data.data);
                } else {
                    const errorElement = document.createElement('div');
                    errorElement.style.color = 'red';
                    errorElement.innerHTML = `❌ Analysis failed: ${data.error}`;
                    content.appendChild(errorElement);
                }
                
            } catch (error) {
                // Stop timer on error
                clearInterval(timerInterval);
                const endTime = new Date();
                const totalTime = (endTime - startTime) / 1000;

                // Check if it was cancelled
                if (error.name === 'AbortError') {
                    timerElement.innerHTML = `
                        <strong>❌ Analysis Cancelled</strong><br>
                        Started: ${startTime.toLocaleTimeString()}<br>
                        Cancelled: ${endTime.toLocaleTimeString()}<br>
                        <strong>Time: ${totalTime.toFixed(1)}s</strong>
                    `;
                    timerElement.style.background = '#fff3cd';
                    timerElement.style.borderColor = '#ffc107';
                } else {
                    timerElement.innerHTML = `
                        <strong>⏱️ Analysis Failed</strong><br>
                        Started: ${startTime.toLocaleTimeString()}<br>
                        Failed: ${endTime.toLocaleTimeString()}<br>
                        <strong>Total Time: ${totalTime.toFixed(1)}s</strong>
                    `;
                    timerElement.style.background = '#ffeaea';
                    timerElement.style.borderColor = '#f44336';
                }

                loadingElement.remove();
                currentAnalysisController = null;

                // Restore button
                runButton.textContent = originalButtonText;
                runButton.style.background = '';

                const errorElement = document.createElement('div');
                errorElement.style.color = 'red';
                errorElement.innerHTML = `❌ Error: ${error.message}`;
                content.appendChild(errorElement);
            }
        }

        // Convert MMSI numbers to MarineTraffic links
        function convertMMSIToLinks(container) {
            const mmsiRegex = /(MMSI:?\s?)(\d{8,9})/gi;
            
            // Function to recursively process text nodes
            function processTextNodes(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent;
                    if (mmsiRegex.test(text)) {
                        const newText = text.replace(mmsiRegex, (match, prefix, mmsi) => {
                            return `${prefix}<a href="https://www.marinetraffic.com/en/ais/details/ships/mmsi:${mmsi}" target="_blank" style="color: #1976d2; text-decoration: underline;" title="View ${mmsi} on MarineTraffic">${mmsi}</a>`;
                        });
                        
                        // Replace text node with HTML
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = newText;
                        
                        // Replace the text node with new nodes
                        const fragment = document.createDocumentFragment();
                        while (tempDiv.firstChild) {
                            fragment.appendChild(tempDiv.firstChild);
                        }
                        node.parentNode.replaceChild(fragment, node);
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    // Process child nodes (but skip existing links)
                    if (node.tagName.toLowerCase() !== 'a') {
                        const children = Array.from(node.childNodes);
                        children.forEach(child => processTextNodes(child));
                    }
                }
            }
            
            processTextNodes(container);
        }

        // Process and embed charts from Claude responses
        function processChartRequests(container) {
            console.log('Processing chart requests in container:', container);
            // Look for JSON chart specifications in the text - improved pattern to handle nested objects
            const chartRegex = /```json\s*([\s\S]*?"type":\s*"chart"[\s\S]*?)\s*```/gi;
            
            // First try processing the entire innerHTML
            const fullText = container.innerHTML || container.textContent || '';
            console.log('Full container text:', fullText.substring(0, 500));
            const fullMatches = [...fullText.matchAll(chartRegex)];
            console.log('Matches in full text:', fullMatches.length);
            
            // Process all matches found in full text
            let processedCharts = false;
            if (fullMatches.length > 0) {
                let newHTML = fullText;
                fullMatches.forEach((match, index) => {
                    try {
                        let jsonString = match[1].trim();
                        jsonString = jsonString.replace(/&quot;/g, '"').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                        
                        // Extract only valid JSON by finding the first complete JSON object
                        let validJsonString = jsonString;
                        try {
                            // Find the end of the first complete JSON object
                            let braceCount = 0;
                            let inString = false;
                            let escaped = false;
                            let jsonEndIndex = -1;
                            
                            for (let i = 0; i < jsonString.length; i++) {
                                const char = jsonString[i];
                                
                                if (escaped) {
                                    escaped = false;
                                    continue;
                                }
                                
                                if (char === '\\' && inString) {
                                    escaped = true;
                                    continue;
                                }
                                
                                if (char === '"' && !escaped) {
                                    inString = !inString;
                                    continue;
                                }
                                
                                if (!inString) {
                                    if (char === '{') {
                                        braceCount++;
                                    } else if (char === '}') {
                                        braceCount--;
                                        if (braceCount === 0) {
                                            jsonEndIndex = i + 1;
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            if (jsonEndIndex > 0) {
                                validJsonString = jsonString.substring(0, jsonEndIndex);
                                console.log('🔧 FRONTEND - Extracted valid JSON, length:', validJsonString.length, 'vs original:', jsonString.length);
                            }
                        } catch (extractError) {
                            console.warn('🔧 JSON extraction failed, using original:', extractError);
                        }
                        
                        console.log('🔍 FRONTEND - Processing JSON length:', validJsonString.length);
                        
                        const chartSpec = JSON.parse(validJsonString);
                        console.log('Parsed chart spec:', chartSpec);
                        
                        if (chartSpec.type === 'chart') {
                            const chartId = `chart-${Date.now()}-${Math.random().toString(36).substr(2, 9)}-${index}`;
                            const chartHTML = `
                                <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #2196F3;">
                                    <h4 style="margin: 0 0 15px 0; color: #333;">📊 ${chartSpec.title || 'Chart'}</h4>
                                    <div id="${chartId}" style="width: 100%; height: 400px;"></div>
                                </div>
                            `;
                            newHTML = newHTML.replace(match[0], chartHTML);
                            processedCharts = true;
                            
                            // Queue chart rendering for after DOM update
                            setTimeout(() => renderChart(chartId, chartSpec), 300);
                        }
                    } catch (e) {
                        console.error('Failed to parse chart specification:', e);
                        console.error('Raw JSON that failed to parse:', validJsonString);
                        
                        // Show the problematic area around the error position
                        if (e.message.includes('position')) {
                            const match = e.message.match(/position (\d+)/);
                            if (match) {
                                const errorPos = parseInt(match[1]);
                                const start = Math.max(0, errorPos - 100);
                                const end = Math.min(validJsonString.length, errorPos + 100);
                                console.error('🚨 PROBLEM AREA around position', errorPos, ':', validJsonString.substring(start, end));
                                console.error('🚨 CHARACTER AT ERROR:', validJsonString[errorPos], 'ASCII:', validJsonString.charCodeAt(errorPos));
                            }
                        }
                    }
                });
                
                if (processedCharts) {
                    container.innerHTML = newHTML;
                }
            }
            
            // Always return after processing to prevent text node processing
            // This prevents re-processing existing charts in the container
            return;
            
            function processTextNodes(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent;
                    console.log('Processing text node:', text.substring(0, 200));
                    const matches = [...text.matchAll(chartRegex)];
                    console.log('Found matches:', matches.length);
                    
                    if (matches.length > 0) {
                        let newHTML = text;
                        
                        matches.forEach((match, index) => {
                            try {
                                // Clean up the JSON string - handle HTML entities and whitespace
                                let jsonString = match[1].trim();
                                // Decode HTML entities if present
                                jsonString = jsonString.replace(/&quot;/g, '"').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                                
                                // Extract only valid JSON by finding the first complete JSON object
                                let validJsonString = jsonString;
                                try {
                                    // Find the end of the first complete JSON object
                                    let braceCount = 0;
                                    let inString = false;
                                    let escaped = false;
                                    let jsonEndIndex = -1;
                                    
                                    for (let i = 0; i < jsonString.length; i++) {
                                        const char = jsonString[i];
                                        
                                        if (escaped) {
                                            escaped = false;
                                            continue;
                                        }
                                        
                                        if (char === '\\' && inString) {
                                            escaped = true;
                                            continue;
                                        }
                                        
                                        if (char === '"' && !escaped) {
                                            inString = !inString;
                                            continue;
                                        }
                                        
                                        if (!inString) {
                                            if (char === '{') {
                                                braceCount++;
                                            } else if (char === '}') {
                                                braceCount--;
                                                if (braceCount === 0) {
                                                    jsonEndIndex = i + 1;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    
                                    if (jsonEndIndex > 0) {
                                        validJsonString = jsonString.substring(0, jsonEndIndex);
                                        console.log('🔧 FRONTEND (legacy) - Extracted valid JSON, length:', validJsonString.length, 'vs original:', jsonString.length);
                                    }
                                } catch (extractError) {
                                    console.warn('🔧 JSON extraction (legacy) failed, using original:', extractError);
                                }
                                
                                console.log('🔍 FRONTEND (legacy) - Processing JSON length:', validJsonString.length);
                                
                                const chartSpec = JSON.parse(validJsonString);
                                console.log('Parsed chart spec:', chartSpec);
                                
                                if (chartSpec.type === 'chart') {
                                    const chartId = `chart-${Date.now()}-${Math.random().toString(36).substr(2, 9)}-${index}`;
                                    const chartHTML = `
                                        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #2196F3;">
                                            <h4 style="margin: 0 0 15px 0; color: #333;">📊 ${chartSpec.title || 'Chart'}</h4>
                                            <canvas id="${chartId}" style="max-height: 400px;"></canvas>
                                        </div>
                                    `;
                                    newHTML = newHTML.replace(match[0], chartHTML);
                                    
                                    // Queue chart rendering for after DOM update
                                    setTimeout(() => renderChart(chartId, chartSpec), 300);
                                }
                            } catch (e) {
                                console.error('Failed to parse chart specification:', e);
                                console.error('Raw JSON that failed to parse:', validJsonString);
                            }
                        });
                        
                        if (newHTML !== text) {
                            // Replace text node with HTML
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = newHTML;
                            const fragment = document.createDocumentFragment();
                            while (tempDiv.firstChild) {
                                fragment.appendChild(tempDiv.firstChild);
                            }
                            node.parentNode.replaceChild(fragment, node);
                        }
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    const children = Array.from(node.childNodes);
                    children.forEach(child => processTextNodes(child));
                }
            }
            
            processTextNodes(container);
        }

        // Render chart using Plotly.js (native format)
        function renderChart(chartId, chartSpec) {
            console.log('Attempting to render Plotly chart:', chartId, chartSpec);
            
            const chartDiv = document.getElementById(chartId);
            if (!chartDiv) {
                console.error('Chart div not found:', chartId);
                return;
            }
            
            console.log('Chart div found:', chartDiv);
            
            // Handle both new native Plotly format and legacy Chart.js format
            let plotlyData, plotlyLayout, plotlyConfig;
            
            if (chartSpec.data && chartSpec.layout) {
                // Native Plotly format - use directly
                console.log('Using native Plotly format');
                plotlyData = chartSpec.data;
                plotlyLayout = chartSpec.layout;
                plotlyConfig = chartSpec.config || {};
            } else if (chartSpec.datasets) {
                // Legacy Chart.js format - convert to Plotly
                console.log('Converting Chart.js format to Plotly');
                
                plotlyData = chartSpec.datasets.map(dataset => ({
                    x: chartSpec.labels || [],
                    y: dataset.data || [],
                    name: dataset.label || '',
                    type: 'scatter',
                    mode: dataset.borderDash ? 'lines' : 'lines+markers',
                    line: {
                        color: dataset.borderColor || dataset.backgroundColor || '#2196F3',
                        width: dataset.borderWidth || 2,
                        dash: dataset.borderDash ? 'dash' : 'solid'
                    },
                    marker: {
                        size: 4,
                        color: dataset.borderColor || dataset.backgroundColor || '#2196F3'
                    },
                    fill: dataset.fill ? 'tonexty' : 'none',
                    fillcolor: dataset.backgroundColor || 'rgba(33, 150, 243, 0.1)'
                }));
                
                plotlyLayout = {
                    title: {
                        text: chartSpec.title || '',
                        font: { size: 16 }
                    },
                    xaxis: {
                        title: chartSpec.xAxisLabel || '',
                        showgrid: true,
                        zeroline: false
                    },
                    yaxis: {
                        title: chartSpec.yAxisLabel || '',
                        showgrid: true,
                        zeroline: false
                    },
                    showlegend: true,
                    hovermode: 'x unified',
                    margin: { l: 60, r: 30, t: 50, b: 50 },
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    paper_bgcolor: 'rgba(0,0,0,0)'
                };
            } else {
                console.error('Invalid chart specification - no data or datasets found:', chartSpec);
                return;
            }
            
            // Default Plotly config
            const defaultConfig = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d', 'resetScale2d'],
                displaylogo: false
            };
            
            plotlyConfig = { ...defaultConfig, ...plotlyConfig };
            
            console.log('Creating Plotly chart with data:', plotlyData, 'layout:', plotlyLayout);
            
            try {
                Plotly.newPlot(chartId, plotlyData, plotlyLayout, plotlyConfig);
                console.log('Plotly chart created successfully:', chartId);
                
                return true;
            } catch (error) {
                console.error('Failed to create Plotly chart:', chartId, error);
            }
        }

        // Display analysis results
        function displayAnalysisResult(analysisResult) {
            const content = document.getElementById('analysisContent');
            
            // Keep the existing timer element at the top
            const existingTimer = document.getElementById('analysisTimer');
            let html = `
                <div style="border-left: 4px solid #667eea; padding-left: 15px; margin-bottom: 20px;">
                    <h4 style="color: #667eea; margin: 0 0 10px 0;">📊 Analysis Summary</h4>
                    <div style="white-space: pre-wrap; line-height: 1.6;">${analysisResult.analysis}</div>
                </div>
            `;
            
            if (analysisResult.insights && analysisResult.insights.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #28a745; margin: 0 0 10px 0;">💡 Key Insights</h4>
                        <ul style="padding-left: 20px;">
                            ${analysisResult.insights.map(insight => `<li style="margin-bottom: 5px;">${insight}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }
            
            if (analysisResult.recommendations && analysisResult.recommendations.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #ffc107; margin: 0 0 10px 0;">🎯 Recommendations</h4>
                        <ul style="padding-left: 20px;">
                            ${analysisResult.recommendations.map(rec => `<li style="margin-bottom: 5px;">${rec}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }
            
            if (analysisResult.anomalies && analysisResult.anomalies.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #dc3545; margin: 0 0 10px 0;">⚠️ Anomalies Detected</h4>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                            ${analysisResult.anomalies.map(anomaly => `
                                <div style="margin-bottom: 8px; padding: 8px; background: white; border-radius: 4px;">
                                    <strong>${anomaly.severity.toUpperCase()}</strong> - ${anomaly.description}
                                    <br><small style="color: #666;">Timestamp: ${new Date(anomaly.timestamp).toLocaleString()}</small>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            html += `
                <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #dee2e6; font-size: 12px; color: #6c757d;">
                    <strong>Analysis Metadata:</strong><br>
                    Data Path: ${analysisResult.metadata.dataPath}<br>
                    Records Analyzed: ${analysisResult.metadata.recordCount}<br>
                    Confidence: ${(analysisResult.confidence * 100).toFixed(1)}%<br>
                    Data Quality: ${analysisResult.dataQuality}<br>
                    Timestamp: ${new Date(analysisResult.timestamp).toLocaleString()}
                </div>
            `;
            
            // Always preserve existing charts and timers, never use innerHTML = which destroys charts
            const resultsDiv = document.createElement('div');
            resultsDiv.innerHTML = html;
            
            // Clear content but preserve timer and any existing charts
            const children = Array.from(content.children);
            children.forEach(child => {
                // Preserve timer and any Plotly chart containers
                if (child.id === 'analysisTimer' || 
                    child.querySelector('div[id^="chart-"]') || 
                    (child.id && child.id.startsWith('chart-')) ||
                    child.querySelector('.plotly-graph-div')) {
                    // Keep this element
                } else {
                    child.remove();
                }
            });
            content.appendChild(resultsDiv);
            
            // Process chart requests FIRST (before MMSI link conversion which would break JSON)
            processChartRequests(resultsDiv);
            // Convert MMSI numbers to MarineTraffic links in the new results (after charts are processed)
            convertMMSIToLinks(resultsDiv);
            
            // Show follow-up section for database access mode and store analysis ID
            if (analysisResult.metadata && analysisResult.metadata.useDatabaseAccess && analysisResult.id) {
                currentAnalysisId = analysisResult.id;
                const followUpSection = document.getElementById('followUpSection');
                if (followUpSection) {
                    followUpSection.style.display = 'block';
                }
            } else {
                currentAnalysisId = null;
                const followUpSection = document.getElementById('followUpSection');
                if (followUpSection) {
                    followUpSection.style.display = 'none';
                }
            }
        }

        // Open analysis history modal
        async function openAnalysisHistoryModal() {
            const modal = document.getElementById('analysisHistoryModal');
            const content = document.getElementById('analysisHistoryModalContent');
            
            // Show modal immediately
            modal.style.display = 'block';
            content.innerHTML = '<div style="text-align: center; padding: 20px;"><div>🔄 Loading analysis history...</div></div>';
            
            try {
                const response = await fetch('/plugins/signalk-parquet/api/analyze/history?limit=20');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success && data.data && data.data.length > 0) {
                    let html = '<div>';
                    
                    data.data.forEach((analysis, index) => {
                        const date = new Date(analysis.timestamp);
                        const isRecent = (Date.now() - date.getTime()) < 24 * 60 * 60 * 1000; // Less than 24 hours
                        
                        html += `
                            <div style="background: ${isRecent ? '#f0f8ff' : 'white'}; border: 1px solid #ddd; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                                    <div>
                                        <h4 style="margin: 0 0 5px 0; color: #333; font-size: 1.1em;">${analysis.metadata.analysisType || 'Custom Analysis'}</h4>
                                        <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">
                                            <strong>Path:</strong> ${analysis.metadata.dataPath}
                                        </div>
                                        <div style="font-size: 0.85em; color: #888;">
                                            ${date.toLocaleString()} ${isRecent ? '(Recent)' : ''}
                                        </div>
                                    </div>
                                    <div style="display: flex; gap: 8px;">
                                        <button onclick="viewAnalysis('${analysis.id}')" style="background: #2196F3; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em;">
                                            👁️ View
                                        </button>
                                        <button onclick="deleteAnalysis('${analysis.id}')" style="background: #f44336; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em;">
                                            🗑️ Delete
                                        </button>
                                    </div>
                                </div>
                                <div style="font-size: 0.9em; color: #555; line-height: 1.4; max-height: 80px; overflow: hidden; position: relative;">
                                    ${analysis.analysis.substring(0, 300)}${analysis.analysis.length > 300 ? '...' : ''}
                                </div>
                                ${analysis.insights && analysis.insights.length > 0 ? `
                                    <div style="margin-top: 10px; font-size: 0.85em; color: #666;">
                                        <strong>Key Insights:</strong> ${analysis.insights.slice(0, 2).join(', ')}${analysis.insights.length > 2 ? '...' : ''}
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                    content.innerHTML = html;
                } else {
                    content.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <div style="font-size: 3em; margin-bottom: 20px;">📈</div>
                            <h3>No Analysis History Found</h3>
                            <p>Your Claude AI analyses will appear here once you start running them.</p>
                        </div>
                    `;
                }
                
            } catch (error) {
                content.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #d32f2f;">
                        <div style="font-size: 3em; margin-bottom: 20px;">⚠️</div>
                        <h3>Error Loading History</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        // Close analysis history modal
        function closeAnalysisHistoryModal() {
            document.getElementById('analysisHistoryModal').style.display = 'none';
        }

        // View individual analysis
        async function viewAnalysis(analysisId) {
            const modal = document.getElementById('analysisViewModal');
            const content = document.getElementById('analysisViewContent');
            const title = document.getElementById('analysisViewTitle');
            
            // Show modal
            modal.style.display = 'block';
            content.innerHTML = '<div style="text-align: center; padding: 20px;">🔄 Loading analysis...</div>';
            
            try {
                // Find the analysis in the current data (could also fetch individually)
                const historyResponse = await fetch('/plugins/signalk-parquet/api/analyze/history');
                const historyData = await historyResponse.json();
                
                if (historyData.success && historyData.data) {
                    const analysis = historyData.data.find(a => a.id === analysisId);
                    if (analysis) {
                        displayFullAnalysis(analysis);
                    } else {
                        content.innerHTML = '<div style="text-align: center; padding: 20px; color: #d32f2f;">Analysis not found.</div>';
                    }
                }
            } catch (error) {
                content.innerHTML = `<div style="text-align: center; padding: 20px; color: #d32f2f;">Error loading analysis: ${error.message}</div>`;
            }
        }

        // Display full analysis in modal
        function displayFullAnalysis(analysis) {
            const content = document.getElementById('analysisViewContent');
            const title = document.getElementById('analysisViewTitle');
            
            title.textContent = `🧠 ${analysis.metadata.analysisType || 'Analysis'} - ${new Date(analysis.timestamp).toLocaleDateString()}`;
            
            let html = `
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #2196F3;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">Analysis Metadata</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9em;">
                        <div><strong>Data Path:</strong> ${analysis.metadata.dataPath}</div>
                        <div><strong>Analysis Type:</strong> ${analysis.metadata.analysisType || 'Custom'}</div>
                        <div><strong>Date:</strong> ${new Date(analysis.timestamp).toLocaleString()}</div>
                        <div><strong>Record Count:</strong> ${analysis.metadata.recordCount || 'N/A'}</div>
                        <div><strong>Confidence:</strong> ${Math.round((analysis.confidence || 0) * 100)}%</div>
                        <div><strong>Data Quality:</strong> ${analysis.dataQuality || 'N/A'}</div>
                    </div>
                </div>

                <div style="margin-bottom: 20px;">
                    <h4 style="color: #333; border-bottom: 2px solid #2196F3; padding-bottom: 5px;">🧠 Main Analysis</h4>
                    <div style="background: white; padding: 20px; border-radius: 8px; border: 1px solid #ddd; line-height: 1.6; white-space: pre-wrap;">${analysis.analysis}</div>
                </div>
            `;
            
            if (analysis.insights && analysis.insights.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #333; border-bottom: 2px solid #4CAF50; padding-bottom: 5px;">💡 Key Insights</h4>
                        <ul style="background: white; padding: 20px; border-radius: 8px; border: 1px solid #ddd; line-height: 1.6;">
                `;
                analysis.insights.forEach(insight => {
                    html += `<li style="margin-bottom: 8px;">${insight}</li>`;
                });
                html += `</ul></div>`;
            }
            
            if (analysis.recommendations && analysis.recommendations.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #333; border-bottom: 2px solid #FF9800; padding-bottom: 5px;">🎯 Recommendations</h4>
                        <ul style="background: white; padding: 20px; border-radius: 8px; border: 1px solid #ddd; line-height: 1.6;">
                `;
                analysis.recommendations.forEach(rec => {
                    html += `<li style="margin-bottom: 8px;">${rec}</li>`;
                });
                html += `</ul></div>`;
            }
            
            if (analysis.anomalies && analysis.anomalies.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #333; border-bottom: 2px solid #f44336; padding-bottom: 5px;">⚠️ Anomalies Detected</h4>
                        <div style="background: white; padding: 20px; border-radius: 8px; border: 1px solid #ddd;">
                `;
                analysis.anomalies.forEach(anomaly => {
                    html += `
                        <div style="margin-bottom: 15px; padding: 10px; background: #fff3e0; border-left: 4px solid #ff9800; border-radius: 4px;">
                            <div style="font-weight: bold; margin-bottom: 5px;">${new Date(anomaly.timestamp).toLocaleString()}</div>
                            <div style="margin-bottom: 5px;"><strong>Value:</strong> ${anomaly.value} (Expected: ${anomaly.expectedRange.min} - ${anomaly.expectedRange.max})</div>
                            <div style="margin-bottom: 5px;"><strong>Severity:</strong> ${anomaly.severity} (Confidence: ${Math.round(anomaly.confidence * 100)}%)</div>
                            <div>${anomaly.description}</div>
                        </div>
                    `;
                });
                html += `</div></div>`;
            }
            
            // Add copy button
            html += `
                <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd;">
                    <button onclick="deleteAnalysis('${analysis.id}', true)" style="background: #f44336; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer;">
                        🗑️ Delete Analysis
                    </button>
                </div>
            `;
            
            content.innerHTML = html;
            
            // Process chart requests FIRST (before MMSI link conversion which would break JSON)
            processChartRequests(content);
            // Convert MMSI numbers to MarineTraffic links in the modal content (after charts are processed)
            convertMMSIToLinks(content);
        }

        // Close analysis view modal
        function closeAnalysisViewModal() {
            document.getElementById('analysisViewModal').style.display = 'none';
        }

        // Delete analysis
        async function deleteAnalysis(analysisId, isFullView = false) {
            try {
                if (!confirm('Are you sure you want to delete this analysis? This action cannot be undone.')) {
                    return;
                }

                const response = await fetch(`/plugins/signalk-parquet/api/analyze/history/${analysisId}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                
                if (result.success) {
                    // Close modal if in full view
                    if (isFullView) {
                        closeAnalysisViewModal();
                    }
                    
                    // Refresh the history list
                    openAnalysisHistoryModal();
                } else {
                    alert(`Failed to delete analysis: ${result.error}`);
                }
            } catch (error) {
                console.error('Failed to delete analysis:', error);
                alert('Failed to delete analysis');
            }
        }


        // Analyze data from Data Paths tab
        async function analyzeDataPath(signalkPath, directory) {
            // Switch to AI Analysis tab
            showTab('aiAnalysis');

            // First select the path checkbox (before enabling database mode)
            const checkboxId = `path_${signalkPath.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                // Clear all other selections and select only this path
                const allCheckboxes = document.querySelectorAll('#analysisDataPathContainer input[type="checkbox"]');
                allCheckboxes.forEach(cb => cb.checked = false);
                checkbox.checked = true;
                updateSelectedPathCount();
            }

            // Enable database access mode for path-specific analysis
            const databaseCheckbox = document.getElementById('enableDatabaseAccess');
            if (databaseCheckbox && !databaseCheckbox.checked) {
                databaseCheckbox.checked = true;
                toggleAnalysisMode(); // Update UI to show database mode
            }

            // Set path-specific analysis prompt
            const promptField = document.getElementById('customPrompt');
            if (promptField) {
                promptField.value = `Analyze the data for path: ${signalkPath}

Please provide insights about:
1. Recent data patterns and trends
2. Any anomalies or unusual readings
3. Data quality and consistency
4. Key statistics and ranges
5. Notable changes over time

Focus specifically on the ${signalkPath} sensor data and provide actionable insights.`;
            }

            // Set recent time range for quick analysis
            const startDateField = document.getElementById('analysisStartDate');
            const endDateField = document.getElementById('analysisEndDate');
            if (startDateField && endDateField) {
                const now = new Date();
                const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                endDateField.value = now.toISOString().slice(0, 16);
                startDateField.value = yesterday.toISOString().slice(0, 16);
            }

            // Auto-trigger the analysis immediately
            runCustomAnalysis();
        }

        // Toggle between analysis modes
        function toggleAnalysisMode() {
            const checkbox = document.getElementById('enableDatabaseAccess');
            const legacyDesc = document.getElementById('legacyModeDesc');
            const databaseDesc = document.getElementById('databaseModeDesc');
            const selectionSection = document.getElementById('selectionOptionsSection');
            const selectionSubtext = document.getElementById('selectionToggleSubtext');
            
            if (checkbox.checked) {
                // Show database mode description
                legacyDesc.style.display = 'none';
                databaseDesc.style.display = 'block';
                
                // Grey out selection options for database mode
                selectionSection.style.opacity = '0.5';
                selectionSection.style.pointerEvents = 'none';
                selectionSubtext.textContent = '(Not needed for database access mode)';
                
                console.log('Switched to Direct Database Access mode');
            } else {
                // Show legacy mode description
                legacyDesc.style.display = 'block';
                databaseDesc.style.display = 'none';
                
                // Enable selection options for legacy mode
                selectionSection.style.opacity = '1';
                selectionSection.style.pointerEvents = 'auto';
                selectionSubtext.textContent = '(Advanced options for legacy mode)';
                
                console.log('Switched to Legacy Data Sampling mode');
            }
        }

        // Toggle selection options visibility
        function toggleSelectionOptions() {
            const container = document.getElementById('selectionOptionsContainer');
            const icon = document.getElementById('selectionToggleIcon');
            
            if (container.style.display === 'none' || !container.style.display) {
                // Show options
                container.style.display = 'block';
                icon.textContent = '▼';
                console.log('Selection options expanded');
            } else {
                // Hide options
                container.style.display = 'none';
                icon.textContent = '▶';
                console.log('Selection options collapsed');
            }
        }

        // Initialize AI Analysis tab when it becomes active
        function initializeAIAnalysisTab() {
            // Load vessel context
            loadVesselContext();
            
            // Load available data paths for both cards and dropdown
            loadAvailableDataPaths();
            
            // Set default date range (last 24 hours)
            const now = new Date();
            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            
            document.getElementById('analysisEndDate').value = now.toISOString().slice(0, 16);
            document.getElementById('analysisStartDate').value = yesterday.toISOString().slice(0, 16);
            
            // Initialize UI state based on default checkbox state
            toggleAnalysisMode();
        }
        
        // Load available data paths for analysis
        async function loadAvailableDataPaths() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/paths');
                const data = await response.json();
                
                if (data.success && data.paths) {
                    // Populate custom analysis checkboxes
                    populateAnalysisPathCheckboxes(data.paths);
                } else {
                    console.error('Failed to load data paths:', data.error);
                }
            } catch (error) {
                console.error('Error loading available data paths:', error);
            }
        }

        // Load data paths for analysis dropdown
        async function loadDataPathsForAnalysis() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/paths');
                const data = await response.json();
                
                if (data.success && data.paths) {
                    const container = document.getElementById('analysisDataPathContainer');
                    
                    if (data.paths.length === 0) {
                        container.innerHTML = '<div style="color: #666; font-style: italic;">No data paths available</div>';
                        return;
                    }
                    
                    container.innerHTML = ''; // Clear loading message
                    
                    data.paths.forEach((pathInfo, index) => {
                        const checkboxDiv = document.createElement('div');
                        checkboxDiv.className = 'path-checkbox-row';
                        
                        const pathInfoDiv = document.createElement('div');
                        pathInfoDiv.className = 'path-info';
                        
                        const iconSpan = document.createElement('span');
                        iconSpan.className = 'path-icon';
                        iconSpan.textContent = getPathIcon(pathInfo.path);
                        
                        const label = document.createElement('label');
                        label.htmlFor = `path_${pathInfo.path.replace(/[^a-zA-Z0-9]/g, '_')}`;
                        label.textContent = `${pathInfo.path} (${pathInfo.fileCount} files)`;
                        label.style.cssText = 'cursor: pointer; margin: 0;';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = pathInfo.path;
                        checkbox.id = `path_${pathInfo.path.replace(/[^a-zA-Z0-9]/g, '_')}`;
                        checkbox.onchange = handlePathCheckboxChange;
                        checkbox.className = 'path-checkbox';
                        
                        pathInfoDiv.appendChild(iconSpan);
                        pathInfoDiv.appendChild(label);
                        checkboxDiv.appendChild(pathInfoDiv);
                        checkboxDiv.appendChild(checkbox);
                        container.appendChild(checkboxDiv);
                    });
                    
                    updateSelectedPathCount();
                }
            } catch (error) {
                console.error('Error loading data paths for analysis:', error);
                const container = document.getElementById('analysisDataPathContainer');
                container.innerHTML = '<div style="color: #d32f2f;">Error loading paths</div>';
            }
        }

        // Ask follow-up question to continue conversation
        async function askFollowUpQuestion() {
            const questionTextarea = document.getElementById('followUpQuestion');
            const askButton = document.getElementById('askFollowUpBtn');
            const question = questionTextarea.value.trim();
            
            if (!question) {
                alert('Please enter a question.');
                return;
            }
            
            if (!currentAnalysisId) {
                alert('No active conversation. Please run a database analysis first.');
                return;
            }
            
            // Disable UI during request
            askButton.disabled = true;
            askButton.textContent = '💬 Asking...';
            questionTextarea.disabled = true;
            
            // Start timer for follow-up
            const startTime = new Date();
            const content = document.getElementById('analysisContent');
            const followUpTimerElement = document.createElement('div');
            followUpTimerElement.id = 'followUpTimer';
            followUpTimerElement.style.cssText = 'background: #fff3e0; border: 1px solid #ff9800; border-radius: 5px; padding: 10px; margin-bottom: 15px; text-align: center; font-family: monospace;';
            content.appendChild(followUpTimerElement);
            
            // Update timer every 100ms
            const timerInterval = setInterval(() => {
                const elapsed = (new Date() - startTime) / 1000;
                followUpTimerElement.innerHTML = `
                    <strong>⏱️ Follow-up Timer</strong><br>
                    Question sent: ${startTime.toLocaleTimeString()}<br>
                    Elapsed: ${elapsed.toFixed(1)}s
                `;
            }, 100);
            
            try {
                const response = await fetch(`${getPluginPath()}/api/analyze/followup`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        conversationId: currentAnalysisId,
                        question: question
                    })
                });
                
                const result = await response.json();
                
                // Stop timer and show final time
                clearInterval(timerInterval);
                const endTime = new Date();
                const totalTime = (endTime - startTime) / 1000;
                
                // Get token usage if available
                let tokenInfo = '';
                if (result.usage) {
                    const usage = result.usage;
                    tokenInfo = `<br><strong>Tokens: ${usage.input_tokens || 0} in + ${usage.output_tokens || 0} out = ${(usage.input_tokens || 0) + (usage.output_tokens || 0)} total</strong>`;
                }
                
                followUpTimerElement.innerHTML = `
                    <strong>⏱️ Follow-up Complete</strong><br>
                    Started: ${startTime.toLocaleTimeString()}<br>
                    Completed: ${endTime.toLocaleTimeString()}<br>
                    <strong>Total Time: ${totalTime.toFixed(1)}s</strong>${tokenInfo}
                `;
                followUpTimerElement.style.background = result.success ? '#e8f5e8' : '#ffeaea';
                followUpTimerElement.style.borderColor = result.success ? '#4caf50' : '#f44336';
                
                if (result.success) {
                    // Display the follow-up response in the analysis content area
                    const followUpHtml = `
                        <div style="border-left: 4px solid #1976d2; padding-left: 15px; margin-bottom: 20px; background: #f8fdff;">
                            <h4 style="color: #1976d2; margin: 0 0 10px 0;">💬 Follow-up Question</h4>
                            <div style="font-style: italic; color: #666; margin-bottom: 10px;">${question}</div>
                            <div style="white-space: pre-wrap; line-height: 1.6;">${result.data.analysis}</div>
                        </div>
                    `;
                    
                    // Append to existing content
                    content.innerHTML += followUpHtml;
                    
                    // Create a temporary container with just the new follow-up content
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = followUpHtml;
                    
                    // Process only the new follow-up content
                    // Process chart requests FIRST (before MMSI link conversion which would break JSON)
                    processChartRequests(tempDiv);
                    convertMMSIToLinks(tempDiv);
                    
                    // If tempDiv was modified, replace the last follow-up section
                    if (tempDiv.innerHTML !== followUpHtml) {
                        const followUpSections = content.querySelectorAll('div[style*="border-left: 4px solid #1976d2"]');
                        if (followUpSections.length > 0) {
                            followUpSections[followUpSections.length - 1].outerHTML = tempDiv.innerHTML;
                        }
                    }
                    
                    // Clear the question input
                    questionTextarea.value = '';
                    
                    // Scroll to show the new response
                    content.scrollIntoView({ behavior: 'smooth', block: 'end' });
                } else {
                    const errorElement = document.createElement('div');
                    errorElement.style.color = 'red';
                    errorElement.innerHTML = `❌ Follow-up failed: ${result.error}`;
                    content.appendChild(errorElement);
                }
            } catch (error) {
                // Stop timer on error
                clearInterval(timerInterval);
                const endTime = new Date();
                const totalTime = (endTime - startTime) / 1000;
                
                // Try to get token usage even on error (in case it's a partial failure)
                let tokenInfo = '';
                try {
                    if (error.response && error.response.usage) {
                        const usage = error.response.usage;
                        tokenInfo = `<br><strong>Tokens: ${usage.input_tokens || 0} in + ${usage.output_tokens || 0} out = ${(usage.input_tokens || 0) + (usage.output_tokens || 0)} total</strong>`;
                    }
                } catch (e) {
                    // Ignore token parsing errors
                }
                
                followUpTimerElement.innerHTML = `
                    <strong>⏱️ Follow-up Failed</strong><br>
                    Started: ${startTime.toLocaleTimeString()}<br>
                    Failed: ${endTime.toLocaleTimeString()}<br>
                    <strong>Total Time: ${totalTime.toFixed(1)}s</strong>${tokenInfo}
                `;
                followUpTimerElement.style.background = '#ffeaea';
                followUpTimerElement.style.borderColor = '#f44336';
                
                console.error('Follow-up question error:', error);
                alert('Failed to ask follow-up question. Please try again.');
            } finally {
                // Re-enable UI
                askButton.disabled = false;
                askButton.textContent = '💬 Ask';
                questionTextarea.disabled = false;
                questionTextarea.focus();
            }
        }

    </script>

    <!-- Analysis History Modal -->
    <div id="analysisHistoryModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1001; overflow-y: auto;">
        <div style="max-width: 900px; margin: 30px auto; background: white; border-radius: 10px; max-height: 90vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 20px; border-bottom: 1px solid #ddd; position: sticky; top: 0; background: white; border-radius: 10px 10px 0 0;">
                <h3 style="margin: 0;">📈 Analysis History</h3>
                <button onclick="closeAnalysisHistoryModal()" style="background: #f44336; color: white; padding: 5px 10px; border-radius: 3px; font-size: 16px;">&times;</button>
            </div>
            <div id="analysisHistoryModalContent" style="padding: 20px;">
                <!-- Analysis history content will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Individual Analysis View Modal -->
    <div id="analysisViewModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1002; overflow-y: auto;">
        <div style="max-width: 1000px; margin: 20px auto; background: white; border-radius: 10px; max-height: 95vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 20px; border-bottom: 1px solid #ddd; position: sticky; top: 0; background: white; border-radius: 10px 10px 0 0;">
                <h3 style="margin: 0;" id="analysisViewTitle">🧠 Analysis Details</h3>
                <button onclick="closeAnalysisViewModal()" style="background: #f44336; color: white; padding: 5px 10px; border-radius: 3px; font-size: 16px;">&times;</button>
            </div>
            <div id="analysisViewContent" style="padding: 20px;">
                <!-- Individual analysis content will be loaded here -->
            </div>
        </div>
    </div>

</body>
</html>
