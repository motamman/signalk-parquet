<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SignalK Parquet Data Interface</title>
    <link rel="icon" type="image/png" href="parquet.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #2BB5D6 0%, #013542 100%);
            color: white;
            padding: 20px 0;
            margin-bottom: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        button {
            background: #667eea;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #5a6fd8;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .results {
            margin-top: 20px;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 600px;
        }

        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
            word-wrap: break-word;
        }
        
        th:nth-child(1), td:nth-child(1) { min-width: 180px; } /* Path */
        th:nth-child(2), td:nth-child(2) { width: 60px; } /* Enabled */
        th:nth-child(3), td:nth-child(3) { min-width: 100px; } /* Regimen */
        th:nth-child(4), td:nth-child(4) { min-width: 120px; } /* Source */
        th:nth-child(5), td:nth-child(5) { width: 90px; } /* Context */
        th:nth-child(6), td:nth-child(6) { min-width: 120px; } /* Exclude MMSI */
        th:nth-child(7), td:nth-child(7) { width: 140px; } /* Actions */

        th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        tr:hover {
            background-color: #f8f9fa;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .path-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .path-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }

        .path-item h4 {
            margin-bottom: 5px;
            color: #495057;
        }

        .path-item p {
            font-size: 0.9rem;
            color: #666;
        }

        .path-item button {
            margin-top: 10px;
            padding: 5px 10px;
            font-size: 12px;
        }


        .query-examples {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .query-examples h4 {
            margin-bottom: 10px;
            color: #495057;
        }

        .query-examples ul {
            list-style: none;
            padding: 0;
        }

        .query-examples li {
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .query-examples li:hover {
            background: #e9ecef;
        }

        .query-examples code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
        }

        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            margin: -20px -20px 15px -20px;
            background: #f8f9fa;
            border-radius: 10px 10px 0 0;
            transition: background-color 0.3s;
        }

        .collapsible-header:hover {
            background: #e9ecef;
        }

        .collapsible-header h2 {
            margin: 0;
        }

        .collapse-icon {
            font-size: 1.2rem;
            transition: transform 0.3s;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }

        .collapsible-content.expanded {
            max-height: 2000px;
        }

        /* Tab Navigation Styles */
        .tab-navigation {
            display: flex;
            background: white;
            border-radius: 10px 10px 0 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 0;
            overflow-x: auto;
        }

        .tab-button {
            background: #f8f9fa;
            border: none;
            padding: 15px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            border-radius: 0;
            transition: all 0.3s;
            white-space: nowrap;
            border-bottom: 3px solid transparent;
            margin: 0;
        }

        .tab-button:first-child {
            border-radius: 10px 0 0 0;
        }

        .tab-button:last-child {
            border-radius: 0 10px 0 0;
        }

        .tab-button:hover {
            background: #e9ecef;
            color: #333;
        }

        .tab-button.active {
            background: white;
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            background: white;
            border-radius: 0 0 10px 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .tab-panel .section {
            margin-bottom: 0;
            box-shadow: none;
            border-radius: 0 0 10px 10px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .stats {
                flex-direction: column;
                gap: 10px;
            }

            .tab-navigation {
                flex-wrap: wrap;
            }

            .tab-button {
                flex: 1;
                min-width: 120px;
                padding: 12px 15px;
                font-size: 13px;
            }

            .tab-button:first-child,
            .tab-button:last-child {
                border-radius: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <img src="parquet.png" alt="Parquet" style="height: 80px; vertical-align: middle; margin-right: 10px; border-radius: 5px;"> 
                SignalK Parquet Data Store</h1>
            <p>Export, query, and explore your SignalK data archived as Parquet files</p>
        </div>

        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-button active" onclick="showTab('pathConfig')">‚öôÔ∏è Path Configuration</button>
            <button class="tab-button" onclick="showTab('commandManager')">üéÆ Command Manager</button>
            <button class="tab-button" onclick="showTab('liveConnections')" style="display: none;">üî¥ Live Connections</button>
            <button class="tab-button" onclick="showTab('dataPaths')">üìÅ Available Data Paths</button>
            <button class="tab-button" onclick="showTab('customQuery')">üîç Custom Query</button>
            <button class="tab-button" onclick="showTab('aiAnalysis')">üß† AI Analysis</button>
            <button class="tab-button" onclick="showTab('s3Config')">‚òÅÔ∏è Cloud Status</button>
        </div>

        <!-- Tab Content Panels -->
        <div class="tab-content">
            <!-- Path Configuration Tab -->
            <div id="pathConfig" class="tab-panel active">
                <div class="section">
                    <h2>‚öôÔ∏è Path Configuration</h2>
                <p>Manage which SignalK paths to collect data from:</p>
                <button onclick="loadPathConfigurations()">üîÑ Refresh Paths</button>
                <button onclick="showAddPathForm()">‚ûï Add New Path</button>
                <button id="toggleCommandsBtn" onclick="toggleCommandPaths()">üëÅÔ∏è Show Commands</button>
                
                <!-- Add Path Form (hidden by default) -->
                <div id="addPathForm" style="display: none; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 5px; min-height: 400px; overflow: visible;">
                    <h4>Add New Path Configuration</h4>
                    <div class="form-group">
                        <label for="pathSignalK">SignalK Path:</label>
                        <input type="text" id="pathSignalK" placeholder="e.g., navigation.position">
                    </div>
                    <div class="form-group">
                        <label for="pathEnabled" style="display: inline !important; margin-bottom: 0 !important;">Always Enabled:</label>
                        <input type="checkbox" id="pathEnabled" style="display: inline !important; width: auto !important; margin-left: 10px;">
                    </div>
                    <div class="form-group">
                        <label for="pathRegimen">Regimen Control:</label>
                        <input type="text" id="pathRegimen" placeholder="e.g., captureWeather, capturePassage">
                    </div>
                    <div class="form-group">
                        <label for="pathContext">Context:</label>
                        <input type="text" id="pathContext" placeholder="e.g., vessels.self or vessels.*" value="vessels.self">
                    </div>
                    <div class="form-group">
                        <label for="pathSource">Source Filter (optional):</label>
                        <input type="text" id="pathSource" placeholder="e.g., mqtt-weatherflow-udp">
                        <small style="color: #666; display: block; margin-top: 5px;">
                            Filter by specific data source. Leave empty to accept all sources.
                        </small>
                    </div>
                    <div class="form-group">
                        <label for="pathExcludeMMSI">Exclude MMSI (for vessels.* context):</label>
                        <input type="text" id="pathExcludeMMSI" placeholder="e.g., 123456789, 987654321 (comma-separated)">
                        <small style="color: #666; display: block; margin-top: 5px;">
                            Only applicable when context is "vessels.*". Leave empty to include all vessels.
                        </small>
                    </div>
                    <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd; min-height: 60px; display: flex; gap: 10px; align-items: center;">
                        <button onclick="addPathConfiguration()">‚úÖ Add Path</button>
                        <button class="btn-secondary" onclick="hideAddPathForm()">‚ùå Cancel</button>
                    </div>
                </div>
                
                    <div id="pathConfigContainer">
                        <div class="loading">Loading path configurations...</div>
                    </div>
                </div>
            </div>

            <!-- Command Manager Tab -->
            <div id="commandManager" class="tab-panel">
                <div class="section">
                    <h2>üéÆ Command Manager</h2>
                    <p>Register and manage SignalK commands for remote control:</p>
                    <button onclick="loadCommands()">üîÑ Refresh Commands</button>
                    <button onclick="showAddCommandForm()">‚ûï Add New Command</button>
                    
                    <!-- Add Command Form (hidden by default) -->
                    <div id="addCommandForm" style="display: none; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 5px;">
                        <h4>Register New Command</h4>
                        <div class="form-group">
                            <label for="commandName">Command Name:</label>
                            <input type="text" id="commandName" placeholder="e.g., captureWeather, startLogging">
                        </div>
                        <div class="form-group">
                            <label for="commandDescription">Description (optional):</label>
                            <input type="text" id="commandDescription" placeholder="e.g., Start weather data capture">
                        </div>
                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd;">
                            <button onclick="registerCommand()">‚úÖ Register Command</button>
                            <button class="btn-secondary" onclick="hideAddCommandForm()">‚ùå Cancel</button>
                        </div>
                    </div>
                    
                    <div id="commandContainer">
                        <div class="loading">Loading commands...</div>
                    </div>
                    
                    <!-- Command History -->
                    <div style="margin-top: 30px;">
                        <h3>üìã Command History</h3>
                        <button onclick="loadCommandHistory()">üîÑ Refresh History</button>
                        <div id="commandHistoryContainer" style="margin-top: 15px;">
                            <div class="loading">Loading command history...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Live Connections Tab -->
            <div id="liveConnections" class="tab-panel">
                <div class="section" style="display: none;">
                    <h2>üî¥ Live Connections - DISABLED</h2>
                    <p>Streaming functionality has been disabled.</p>
                    
                    <div style="margin-bottom: 20px;">
                        <button onclick="loadStreams()">üîÑ Refresh Streams</button>
                        <button onclick="showAddStreamForm()">‚ûï Create New Stream</button>
                    </div>

                    <!-- Add Stream Form (hidden by default) -->
                    <div id="addStreamForm" style="display: none; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 5px;">
                        <h4>Create New Historical Stream</h4>
                        
                        <div class="form-group">
                            <label for="streamName">Stream Name:</label>
                            <input type="text" id="streamName" placeholder="e.g., Navigation History">
                        </div>
                        
                        <div class="form-group">
                            <label for="streamPath">SignalK Path:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="streamPath" style="flex: 1;">
                                    <option value="">Loading available paths...</option>
                                </select>
                                <button type="button" onclick="refreshSignalKPaths()" style="padding: 8px; background: #007bff; color: white; border: none; border-radius: 3px;" title="Refresh path list">üîÑ</button>
                            </div>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Available paths from historical data. Click refresh if you don't see your path.
                            </small>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamTimeRange">Time Range:</label>
                            <select id="streamTimeRange">
                                <option value="1h">Last 1 Hour</option>
                                <option value="6h">Last 6 Hours</option>
                                <option value="24h">Last 24 Hours</option>
                                <option value="7d">Last 7 Days</option>
                                <option value="30d">Last 30 Days</option>
                                <option value="custom">Custom Range</option>
                            </select>
                        </div>
                        
                        <div class="form-group" id="customTimeRange" style="display: none;">
                            <label>Custom Time Range:</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <input type="datetime-local" id="streamStartTime" placeholder="Start time">
                                <input type="datetime-local" id="streamEndTime" placeholder="End time">
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamResolution">Data Resolution:</label>
                            <select id="streamResolution">
                                <option value="1000">1 second</option>
                                <option value="5000">5 seconds</option>
                                <option value="15000">15 seconds</option>
                                <option value="30000" selected>30 seconds</option>
                                <option value="60000">1 minute</option>
                                <option value="300000">5 minutes</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamRate">Streaming Rate:</label>
                            <select id="streamRate">
                                <option value="100">Fast (100ms intervals)</option>
                                <option value="500" selected>Normal (500ms intervals)</option>
                                <option value="1000">Slow (1 second intervals)</option>
                                <option value="5000">Very Slow (5 second intervals)</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamAggregateMethod">Statistical Function:</label>
                            <select id="streamAggregateMethod">
                                <option value="average" selected>Average - arithmetic mean of values</option>
                                <option value="min">Minimum - lowest value in time window</option>
                                <option value="max">Maximum - highest value in time window</option>
                                <option value="first">First - earliest value in time window</option>
                                <option value="last">Last - most recent value in time window</option>
                                <option value="mid">Median - middle value when sorted</option>
                                <option value="middle_index">Middle Index - middle value by position</option>
                            </select>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Statistical function applied to data within each time window
                            </small>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamWindowSize">Rolling Window Size:</label>
                            <select id="streamWindowSize">
                                <option value="5">5 data points</option>
                                <option value="10" selected>10 data points</option>
                                <option value="20">20 data points</option>
                                <option value="50">50 data points</option>
                                <option value="100">100 data points</option>
                            </select>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Number of recent values used for real-time statistical calculations
                            </small>
                        </div>
                        
                        <div class="form-group">
                            <label for="streamAutoStart">Auto-start stream:</label>
                            <input type="checkbox" id="streamAutoStart" checked>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Start streaming immediately after creation
                            </small>
                        </div>
                        
                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd;">
                            <button onclick="createStream()">‚úÖ Create Stream</button>
                            <button class="btn-secondary" onclick="hideAddStreamForm()">‚ùå Cancel</button>
                        </div>
                    </div>

                    <!-- Active Streams Display -->
                    <div id="streamsContainer">
                        <div class="loading">Loading streams...</div>
                    </div>
                    
                    <!-- Stream Statistics -->
                    <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                        <h3>üìä Stream Statistics</h3>
                        <div id="streamStats" style="margin-top: 15px;">
                            <div class="loading">Loading statistics...</div>
                        </div>
                    </div>

                    <!-- Live Data Display -->
                    <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                        <h3>üì° Live Data Stream</h3>
                        <p style="margin-bottom: 15px;">Real-time time-bucketed statistical streaming data (newest first, max 100 entries):</p>
                        
                        <!-- Data Interpretation Guide -->
                        <div style="background: #f0f8ff; padding: 15px; border-radius: 5px; margin-bottom: 15px; font-size: 13px;">
                            <strong>üìä How to Read This Data:</strong><br/>
                            ‚Ä¢ <strong>üìä INITIAL</strong>: Full time window data (first load with many buckets)<br/>
                            ‚Ä¢ <strong>üìà INCREMENTAL</strong>: New data points since last update (sliding window - fewer buckets)<br/>
                            ‚Ä¢ <strong>Statistical Method</strong>: MAX, AVG, MIN, FIRST, LAST, MID applied to each time bucket<br/>
                            ‚Ä¢ <strong>Buckets</strong>: Number of time intervals processed (e.g., 30-second time buckets)<br/>
                            ‚Ä¢ <strong>Value</strong>: Result of statistical calculation for that time bucket<br/>
                            ‚Ä¢ <strong>EMA/SMA</strong>: Moving averages (10-period) calculated for numeric values - EMA responds faster to changes<br/>
                            ‚Ä¢ <strong>Time</strong>: Timestamp of the time bucket (not delivery time)
                        </div>
                        
                        <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px;">
                            <table id="liveDataTable" style="width: 100%; border-collapse: collapse; font-size: 12px;">
                                <thead style="position: sticky; top: 0; background: #f8f9fa; z-index: 1;">
                                    <tr>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Bucket Time</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Stream Type & Statistical Method</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Path</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">Statistical Value</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">EMA (10)</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #ddd; text-align: left;">SMA (10)</th>
                                    </tr>
                                </thead>
                                <tbody id="liveDataBody">
                                    <tr>
                                        <td colspan="6" style="padding: 20px; text-align: center; color: #666;">
                                            No data streaming yet. Start a stream to see live data.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div style="margin-top: 10px; font-size: 11px; color: #666;">
                            <span id="liveDataCount">0</span> time-bucketed entries ‚Ä¢ 
                            <button onclick="clearLiveData()" style="font-size: 11px; padding: 2px 8px;">üóëÔ∏è Clear</button>
                            <button onclick="toggleLiveDataPause()" id="pauseDataBtn" style="font-size: 11px; padding: 2px 8px; margin-left: 5px;">‚è∏Ô∏è Pause</button>
                            <button onclick="showDataSummary()" style="font-size: 11px; padding: 2px 8px; margin-left: 5px;">üìä Summary</button>
                        </div>
                        
                        <!-- Data Summary Panel -->
                        <div id="dataSummaryPanel" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                            <h4>üìä Data Summary & Trends</h4>
                            <div id="dataSummaryContent"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- AI Analysis Tab -->
            <div id="aiAnalysis" class="tab-panel">
                <div class="section">
                    <h2>üß† AI Analysis with Claude</h2>
                    <p>Analyze your maritime data using Claude AI for insights, patterns, and recommendations.</p>
                    
                    <!-- Connection Test -->
                    <div style="margin-bottom: 20px;">
                        <button onclick="testClaudeConnection()" id="testConnectionBtn">üîó Test Claude Connection</button>
                        <div id="claudeConnectionResult" style="margin-top: 10px;"></div>
                    </div>

                    <!-- Vessel Context Section -->
                    <div style="margin-bottom: 30px; border: 2px solid #e3f2fd; border-radius: 8px; background: #fafbfc;">
                        <div onclick="toggleVesselContext()" style="padding: 15px 20px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; user-select: none;">
                            <div>
                                <h3 style="margin: 0;">‚öì Vessel Context Document</h3>
                                <p style="margin: 5px 0 0 0; color: #555; font-size: 0.9em;">Click to expand - context automatically included with every AI analysis</p>
                            </div>
                            <span id="vesselContextToggleIcon" style="font-size: 1.2em; color: #667eea;">‚ñ∂</span>
                        </div>
                        <div id="vesselContextContent" style="display: none; padding: 0 20px 20px 20px; border-top: 1px solid #e3f2fd;">
                        
                        <!-- Auto-extracted vessel info -->
                        <div style="margin-bottom: 20px;">
                            <h4 style="margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;">
                                <span>üìä Auto-Extracted Vessel Information</span>
                                <button onclick="refreshVesselInfo()" style="font-size: 0.9em; padding: 6px 12px;">üîÑ Refresh from SignalK</button>
                            </h4>
                            <div id="autoVesselInfo" style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #ddd;">
                                <div style="color: #666; font-style: italic;">Loading vessel information...</div>
                            </div>
                        </div>

                        <!-- Custom context -->
                        <div style="margin-bottom: 20px;">
                            <h4 style="margin-bottom: 10px;">‚úèÔ∏è Custom Context & Notes</h4>
                            <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Add any additional context about your vessel, operations, or specific information you want Claude to consider during analysis:</p>
                            <textarea id="customVesselContext" 
                                placeholder="e.g., 'This is a racing sailboat primarily used for coastal sailing. The vessel has recently had engine maintenance. We're particularly interested in wind performance analysis...'"
                                style="width: 100%; min-height: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 5px; resize: vertical; font-family: inherit;"></textarea>
                        </div>

                        <!-- Context preview and actions -->
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <button onclick="saveVesselContext()" style="background: #4CAF50; padding: 8px 16px;">üíæ Save Context</button>
                            <button onclick="previewClaudeContext()" style="background: #2196F3; padding: 8px 16px;">üëÅÔ∏è Preview Claude Context</button>
                            <div id="vesselContextStatus" style="margin-left: 10px; font-size: 0.9em;"></div>
                        </div>

                        <!-- Context preview modal -->
                        <div id="contextPreviewModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">
                            <div style="max-width: 800px; margin: 50px auto; background: white; border-radius: 10px; padding: 20px; max-height: 80vh; overflow-y: auto;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h3>üëÅÔ∏è Claude Context Preview</h3>
                                    <button onclick="closeContextPreview()" style="background: #f44336; color: white; padding: 5px 10px; border-radius: 3px;">&times;</button>
                                </div>
                                <p style="color: #666; margin-bottom: 15px;">This is the context that will be sent to Claude with every analysis:</p>
                                <pre id="contextPreviewContent" style="background: #f8f9fa; padding: 15px; border-radius: 5px; border: 1px solid #ddd; white-space: pre-wrap; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 0.9em; line-height: 1.4; max-height: 400px; overflow-y: auto;"></pre>
                                <div style="margin-top: 15px; padding: 10px; background: #e8f5e8; border-radius: 5px; border-left: 4px solid #4CAF50;">
                                    <small><strong>üí° Tip:</strong> A good vessel context helps Claude provide more accurate and relevant insights for your specific vessel and operations.</small>
                                </div>
                            </div>
                        </div>

                        </div>
                    </div>
                    
                    <!-- Custom Analysis -->
                    <div style="margin-bottom: 30px;">
                        <h3>üéØ Custom Analysis</h3>
                        <div style="margin-top: 15px;">
                            <!-- Analysis Mode Toggle with Model Selector -->
                            <div style="margin-bottom: 20px; padding: 15px; border: 2px solid #e3f2fd; border-radius: 8px; background: #f8f9ff;">
                                <div style="margin-bottom: 10px;">
                                    <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; font-weight: bold;">
                                        <span>üöÄ Direct Database Access</span>
                                        <input type="checkbox" id="enableDatabaseAccess" checked onchange="toggleAnalysisMode()" style="transform: scale(1.2);">
                                    </label>
                                </div>
                                <div style="font-size: 0.9em; color: #555;">
                                    <div id="legacyModeDesc" style="color: #666; display: none;">
                                        <strong>Legacy:</strong> Pre-load data samples for analysis (faster, limited scope)
                                    </div>
                                    <div id="databaseModeDesc" style="color: #1976d2;">
                                        <strong>Enhanced:</strong> Claude explores your database interactively (more powerful, complete historical access)
                                    </div>
                                </div>
                                
                                <!-- Claude Model Selection - moved here -->
                                <div style="margin-top: 15px;">
                                    <label for="claudeModelMain">Claude Model:</label>
                                    <select id="claudeModelMain" style="width: 100%; padding: 8px; margin-top: 5px;">
                                        <option value="claude-sonnet-4-20250514" selected>Claude Sonnet 4 - Latest Sonnet model (recommended)</option>
                                        <option value="claude-opus-4-1-20250805">Claude Opus 4.1 - Most powerful model (premium)</option>
                                        <option value="claude-opus-4-20250514">Claude Opus 4 - High performance model (premium)</option>
                                    </select>
                                    <p style="font-size: 0.9em; color: #666; margin: 5px 0 0 0;">Choose the Claude model for analysis. Sonnet provides the most detailed insights.</p>
                                </div>
                            </div>

                            <!-- Collapsible Selection Options -->
                            <div id="selectionOptionsSection" style="margin-bottom: 20px;">
                                <div onclick="toggleSelectionOptions()" style="cursor: pointer; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; user-select: none;">
                                    <span id="selectionToggleIcon" style="margin-right: 8px;">‚ñ∂</span>
                                    <strong>Selection Options</strong>
                                    <span id="selectionToggleSubtext" style="font-size: 0.9em; color: #666; margin-left: 10px;">(Advanced options for legacy mode)</span>
                                </div>
                                <div id="selectionOptionsContainer" style="display: none; border: 1px solid #dee2e6; border-top: none; border-radius: 0 0 5px 5px; padding: 15px; background: #f9f9f9;">
                                    <!-- Data Path Selection -->
                                    <div style="margin-bottom: 15px;">
                                        <label>Data Paths (select one or more):</label>
                                        <div id="analysisDataPathContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-top: 5px; background: white;">
                                            <div style="color: #666; font-style: italic;">Loading available paths...</div>
                                        </div>
                                        <style>
                                            .path-checkbox-row {
                                                display: flex;
                                                align-items: center;
                                                padding: 8px 8px 8px 5px;
                                                margin: 2px 0;
                                                border-radius: 4px;
                                            }
                                            .path-checkbox-row:nth-child(odd) {
                                                background-color: #f8f9fa;
                                            }
                                            .path-checkbox-row:nth-child(even) {
                                                background-color: white;
                                            }
                                            .path-checkbox-row:hover {
                                                background-color: #e3f2fd;
                                            }
                                            .path-info {
                                                display: flex;
                                                align-items: center;
                                                flex-grow: 1;
                                            }
                                            .path-icon {
                                                margin-right: 8px;
                                                font-size: 16px;
                                            }
                                            .path-checkbox {
                                                margin-left: auto;
                                                width: 16px;
                                                height: 16px;
                                                flex-shrink: 0;
                                            }
                                        </style>
                                        <div style="margin-top: 5px; font-size: 0.9em; color: #666; display: flex; justify-content: space-between; align-items: center;">
                                            <span><span id="selectedPathCount">0</span> path(s) selected</span>
                                            <div>
                                                <button onclick="selectAllPaths()" style="font-size: 0.8em; padding: 2px 6px; margin-right: 5px;">Select All</button>
                                                <button onclick="clearAllPaths()" style="font-size: 0.8em; padding: 2px 6px;">Clear All</button>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Date Range Selection -->
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                        <div>
                                            <label for="analysisStartDate">Start Date:</label>
                                            <input type="datetime-local" id="analysisStartDate" style="width: 100%; padding: 8px; margin-top: 5px;">
                                        </div>
                                        <div>
                                            <label for="analysisEndDate">End Date:</label>
                                            <input type="datetime-local" id="analysisEndDate" style="width: 100%; padding: 8px; margin-top: 5px;">
                                        </div>
                                    </div>
                                    
                                    <!-- Aggregation Method -->
                                    <div style="margin-bottom: 15px;">
                                        <label for="aggregationMethod">Aggregation Method:</label>
                                        <select id="aggregationMethod" style="width: 100%; padding: 8px; margin-top: 5px;">
                                            <option value="average" selected>Average - Mean values over time buckets</option>
                                            <option value="min">Min - Minimum values over time buckets</option>
                                            <option value="max">Max - Maximum values over time buckets</option>
                                            <option value="first">First - First value in each time bucket</option>
                                            <option value="last">Last - Last value in each time bucket</option>
                                            <option value="mid">Median - Middle values over time buckets</option>
                                            <option value="multiple">Multiple - Get min, max, and average</option>
                                        </select>
                                    </div>
                                    
                                    <!-- Time Resolution -->
                                    <div style="margin-bottom: 15px;">
                                        <label for="resolution">Time Resolution:</label>
                                        <select id="resolution" style="width: 100%; padding: 8px; margin-top: 5px;">
                                            <option value="" selected>Auto - Automatically determine best resolution</option>
                                            <option value="1m">1 minute - Fine-grained data</option>
                                            <option value="5m">5 minutes - Detailed data</option>
                                            <option value="15m">15 minutes - Regular sampling</option>
                                            <option value="1h">1 hour - Hourly summaries</option>
                                            <option value="1d">1 day - Daily summaries</option>
                                        </select>
                                    </div>
                                    
                                </div>
                            </div>

                            <div style="margin-bottom: 15px;">
                                <label for="customPrompt">Custom Analysis Request (optional):</label>
                                <textarea id="customPrompt" placeholder="What specific insights are you looking for? Leave blank for general analysis..." style="width: 100%; padding: 8px; margin-top: 5px; min-height: 60px; resize: vertical;"></textarea>
                            </div>

                            <button onclick="runCustomAnalysis()" style="padding: 12px 25px; margin-top: 15px;">üöÄ Run Custom Analysis</button>
                        </div>
                    </div>
                    
                    <!-- Analysis Results -->
                    <div id="analysisResults" style="display: none;">
                        <h3>üìä Analysis Results</h3>
                        <div id="analysisContent" style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 15px;">
                            <!-- Results will appear here -->
                        </div>
                        
                        <!-- Follow-up Questions -->
                        <div id="followUpSection" style="display: none; margin-top: 20px; padding: 15px; border: 2px solid #e8f4f8; border-radius: 8px; background: #f8fdff;">
                            <h4 style="margin: 0 0 10px 0; color: #1976d2;">üí¨ Ask Follow-up Questions</h4>
                            <p style="font-size: 0.9em; color: #666; margin: 0 0 15px 0;">Continue the conversation to explore your data deeper.</p>
                            <div style="display: flex; gap: 10px; align-items: flex-end;">
                                <div style="flex: 1;">
                                    <textarea id="followUpQuestion" placeholder="Ask Claude to explore further... (e.g., 'Show me wind patterns during high waves' or 'What happened around 3 PM?')" style="width: 100%; padding: 8px; min-height: 40px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"></textarea>
                                </div>
                                <button id="askFollowUpBtn" onclick="askFollowUpQuestion()" style="padding: 8px 15px; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">üí¨ Ask</button>
                            </div>
                        </div>
                    </div>
                    

                    <!-- Analysis History -->
                    <div style="margin-top: 30px;">
                        <h3>üìà Analysis History</h3>
                        <button onclick="openAnalysisHistoryModal()" id="loadHistoryBtn">üìà View Analysis History</button>
                        <p style="font-size: 0.9em; color: #666; margin-top: 10px;">View and manage your previous Claude AI analyses.</p>
                    </div>
                </div>
            </div>

            <!-- S3 Configuration Tab -->
            <div id="s3Config" class="tab-panel">
                <div class="section">
                    <h2>‚òÅÔ∏è Cloud Status</h2>
            <p>Test your S3 connection and understand the Key Prefix functionality:</p>
            <button onclick="testS3Connection()">üîó Test S3 Connection</button>
            <div id="s3TestResult" style="margin-top: 10px;"></div>
            
            <div style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                <h4>üìã S3 Key Prefix Explanation</h4>
                <p><strong>S3 Key Prefix</strong> organizes your uploaded files in the S3 bucket with a directory structure:</p>
                <ul style="margin: 10px 0; padding-left: 20px;">
                    <li><strong>Without prefix:</strong> Files upload as <code>vessels/self/navigation/position/2025-07-12.parquet</code></li>
                    <li><strong>With prefix "marine-data":</strong> Files upload as <code>marine-data/vessels/self/navigation/position/2025-07-12.parquet</code></li>
                    <li><strong>With prefix "boat-123/":</strong> Files upload as <code>boat-123/vessels/self/navigation/position/2025-07-12.parquet</code></li>
                </ul>
                    <p>This allows organizing multiple vessels or data sources in the same S3 bucket.</p>
                </div>
                </div>
            </div>

            <!-- Data Paths Tab -->
            <div id="dataPaths" class="tab-panel">
                <div class="section">
                    <h2>üìÅ Available Data Paths</h2>
                <p>Available SignalK data paths with Parquet files:</p>
                    <div id="availablePaths">
                        <div class="loading">Loading available paths...</div>
                    </div>
                    
                    <!-- Query Section for Data Paths -->
                    <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                        <h3>Query Data</h3>
                        <div class="form-group">
                            <label for="dataPathsQueryInput">DuckDB SQL Query:</label>
                            <textarea id="dataPathsQueryInput" placeholder="SELECT * FROM 'path/to/file.parquet' LIMIT 10"></textarea>
                        </div>
                        <button onclick="executeDataPathsQuery()">‚ñ∂Ô∏è Execute Query</button>
                        <button class="btn-secondary" onclick="clearDataPathsQuery()">üóëÔ∏è Clear</button>
                        
                        <div id="dataPathsResultsContainer" class="results">
                            <p>Run a query to see results here...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Custom Query Tab -->
            <div id="customQuery" class="tab-panel">
                <div class="section">
                    <h2>üîç Custom Query</h2>
                <div class="form-group">
                    <label for="queryInput">DuckDB SQL Query:</label>
                    <textarea id="queryInput" placeholder="SELECT * FROM 'path/to/file.parquet' LIMIT 10"></textarea>
                </div>
                <button onclick="executeQuery()">‚ñ∂Ô∏è Execute Query</button>
                <button class="btn-secondary" onclick="clearQuery()">üóëÔ∏è Clear</button>
                
                <div class="query-examples">
                    <h4>üìù Example Queries (click to use):</h4>
                    <ul id="queryExamples">
                            <li><div class="loading">Loading example queries...</div></li>
                        </ul>
                    </div>
                    
                    <!-- Query Results Section -->
                    <div id="customQueryResultsContainer" class="results">
                        <p>Run a query to see results here...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let availablePaths = [];
        let dataDirectory = '';
        let showCommandPaths = false; // Default to hiding command paths
        let currentAnalysisId = null; // Track current analysis for follow-up questions

        // Get the plugin path dynamically
        function getPluginPath() {
            // Get the current script's path to determine the plugin name
            const currentPath = window.location.pathname;
            const pathParts = currentPath.split('/');
            const pluginIndex = pathParts.indexOf('plugins');
            
            if (pluginIndex !== -1 && pathParts[pluginIndex + 1]) {
                return `/plugins/${pathParts[pluginIndex + 1]}`;
            }
            
            // Fallback to the plugin name from package.json
            return '/plugins/signalk-parquet';
        }

        // Load available paths on page load
        window.addEventListener('load', async function() {
            await loadAvailablePaths();
            await loadPathConfigurations();
            generateExampleQueries();
        });

        async function loadAvailablePaths() {
            try {
                const response = await fetch(`${getPluginPath()}/api/paths`);
                const result = await response.json();
                
                if (result.success) {
                    availablePaths = result.paths;
                    dataDirectory = result.dataDirectory;
                    displayAvailablePaths();
                } else {
                    document.getElementById('availablePaths').innerHTML = 
                        `<div class="error">Error loading paths: ${result.error}</div>`;
                }
            } catch (error) {
                document.getElementById('availablePaths').innerHTML = 
                    `<div class="error">Network error: ${error.message}</div>`;
            }
        }

        function displayAvailablePaths() {
            const container = document.getElementById('availablePaths');
            
            if (availablePaths.length === 0) {
                container.innerHTML = '<p>No Parquet data files found. Start collecting data first.</p>';
                return;
            }

            let html = '<div class="path-list">';
            availablePaths.forEach(pathInfo => {
                html += `
                    <div class="path-item">
                        <h4>${pathInfo.path}</h4>
                        <p>${pathInfo.fileCount} files</p>
                        <button onclick="generateQueryForPath('${pathInfo.path}', '${pathInfo.directory}')">üìã Generate Query</button>
                        <button onclick="analyzeDataPath('${pathInfo.path}', '${pathInfo.directory}')" style="margin-left: 10px; background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">üß† Analyze</button>
                    </div>
                `;
            });
            html += '</div>';
            
            container.innerHTML = html;
        }

        function generateQueryForPath(signalkPath, directory) {
            const query = `SELECT * FROM '${directory}/*.parquet' ORDER BY received_timestamp DESC LIMIT 10`;
            setDataPathsQuery(query);
        }


        function generateExampleQueries() {
            const container = document.getElementById('queryExamples');
            
            if (availablePaths.length === 0) {
                container.innerHTML = '<li><em>No data paths available yet. Start collecting data first.</em></li>';
                return;
            }

            let html = '';
            
            // Generate examples based on available paths
            availablePaths.slice(0, 4).forEach(pathInfo => {
                const examples = [
                    `SELECT * FROM '${pathInfo.directory}/*.parquet' ORDER BY received_timestamp DESC LIMIT 10`,
                    `SELECT COUNT(*) as total_records FROM '${pathInfo.directory}/*.parquet'`,
                    `SELECT received_timestamp, value, source_label FROM '${pathInfo.directory}/*.parquet' WHERE value IS NOT NULL ORDER BY received_timestamp DESC LIMIT 10`
                ];
                
                examples.forEach(query => {
                    html += `<li onclick="setQuery(this.textContent)"><code>${query}</code></li>`;
                });
            });

            container.innerHTML = html;
        }

        async function executeQuery() {
            const query = document.getElementById('queryInput').value.trim();
            if (!query) {
                alert('Please enter a query');
                return;
            }

            const resultsContainer = document.getElementById('customQueryResultsContainer');
            resultsContainer.innerHTML = '<div class="loading">Executing query...</div>';

            try {
                const response = await fetch('/plugins/signalk-parquet/api/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query })
                });

                const result = await response.json();

                if (result.success) {
                    displayResults(result, 'customQueryResultsContainer');
                } else {
                    resultsContainer.innerHTML = `<div class="error">Query error: ${result.error}</div>`;
                }
            } catch (error) {
                resultsContainer.innerHTML = `<div class="error">Network error: ${error.message}</div>`;
            }
        }

        async function executeDataPathsQuery() {
            const query = document.getElementById('dataPathsQueryInput').value.trim();
            if (!query) {
                alert('Please enter a query');
                return;
            }

            const resultsContainer = document.getElementById('dataPathsResultsContainer');
            resultsContainer.innerHTML = '<div class="loading">Executing query...</div>';

            try {
                const response = await fetch('/plugins/signalk-parquet/api/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query })
                });

                const result = await response.json();

                if (result.success) {
                    displayResults(result, 'dataPathsResultsContainer');
                } else {
                    resultsContainer.innerHTML = `<div class="error">Query error: ${result.error}</div>`;
                }
            } catch (error) {
                resultsContainer.innerHTML = `<div class="error">Network error: ${error.message}</div>`;
            }
        }

        function displayResults(result, containerId = 'resultsContainer') {
            const container = document.getElementById(containerId);
            
            if (!result.data || result.data.length === 0) {
                container.innerHTML = '<p>No data returned from query.</p>';
                return;
            }

            // Stats
            let statsHtml = `
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value">${result.rowCount}</div>
                        <div class="stat-label">Rows</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${Object.keys(result.data[0]).length}</div>
                        <div class="stat-label">Columns</div>
                    </div>
                </div>
            `;

            // Table
            const columns = Object.keys(result.data[0]);
            let tableHtml = '<div class="table-container"><table><thead><tr>';
            
            columns.forEach(col => {
                tableHtml += `<th>${col}</th>`;
            });
            tableHtml += '</tr></thead><tbody>';

            result.data.forEach(row => {
                tableHtml += '<tr>';
                columns.forEach(col => {
                    let value = row[col];
                    if (value === null || value === undefined) {
                        value = '';
                    } else if (typeof value === 'object') {
                        value = JSON.stringify(value);
                    }
                    tableHtml += `<td>${value}</td>`;
                });
                tableHtml += '</tr>';
            });

            tableHtml += '</tbody></table></div>';

            container.innerHTML = statsHtml + tableHtml;
        }

        function setQuery(query) {
            document.getElementById('queryInput').value = query;
        }

        function setDataPathsQuery(query) {
            document.getElementById('dataPathsQueryInput').value = query;
        }

        function clearQuery() {
            document.getElementById('queryInput').value = '';
            document.getElementById('customQueryResultsContainer').innerHTML = '<p>Run a query to see results here...</p>';
        }

        function clearDataPathsQuery() {
            document.getElementById('dataPathsQueryInput').value = '';
            document.getElementById('dataPathsResultsContainer').innerHTML = '<p>Run a query to see results here...</p>';
        }

        function showTab(tabId) {
            // Hide all tab panels
            const tabPanels = document.querySelectorAll('.tab-panel');
            tabPanels.forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Show the selected tab panel
            const selectedPanel = document.getElementById(tabId);
            if (selectedPanel) {
                selectedPanel.classList.add('active');
            }
            
            // Add active class to the clicked tab button
            const clickedButton = document.querySelector(`[onclick="showTab('${tabId}')"]`);
            if (clickedButton) {
                clickedButton.classList.add('active');
            }
            
            // Initialize AI Analysis tab when it becomes active
            if (tabId === 'aiAnalysis') {
                initializeAIAnalysisTab();
            }
        }

        async function testS3Connection() {
            const resultDiv = document.getElementById('s3TestResult');
            const button = document.querySelector('button[onclick="testS3Connection()"]');
            
            // Show loading state
            button.disabled = true;
            button.textContent = 'üîÑ Testing...';
            resultDiv.innerHTML = '<div class="loading">Testing S3 connection...</div>';

            try {
                const response = await fetch('/plugins/signalk-parquet/api/test-s3', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const result = await response.json();

                if (result.success) {
                    resultDiv.innerHTML = `
                        <div class="success">
                            ‚úÖ ${result.message}<br>
                            <strong>Bucket:</strong> ${result.bucket}<br>
                            <strong>Region:</strong> ${result.region}<br>
                            <strong>Key Prefix:</strong> ${result.keyPrefix}
                        </div>
                    `;
                } else {
                    resultDiv.innerHTML = `<div class="error">‚ùå ${result.error}</div>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<div class="error">‚ùå Network error: ${error.message}</div>`;
            } finally {
                // Reset button
                button.disabled = false;
                button.textContent = 'üîó Test S3 Connection';
            }
        }

        // Path Configuration Management Functions
        async function loadPathConfigurations() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/config/paths');
                const result = await response.json();
                
                if (result.success) {
                    displayPathConfigurations(result.paths);
                } else {
                    document.getElementById('pathConfigContainer').innerHTML = 
                        `<div class="error">Error loading path configurations: ${result.error}</div>`;
                }
            } catch (error) {
                document.getElementById('pathConfigContainer').innerHTML = 
                    `<div class="error">Network error: ${error.message}</div>`;
            }
        }

        function displayPathConfigurations(paths) {
            const container = document.getElementById('pathConfigContainer');
            
            if (!paths || paths.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 5px; margin: 20px 0;">
                        <h3 style="color: #666; margin-bottom: 10px;">No Path Configurations Found</h3>
                        <p style="color: #666; margin-bottom: 20px;">You need to configure SignalK paths to start collecting data.</p>
                        <button onclick="showAddPathForm()">‚ûï Add Your First Path</button>
                    </div>
                `;
                return;
            }

            // Filter paths based on showCommandPaths setting
            const filteredPaths = showCommandPaths ? paths : paths.filter(path => !path.path || !path.path.startsWith('commands.'));
            
            if (filteredPaths.length === 0) {
                const commandCount = paths.filter(path => path.path && path.path.startsWith('commands.')).length;
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 5px; margin: 20px 0;">
                        <h3 style="color: #666; margin-bottom: 10px;">No Data Paths Found</h3>
                        <p style="color: #666; margin-bottom: 20px;">
                            ${commandCount > 0 ? `${commandCount} command path${commandCount > 1 ? 's' : ''} hidden. ` : ''}
                            Add data paths to start collecting SignalK data.
                        </p>
                        <button onclick="showAddPathForm()">‚ûï Add Your First Data Path</button>
                    </div>
                `;
                return;
            }

            let html = '<div class="table-container"><table><thead><tr>';
            html += '<th>Path</th><th>Always Enabled</th><th>Regimen</th><th>Source</th><th>Context</th><th>Exclude MMSI</th><th>Actions</th>'
            html += '</tr></thead><tbody>';

            filteredPaths.forEach((path, filteredIndex) => {
                // Find the original index in the full paths array
                const originalIndex = paths.findIndex(p => p === path);
                const excludeMMSI = path.excludeMMSI && path.excludeMMSI.length > 0 ? path.excludeMMSI.join(', ') : '';
                const isCommand = path.path && path.path.startsWith('commands.');
                const rowClass = isCommand ? 'style="background-color: #fff3cd;"' : '';
                
                html += `<tr data-index="${originalIndex}" ${rowClass}>
                    <td><code>${path.path || ''}</code>${isCommand ? ' <span style="color: #856404; font-size: 11px;">(Command)</span>' : ''}</td>
                    <td>${path.enabled ? '‚úÖ' : '‚ùå'}</td>
                    <td>${path.regimen || ''}</td>
                    <td><code>${path.source || ''}</code></td>
                    <td>${path.context || 'vessels.self'}</td>
                    <td>${excludeMMSI}</td>
                    <td>
                        <button onclick="editPathConfiguration(${originalIndex})" style="padding: 5px 10px; font-size: 12px;">‚úèÔ∏è Edit</button>
                        <button onclick="removePathConfiguration(${originalIndex})" style="padding: 5px 10px; font-size: 12px; background: #dc3545;">üóëÔ∏è Remove</button>
                    </td>
                </tr>`;
            });

            html += '</tbody></table></div>';
            
            // Add summary info
            const totalPaths = paths.length;
            const commandPaths = paths.filter(path => path.path && path.path.startsWith('commands.')).length;
            const dataPaths = totalPaths - commandPaths;
            
            const summaryHtml = `
                <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-size: 14px; color: #666;">
                    Showing ${filteredPaths.length} of ${totalPaths} paths 
                    (${dataPaths} data path${dataPaths !== 1 ? 's' : ''}, ${commandPaths} command path${commandPaths !== 1 ? 's' : ''})
                </div>
            `;
            
            container.innerHTML = html + summaryHtml;
        }

        function toggleCommandPaths() {
            showCommandPaths = !showCommandPaths;
            const button = document.getElementById('toggleCommandsBtn');
            button.textContent = showCommandPaths ? 'üôà Hide Commands' : 'üëÅÔ∏è Show Commands';
            
            // Re-display the paths with the new filter
            loadPathConfigurations();
        }

        function showAddPathForm() {
            document.getElementById('addPathForm').style.display = 'block';
        }

        function hideAddPathForm() {
            document.getElementById('addPathForm').style.display = 'none';
            clearAddPathForm();
        }

        function clearAddPathForm() {
            document.getElementById('pathSignalK').value = '';
            document.getElementById('pathEnabled').checked = false;
            document.getElementById('pathRegimen').value = '';
            document.getElementById('pathSource').value = '';
            document.getElementById('pathContext').value = 'vessels.self';
            document.getElementById('pathExcludeMMSI').value = '';
        }

        async function addPathConfiguration() {
            const excludeMMSIInput = document.getElementById('pathExcludeMMSI').value.trim();
            const excludeMMSI = excludeMMSIInput ? excludeMMSIInput.split(',').map(mmsi => mmsi.trim()).filter(mmsi => mmsi) : [];
            
            const pathConfig = {
                path: document.getElementById('pathSignalK').value.trim(),
                enabled: document.getElementById('pathEnabled').checked,
                regimen: document.getElementById('pathRegimen').value.trim(),
                source: document.getElementById('pathSource').value.trim() || undefined,
                context: document.getElementById('pathContext').value.trim() || 'vessels.self',
                excludeMMSI: excludeMMSI.length > 0 ? excludeMMSI : undefined
            };

            if (!pathConfig.path) {
                alert('SignalK path is required');
                return;
            }

            try {
                const response = await fetch('/plugins/signalk-parquet/api/config/paths', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(pathConfig)
                });

                const result = await response.json();

                if (result.success) {
                    hideAddPathForm();
                    await loadPathConfigurations();
                    alert('Path configuration added successfully');
                } else {
                    alert(`Error adding path configuration: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }

        async function removePathConfiguration(index) {
            if (!confirm('Are you sure you want to remove this path configuration?')) {
                return;
            }

            try {
                const response = await fetch(`/plugins/signalk-parquet/api/config/paths/${index}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (result.success) {
                    await loadPathConfigurations();
                    alert('Path configuration removed successfully');
                } else {
                    alert(`Error removing path configuration: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }

        let editingIndex = -1;

        async function editPathConfiguration(index) {
            // Cancel any existing edit
            if (editingIndex !== -1) {
                cancelEdit();
            }
            
            editingIndex = index;
            
            // Get the current path configuration
            const response = await fetch('/plugins/signalk-parquet/api/config/paths');
            const result = await response.json();
            
            if (!result.success || !result.paths[index]) {
                alert('Error loading path configuration');
                return;
            }
            
            const path = result.paths[index];
            
            // Replace the row with edit form
            const row = document.querySelector(`tr[data-index="${index}"]`);
            if (row) {
                const excludeMMSIValue = path.excludeMMSI && path.excludeMMSI.length > 0 ? path.excludeMMSI.join(', ') : '';
                row.innerHTML = `
                    <td><input type="text" id="editPath${index}" value="${path.path || ''}" style="width: 100%;"></td>
                    <td><input type="checkbox" id="editEnabled${index}" ${path.enabled ? 'checked' : ''}></td>
                    <td><input type="text" id="editRegimen${index}" value="${path.regimen || ''}" style="width: 100%;"></td>
                    <td><input type="text" id="editSource${index}" value="${path.source || ''}" style="width: 100%;" placeholder="e.g., mqtt-weatherflow-udp"></td>
                    <td><input type="text" id="editContext${index}" value="${path.context || 'vessels.self'}" style="width: 100%;"></td>
                    <td><input type="text" id="editExcludeMMSI${index}" value="${excludeMMSIValue}" style="width: 100%;" placeholder="123456789, 987654321"></td>
                    <td>
                        <button onclick="saveEdit(${index})" style="padding: 5px 10px; font-size: 12px; background: #28a745;">üíæ Save</button>
                        <button onclick="cancelEdit()" style="padding: 5px 10px; font-size: 12px; background: #6c757d;">‚ùå Cancel</button>
                    </td>
                `;
            }
        }

        async function saveEdit(index) {
            const excludeMMSIInput = document.getElementById(`editExcludeMMSI${index}`).value.trim();
            const excludeMMSI = excludeMMSIInput ? excludeMMSIInput.split(',').map(mmsi => mmsi.trim()).filter(mmsi => mmsi) : [];
            
            const updatedPath = {
                path: document.getElementById(`editPath${index}`).value.trim(),
                enabled: document.getElementById(`editEnabled${index}`).checked,
                regimen: document.getElementById(`editRegimen${index}`).value.trim(),
                source: document.getElementById(`editSource${index}`).value.trim() || undefined,
                context: document.getElementById(`editContext${index}`).value.trim() || 'vessels.self',
                excludeMMSI: excludeMMSI.length > 0 ? excludeMMSI : undefined
            };

            if (!updatedPath.path) {
                alert('SignalK path is required');
                return;
            }

            try {
                const response = await fetch(`/plugins/signalk-parquet/api/config/paths/${index}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(updatedPath)
                });

                const result = await response.json();

                if (result.success) {
                    editingIndex = -1;
                    await loadPathConfigurations();
                    alert('Path configuration updated successfully');
                } else {
                    alert(`Error updating path configuration: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }

        function cancelEdit() {
            editingIndex = -1;
            loadPathConfigurations();
        }

        // Command Management Functions
        async function loadCommands() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/commands');
                const result = await response.json();
                
                if (result.success) {
                    displayCommands(result.commands || []);
                } else {
                    document.getElementById('commandContainer').innerHTML = `<div class="error">Error loading commands: ${result.error}</div>`;
                }
            } catch (error) {
                document.getElementById('commandContainer').innerHTML = `<div class="error">Error loading commands: ${error.message}</div>`;
            }
        }
        
        function displayCommands(commands) {
            const container = document.getElementById('commandContainer');
            
            if (!commands || commands.length === 0) {
                container.innerHTML = '<div class="info">No commands registered yet.</div>';
                return;
            }
            
            let html = '<div class="table-container"><table><thead><tr>';
            html += '<th>Command</th><th>Path</th><th>Description</th><th>Status</th><th>Registered</th><th>Actions</th>';
            html += '</tr></thead><tbody>';
            
            commands.forEach(command => {
                const status = command.active ? 'üü¢ Active' : 'üî¥ Inactive';
                const registeredDate = new Date(command.registered).toLocaleString();
                html += `<tr>
                    <td><strong>${command.command}</strong></td>
                    <td><code>vessels.self.commands.${command.command}</code></td>
                    <td>${command.description || 'No description'}</td>
                    <td>${status}</td>
                    <td>${registeredDate}</td>
                    <td>
                        <button onclick="executeCommand('${command.command}', true)" style="margin-right: 5px;">‚ñ∂Ô∏è Start</button>
                        <button onclick="executeCommand('${command.command}', false)" style="margin-right: 5px;">‚èπÔ∏è Stop</button>
                        <button onclick="unregisterCommand('${command.command}')" class="btn-danger">‚ùå Remove</button>
                    </td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            container.innerHTML = html;
        }
        
        function showAddCommandForm() {
            document.getElementById('addCommandForm').style.display = 'block';
        }
        
        function hideAddCommandForm() {
            document.getElementById('addCommandForm').style.display = 'none';
            clearAddCommandForm();
        }
        
        function clearAddCommandForm() {
            document.getElementById('commandName').value = '';
            document.getElementById('commandDescription').value = '';
        }
        
        async function registerCommand() {
            try {
                const command = document.getElementById('commandName').value.trim();
                const description = document.getElementById('commandDescription').value.trim();
                
                if (!command) {
                    alert('Command name is required');
                    return;
                }
                
                const response = await fetch('/plugins/signalk-parquet/api/commands', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        command: command,
                        description: description || undefined
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    hideAddCommandForm();
                    await loadCommands();
                    await loadPathConfigurations(); // Refresh paths to show the auto-created path
                    alert(`Command '${command}' registered successfully!\n\nA path configuration has been automatically created and enabled for this command.`);
                } else {
                    alert(`Error registering command: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }
        
        async function executeCommand(commandName, value) {
            try {
                const response = await fetch(`/plugins/signalk-parquet/api/commands/${commandName}/execute`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        value: value
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    await loadCommands();
                    await loadCommandHistory();
                    alert(`Command '${commandName}' ${value ? 'started' : 'stopped'} successfully`);
                } else {
                    alert(`Error executing command: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }
        
        async function unregisterCommand(commandName) {
            if (!confirm(`Are you sure you want to unregister command '${commandName}'?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/plugins/signalk-parquet/api/commands/${commandName}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    await loadCommands();
                    await loadCommandHistory();
                    await loadPathConfigurations(); // Refresh paths to show the removed path
                    alert(`Command '${commandName}' unregistered successfully!\n\nThe associated path configuration has been automatically removed.`);
                } else {
                    alert(`Error unregistering command: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }
        
        async function loadCommandHistory() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/commands/history');
                const result = await response.json();
                
                if (result.success) {
                    displayCommandHistory(result.data || []);
                } else {
                    document.getElementById('commandHistoryContainer').innerHTML = `<div class="error">Error loading command history: ${result.error}</div>`;
                }
            } catch (error) {
                document.getElementById('commandHistoryContainer').innerHTML = `<div class="error">Error loading command history: ${error.message}</div>`;
            }
        }
        
        function displayCommandHistory(history) {
            const container = document.getElementById('commandHistoryContainer');
            
            if (!history || history.length === 0) {
                container.innerHTML = '<div class="info">No command history available.</div>';
                return;
            }
            
            let html = '<div class="table-container"><table><thead><tr>';
            html += '<th>Command</th><th>Action</th><th>Value</th><th>Status</th><th>Time</th><th>Error</th>';
            html += '</tr></thead><tbody>';
            
            history.forEach(entry => {
                const status = entry.success ? '‚úÖ Success' : '‚ùå Failed';
                const timestamp = new Date(entry.timestamp).toLocaleString();
                const value = entry.value !== undefined ? (entry.value ? 'true' : 'false') : '-';
                html += `<tr>
                    <td><strong>${entry.command}</strong></td>
                    <td>${entry.action}</td>
                    <td>${value}</td>
                    <td>${status}</td>
                    <td>${timestamp}</td>
                    <td>${entry.error || '-'}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // Live Connections / Stream Management Functions
        let activeStreams = [];

        async function loadStreams() {
            // DISABLED - Streaming functionality has been disabled
            // try {
            //     const response = await fetch('/plugins/signalk-parquet/api/streams');
            //     const result = await response.json();
                
            //     if (result.success) {
            //         activeStreams = result.streams || [];
            //         displayStreams(activeStreams);
            //         loadStreamStats();
            //     } else {
            //         document.getElementById('streamsContainer').innerHTML = `<div class="error">Error loading streams: ${result.error}</div>`;
            //     }
            // } catch (error) {
            //     document.getElementById('streamsContainer').innerHTML = `<div class="error">Network error: ${error.message}</div>`;
            // }
            return;
        }

        function displayStreams(streams) {
            const container = document.getElementById('streamsContainer');
            
            if (!streams || streams.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 5px; margin: 20px 0;">
                        <h3 style="color: #666; margin-bottom: 10px;">No Active Streams</h3>
                        <p style="color: #666; margin-bottom: 20px;">Create your first historical data stream to get started.</p>
                        <button onclick="showAddStreamForm()">‚ûï Create Your First Stream</button>
                    </div>
                `;
                return;
            }

            let html = '<div class="table-container"><table><thead><tr>';
            html += '<th>Name</th><th>Path</th><th>Status</th><th>Time Range</th><th>Resolution</th><th>Rate</th><th>Statistics</th><th>Progress</th><th>Stream URL</th><th>Actions</th>';
            html += '</tr></thead><tbody>';

            streams.forEach((stream, index) => {
                const isRunning = stream.status === 'running';
                const isPaused = stream.status === 'paused';
                const isStopped = stream.status === 'stopped' || stream.status === 'created';
                
                const status = isRunning ? 'üü¢ Running' : isPaused ? '‚è∏Ô∏è Paused' : 'üî¥ Stopped';
                const progress = stream.dataPointsStreamed ? `${stream.dataPointsStreamed} points` : '-';
                const timeRange = `${stream.timeRange || '1h'} (${stream.startTime || 'N/A'} - ${stream.endTime || 'N/A'})`;
                const statistics = stream.aggregateMethod || 'average';
                const streamMode = stream.isIncremental ? 'üìà' : 'üìä';
                const lastTimestamp = stream.lastTimestamp ? new Date(stream.lastTimestamp).toLocaleTimeString() : 'Never';
                
                // Generate stream URLs
                const streamName = stream.name.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
                const aggregateMethod = stream.aggregateMethod || 'average';
                const streamPath = `streaming.${streamName}.${aggregateMethod}`;
                const wsUrl = `ws://${window.location.host}/signalk/v1/stream`;
                const restUrl = `http://${window.location.host}/signalk/v1/api/vessels/self/${streamPath}`;
                
                html += `<tr>
                    <td><strong>${stream.name}</strong></td>
                    <td><code>${stream.path}</code></td>
                    <td>${status}</td>
                    <td>${timeRange}</td>
                    <td>${stream.resolution || 30000}ms</td>
                    <td>${stream.rate || 5000}ms</td>
                    <td><small>${statistics} ${streamMode}<br/>Last: ${lastTimestamp}</small></td>
                    <td>${progress}</td>
                    <td>
                        ${isRunning ? 
                            `<div style="font-size: 11px;">
                                <strong>Path:</strong> <code style="font-size: 10px;">${streamPath}</code><br/>
                                <strong>REST:</strong> <a href="${restUrl}" target="_blank" style="font-size: 10px; color: #007bff;">API Link</a><br/>
                                <strong>WS:</strong> <code style="font-size: 10px;">${wsUrl}</code>
                            </div>` : 
                            '<small style="color: #666;">Stream not running</small>'
                        }
                    </td>
                    <td>
                        ${isStopped ? 
                            `<button onclick="startStream('${stream.id}')" style="padding: 5px 10px; font-size: 12px; background: #28a745;">‚ñ∂Ô∏è Start</button>` : 
                            `<button onclick="pauseStream('${stream.id}')" style="padding: 5px 10px; font-size: 12px; background: #ffc107;">${isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause'}</button>
                             <button onclick="stopStream('${stream.id}')" style="padding: 5px 10px; font-size: 12px; background: #dc3545;">‚èπÔ∏è Stop</button>`
                        }
                        <button onclick="editStream('${stream.id}')" style="padding: 5px 10px; font-size: 12px;">‚úèÔ∏è Edit</button>
                        <button onclick="deleteStream('${stream.id}')" style="padding: 5px 10px; font-size: 12px; background: #dc3545;">üóëÔ∏è Delete</button>
                    </td>
                </tr>`;
            });

            html += '</tbody></table></div>';
            container.innerHTML = html;
            
            // Update live connection icon based on active streams
            updateLiveConnectionIcon(streams);
        }

        function updateLiveConnectionIcon(streams) {
            const hasActiveStreams = streams && streams.some(stream => stream.status === 'running');
            const icon = hasActiveStreams ? 'üü¢' : 'üî¥';
            
            // Update tab button
            const tabButton = document.querySelector('.tab-button[onclick="showTab(\'liveConnections\')"]');
            if (tabButton) {
                tabButton.innerHTML = `${icon} Live Connections`;
            }
            
            // Update section header
            const sectionHeader = document.querySelector('#liveConnections h2');
            if (sectionHeader) {
                sectionHeader.innerHTML = `${icon} Live Connections`;
            }
        }

        async function loadStreamStats() {
            // DISABLED - Streaming functionality has been disabled
            // try {
            //     const response = await fetch('/plugins/signalk-parquet/api/streams/stats');
            //     const result = await response.json();
                
            //     if (result.success) {
            //         displayStreamStats(result.stats);
            //     } else {
            //         document.getElementById('streamStats').innerHTML = `<div class="error">Error loading stats: ${result.error}</div>`;
            //     }
            // } catch (error) {
            //     document.getElementById('streamStats').innerHTML = `<div class="error">Network error: ${error.message}</div>`;
            // }
            return;
        }

        function displayStreamStats(stats) {
            const container = document.getElementById('streamStats');
            
            const html = `
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value">${stats.totalStreams || 0}</div>
                        <div class="stat-label">Total Streams</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.runningStreams || 0}</div>
                        <div class="stat-label">Active</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.totalDataPointsStreamed || 0}</div>
                        <div class="stat-label">Data Points Streamed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.connectedClients || 0}</div>
                        <div class="stat-label">Connected Clients</div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        function showAddStreamForm() {
            document.getElementById('addStreamForm').style.display = 'block';
            
            // Show/hide custom time range based on selection
            const timeRangeSelect = document.getElementById('streamTimeRange');
            timeRangeSelect.addEventListener('change', function() {
                const customDiv = document.getElementById('customTimeRange');
                customDiv.style.display = this.value === 'custom' ? 'block' : 'none';
            });
        }

        function hideAddStreamForm() {
            document.getElementById('addStreamForm').style.display = 'none';
            clearAddStreamForm();
        }

        function clearAddStreamForm() {
            document.getElementById('streamName').value = '';
            
            // Reset path field to dropdown if it was converted to manual input
            const pathField = document.getElementById('streamPath');
            if (pathField.tagName === 'INPUT') {
                // Recreate the select element
                const pathContainer = pathField.parentNode;
                const pathSelect = document.createElement('select');
                pathSelect.id = 'streamPath';
                pathSelect.style.cssText = 'flex: 1;';
                pathSelect.innerHTML = '<option value="">Select a SignalK path...</option>';
                
                pathContainer.replaceChild(pathSelect, pathField);
                
                // Reload paths
                loadSignalKPaths();
            } else {
                pathField.value = '';
            }
            
            document.getElementById('streamTimeRange').value = '1h';
            document.getElementById('streamResolution').value = '30000';
            document.getElementById('streamRate').value = '500';
            document.getElementById('streamAutoStart').checked = true;
            document.getElementById('customTimeRange').style.display = 'none';
            document.getElementById('streamStartTime').value = '';
            document.getElementById('streamEndTime').value = '';
        }

        async function loadSignalKPaths() {
            const pathSelect = document.getElementById('streamPath');
            const originalHTML = pathSelect.innerHTML;
            
            try {
                pathSelect.innerHTML = '<option value="">Loading paths...</option>';
                
                // Use the same endpoint as the Available Paths tab
                const response = await fetch('/plugins/signalk-parquet/api/paths');
                const result = await response.json();
                
                if (result.success && Array.isArray(result.paths) && result.paths.length > 0) {
                    // Clear loading message and add paths
                    pathSelect.innerHTML = '<option value="">Select a SignalK path...</option>';
                    
                    // Sort paths alphabetically for better UX
                    const sortedPaths = result.paths.sort((a, b) => a.path.localeCompare(b.path));
                    
                    sortedPaths.forEach(pathInfo => {
                        const option = document.createElement('option');
                        option.value = pathInfo.path;
                        option.textContent = `${pathInfo.path} (${pathInfo.fileCount} files)`;
                        pathSelect.appendChild(option);
                    });
                    
                } else {
                    // No paths found - provide manual entry option
                    pathSelect.innerHTML = '<option value="">No historical paths found</option>';
                    const manualOption = document.createElement('option');
                    manualOption.value = 'manual';
                    manualOption.textContent = '‚úèÔ∏è Enter path manually';
                    pathSelect.appendChild(manualOption);
                }
            } catch (error) {
                console.error('Error loading SignalK paths:', error);
                
                // Provide manual entry option as fallback
                pathSelect.innerHTML = '<option value="">Select or enter a SignalK path...</option>';
                const manualOption = document.createElement('option');
                manualOption.value = 'manual';
                manualOption.textContent = '‚úèÔ∏è Enter path manually';
                pathSelect.appendChild(manualOption);
            }
        }

        async function refreshSignalKPaths() {
            await loadSignalKPaths();
        }

        // Initialize page when DOM is loaded
        document.addEventListener('DOMContentLoaded', async function() {
            // Load SignalK paths for the dropdown
            await loadSignalKPaths();
            
            // Set up auto-refresh for streams and stats - DISABLED
            // setInterval(() => {
            //     loadStreams();
            // }, 5000); // Refresh every 5 seconds
            
            // Add event listener for path selection to handle manual entry
            const pathSelect = document.getElementById('streamPath');
            let manualInput = null;
            
            pathSelect.addEventListener('change', function() {
                if (this.value === 'manual') {
                    // Replace select with text input for manual entry
                    manualInput = document.createElement('input');
                    manualInput.type = 'text';
                    manualInput.id = 'streamPath';
                    manualInput.placeholder = 'Enter SignalK path manually (e.g., navigation.position)';
                    manualInput.style.cssText = this.style.cssText;
                    
                    this.parentNode.replaceChild(manualInput, this);
                    manualInput.focus();
                }
            });
        });

        async function createStream() {
            const streamConfig = {
                name: document.getElementById('streamName').value.trim(),
                path: document.getElementById('streamPath').value.trim(),
                timeRange: document.getElementById('streamTimeRange').value,
                resolution: parseInt(document.getElementById('streamResolution').value),
                rate: parseInt(document.getElementById('streamRate').value),
                aggregateMethod: document.getElementById('streamAggregateMethod').value,
                windowSize: parseInt(document.getElementById('streamWindowSize').value),
                autoStart: document.getElementById('streamAutoStart').checked
            };

            // Handle custom time range
            if (streamConfig.timeRange === 'custom') {
                streamConfig.startTime = document.getElementById('streamStartTime').value;
                streamConfig.endTime = document.getElementById('streamEndTime').value;
                
                if (!streamConfig.startTime || !streamConfig.endTime) {
                    alert('Custom time range requires both start and end times');
                    return;
                }
            }

            if (!streamConfig.name || !streamConfig.path) {
                alert('Stream name and path are required');
                return;
            }

            // Streaming functionality has been disabled
            alert('Streaming functionality has been disabled');
        }

        async function startStream(streamId) {
            await streamAction(streamId, 'start');
        }

        async function pauseStream(streamId) {
            await streamAction(streamId, 'pause');
        }

        async function stopStream(streamId) {
            await streamAction(streamId, 'stop');
        }

        async function deleteStream(streamId) {
            if (!confirm('Are you sure you want to delete this stream? This action cannot be undone.')) {
                return;
            }
            await streamAction(streamId, 'delete');
        }

        async function streamAction(streamId, action) {
            try {
                const method = action === 'delete' ? 'DELETE' : 'PUT';
                const url = action === 'delete' ? 
                    `/plugins/signalk-parquet/api/streams/${streamId}` :
                    `/plugins/signalk-parquet/api/streams/${streamId}/${action}`;
                
                const response = await fetch(url, { method });
                const result = await response.json();

                if (result.success) {
                    // Streaming disabled - no need to refresh
                    const actionMsg = action === 'delete' ? 'deleted' : `${action}ed`;
                    // Don't show alert for successful actions, just refresh the display
                } else {
                    alert(`Error ${action}ing stream: ${result.error}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }

        async function editStream(streamId) {
            try {
                // Get the current stream configuration
                // Streaming functionality has been disabled
                alert('Streaming functionality has been disabled');
                return;
                
                if (!result.success) {
                    alert('Error loading stream data');
                    return;
                }
                
                const stream = result.streams.find(s => s.id === streamId);
                if (!stream) {
                    alert('Stream not found');
                    return;
                }
                
                // Populate the form with current values
                document.getElementById('streamName').value = stream.name || '';
                
                // Handle path selection - check if it exists in dropdown
                const pathSelect = document.getElementById('streamPath');
                const streamPath = stream.path || '';
                let pathFound = false;
                
                for (let option of pathSelect.options) {
                    if (option.value === streamPath) {
                        pathSelect.value = streamPath;
                        pathFound = true;
                        break;
                    }
                }
                
                // If path not found in dropdown, convert to manual input
                if (!pathFound && streamPath) {
                    const manualInput = document.createElement('input');
                    manualInput.type = 'text';
                    manualInput.id = 'streamPath';
                    manualInput.value = streamPath;
                    manualInput.placeholder = 'Enter SignalK path manually (e.g., navigation.position)';
                    manualInput.style.cssText = pathSelect.style.cssText;
                    
                    pathSelect.parentNode.replaceChild(manualInput, pathSelect);
                }
                
                document.getElementById('streamTimeRange').value = stream.timeRange || '1h';
                document.getElementById('streamResolution').value = stream.resolution || 30000;
                document.getElementById('streamRate').value = stream.rate || 1000;
                document.getElementById('streamAggregateMethod').value = stream.aggregateMethod || 'average';
                document.getElementById('streamWindowSize').value = stream.windowSize || 50;
                document.getElementById('streamAutoStart').checked = false; // Don't auto-start on edit
                
                // Handle custom time range
                if (stream.timeRange === 'custom') {
                    document.getElementById('customTimeRange').style.display = 'block';
                    document.getElementById('streamStartTime').value = stream.startTime || '';
                    document.getElementById('streamEndTime').value = stream.endTime || '';
                } else {
                    document.getElementById('customTimeRange').style.display = 'none';
                }
                
                // Show the form and change the create button to update
                document.getElementById('addStreamForm').style.display = 'block';
                document.getElementById('addStreamButton').style.display = 'none';
                
                // Change form title and button
                const formTitle = document.querySelector('#addStreamForm h4');
                formTitle.textContent = `Edit Stream: ${stream.name}`;
                
                // Replace create button with update/cancel buttons
                const buttonContainer = document.querySelector('#addStreamForm .form-group:last-child > div');
                buttonContainer.innerHTML = `
                    <button onclick="updateStream('${streamId}')">‚úÖ Update Stream</button>
                    <button class="btn-secondary" onclick="cancelEditStream()">‚ùå Cancel</button>
                `;
                
            } catch (error) {
                alert(`Error loading stream for editing: ${error.message}`);
            }
        }

        async function updateStream(streamId) {
            const streamConfig = {
                name: document.getElementById('streamName').value.trim(),
                path: document.getElementById('streamPath').value.trim(),
                timeRange: document.getElementById('streamTimeRange').value,
                resolution: parseInt(document.getElementById('streamResolution').value),
                rate: parseInt(document.getElementById('streamRate').value),
                aggregateMethod: document.getElementById('streamAggregateMethod').value,
                windowSize: parseInt(document.getElementById('streamWindowSize').value),
                autoRestart: true // Restart if it was running
            };

            // Handle custom time range
            if (streamConfig.timeRange === 'custom') {
                streamConfig.startTime = document.getElementById('streamStartTime').value;
                streamConfig.endTime = document.getElementById('streamEndTime').value;
                
                if (!streamConfig.startTime || !streamConfig.endTime) {
                    alert('Custom time range requires both start and end times');
                    return;
                }
            }

            if (!streamConfig.name || !streamConfig.path) {
                alert('Stream name and path are required');
                return;
            }

            // Streaming functionality has been disabled
            alert('Streaming functionality has been disabled');
        }

        function cancelEditStream() {
            // Hide the form and reset it
            hideAddStreamForm();
            
            // Reset form title and buttons
            const formTitle = document.querySelector('#addStreamForm h4');
            formTitle.textContent = 'Add New Stream Configuration';
            
            const buttonContainer = document.querySelector('#addStreamForm .form-group:last-child > div');
            buttonContainer.innerHTML = `
                <button onclick="createStream()">‚úÖ Create Stream</button>
                <button class="btn-secondary" onclick="hideAddStreamForm()">‚ùå Cancel</button>
            `;
        }

        // Live Data Display Functions
        let liveDataEntries = [];
        let liveDataPaused = false;
        const MAX_LIVE_ENTRIES = 100;

        function addLiveDataEntry(streamId, streamName, path, value, timestamp, ema = null, sma = null) {
            if (liveDataPaused) return;

            // Check for duplicates using streamId (which now includes timestamp)
            const existingEntry = liveDataEntries.find(entry => entry.streamId === streamId);
            if (existingEntry) {
                return; // Skip duplicate entry
            }

            const entry = {
                timestamp: timestamp || new Date().toISOString(),
                streamId: streamId,
                streamName: streamName,
                path: path,
                value: value,
                ema: ema,
                sma: sma
            };

            // Add entry to array
            liveDataEntries.push(entry);
            
            // Sort by timestamp (newest first)
            liveDataEntries.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

            // Keep only max entries
            if (liveDataEntries.length > MAX_LIVE_ENTRIES) {
                liveDataEntries = liveDataEntries.slice(0, MAX_LIVE_ENTRIES);
            }

            updateLiveDataDisplay();
        }

        function updateLiveDataDisplay() {
            const tbody = document.getElementById('liveDataBody');
            const countElement = document.getElementById('liveDataCount');

            countElement.textContent = liveDataEntries.length;

            if (liveDataEntries.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" style="padding: 20px; text-align: center; color: #666;">
                            No data streaming yet. Start a stream to see live data.
                        </td>
                    </tr>
                `;
                return;
            }

            let html = '';
            liveDataEntries.forEach((entry, index) => {
                // Create date object and handle UTC timestamps properly
                const date = new Date(entry.timestamp);
                const now = new Date();
                
                // Check if timestamp is from today
                const isToday = date.toDateString() === now.toDateString();
                
                let timeStr;
                if (isToday) {
                    // Today: just show time
                    timeStr = date.toLocaleTimeString();
                } else {
                    // Not today: show "Aug 21, 6:25 PM" format
                    const options = { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: 'numeric', 
                        minute: '2-digit',
                        hour12: true 
                    };
                    timeStr = date.toLocaleString(undefined, options);
                }
                const valueStr = formatValue(entry.value);
                const emaStr = entry.ema !== null ? entry.ema.toFixed(3) : '-';
                const smaStr = entry.sma !== null ? entry.sma.toFixed(3) : '-';
                const rowClass = index % 2 === 0 ? 'background: #f9f9f9;' : '';
                

                html += `
                    <tr style="${rowClass}">
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee; font-family: monospace;">${timeStr}</td>
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee;"><strong>${entry.streamName}</strong></td>
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee;"><code style="font-size: 11px;">${entry.path}</code></td>
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee; font-family: monospace;">${valueStr}</td>
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee; font-family: monospace; color: #007bff;">${emaStr}</td>
                        <td style="padding: 6px 8px; border-bottom: 1px solid #eee; font-family: monospace; color: #28a745;">${smaStr}</td>
                    </tr>
                `;
            });

            tbody.innerHTML = html;
        }

        function formatValue(value) {
            if (value === null || value === undefined) {
                return '<em>null</em>';
            }
            
            if (typeof value === 'object') {
                if (value.latitude !== undefined && value.longitude !== undefined) {
                    // Position object
                    return `${value.latitude.toFixed(6)}, ${value.longitude.toFixed(6)}`;
                }
                // Other objects - show as JSON
                return JSON.stringify(value);
            }
            
            if (typeof value === 'number') {
                return value.toFixed(3);
            }
            
            return String(value);
        }

        function clearLiveData() {
            if (confirm('Clear all live data entries?')) {
                liveDataEntries = [];
                updateLiveDataDisplay();
            }
        }

        function toggleLiveDataPause() {
            liveDataPaused = !liveDataPaused;
            const btn = document.getElementById('pauseDataBtn');
            btn.textContent = liveDataPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
            btn.style.background = liveDataPaused ? '#28a745' : '#ffc107';
        }

        function showDataSummary() {
            const panel = document.getElementById('dataSummaryPanel');
            const content = document.getElementById('dataSummaryContent');
            
            if (panel.style.display === 'none') {
                // Analyze the data
                const pathStats = {};
                const streamTypes = {initial: 0, incremental: 0};
                let totalBuckets = 0;
                
                liveDataEntries.forEach(entry => {
                    // Extract path and value
                    const path = entry.path;
                    const value = parseFloat(entry.value);
                    const streamName = entry.streamName;
                    
                    if (!isNaN(value)) {
                        if (!pathStats[path]) {
                            pathStats[path] = {
                                values: [],
                                methods: new Set(),
                                bucketCounts: []
                            };
                        }
                        pathStats[path].values.push(value);
                        
                        // Extract method and bucket count from stream name
                        const methodMatch = streamName.match(/(INITIAL|INCREMENTAL): (\w+)/);
                        if (methodMatch) {
                            const [, type, method] = methodMatch;
                            pathStats[path].methods.add(method);
                            streamTypes[type.toLowerCase()]++;
                        }
                        
                        // Extract bucket count
                        const bucketMatch = streamName.match(/\((\d+) buckets\)/);
                        if (bucketMatch) {
                            const bucketCount = parseInt(bucketMatch[1]);
                            pathStats[path].bucketCounts.push(bucketCount);
                            totalBuckets += bucketCount;
                        }
                    }
                });
                
                let summaryHtml = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">';
                
                // Stream Statistics
                summaryHtml += '<div><strong>üìà Stream Activity:</strong><br/>';
                summaryHtml += `Initial Loads: ${streamTypes.initial}<br/>`;
                summaryHtml += `Incremental Updates: ${streamTypes.incremental}<br/>`;
                summaryHtml += `Total Time Buckets: ${totalBuckets}</div>`;
                
                // Path Analysis
                summaryHtml += '<div><strong>üéØ Path Analysis:</strong><br/>';
                Object.entries(pathStats).forEach(([path, stats]) => {
                    const values = stats.values;
                    const min = Math.min(...values).toFixed(3);
                    const max = Math.max(...values).toFixed(3);
                    const avg = (values.reduce((a, b) => a + b, 0) / values.length).toFixed(3);
                    const latest = values[0]?.toFixed(3) || 'N/A';
                    const methods = Array.from(stats.methods).join(', ');
                    const avgBuckets = stats.bucketCounts.length > 0 ? 
                        (stats.bucketCounts.reduce((a, b) => a + b, 0) / stats.bucketCounts.length).toFixed(0) : 'N/A';
                    
                    summaryHtml += `<strong>${path}:</strong><br/>`;
                    summaryHtml += `‚Ä¢ Methods: ${methods}<br/>`;
                    summaryHtml += `‚Ä¢ Range: ${min} - ${max}<br/>`;
                    summaryHtml += `‚Ä¢ Average: ${avg}<br/>`;
                    summaryHtml += `‚Ä¢ Latest: ${latest}<br/>`;
                    summaryHtml += `‚Ä¢ Avg Buckets: ${avgBuckets}<br/><br/>`;
                });
                summaryHtml += '</div></div>';
                
                // Data Trends
                summaryHtml += '<div style="margin-top: 15px;"><strong>üìä Data Interpretation:</strong><br/>';
                summaryHtml += 'This shows your time-bucketed statistical streaming in action!<br/>';
                summaryHtml += '‚Ä¢ Each row represents a statistical calculation (MAX, AVG, etc.) for a time bucket<br/>';
                summaryHtml += '‚Ä¢ INITIAL = First load with full time window<br/>';
                summaryHtml += '‚Ä¢ INCREMENTAL = New buckets from sliding window updates<br/>';
                summaryHtml += '‚Ä¢ Values change as new data arrives and statistics are recalculated</div>';
                
                content.innerHTML = summaryHtml;
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        // WebSocket connection for real-time streaming data
        let ws = null;
        let wsReconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        function connectWebSocket() {
            // For now, use polling mode since we need a dedicated WebSocket server
            startLiveDataPolling();
        }

        function handleWebSocketMessage(message) {
            // Handle time-series data from our streaming service
            if (message.type === 'timeSeriesData') {
                handleTimeSeriesData(message);
            }
            // Handle regular SignalK delta messages
            else if (message.updates && Array.isArray(message.updates)) {
                message.updates.forEach(update => {
                    if (update.values && Array.isArray(update.values)) {
                        update.values.forEach(valueUpdate => {
                            addLiveDataEntry(
                                'signalk',
                                'SignalK Stream',
                                valueUpdate.path,
                                valueUpdate.value,
                                update.timestamp || new Date().toISOString()
                            );
                        });
                    }
                });
            }
        }

        function handleTimeSeriesData(message) {
            const { streamId, metadata, data } = message;
            
            
            // Add each time-bucketed data point to the live display
            data.forEach((point, index) => {
                const displayValue = typeof point.value === 'object' ? 
                    JSON.stringify(point.value) : 
                    (typeof point.value === 'number' ? point.value.toFixed(3) : point.value);
                
                const displayName = `${metadata.aggregateMethod.toUpperCase()}: ${metadata.path}`;
                const bucketInfo = `[${point.bucketIndex}/${metadata.totalPoints}]`;
                
                // Extract EMA and SMA if available for numeric values
                const ema = (typeof point.ema === 'number') ? point.ema : null;
                const sma = (typeof point.sma === 'number') ? point.sma : null;
                
                addLiveDataEntry(
                    streamId,
                    `${displayName} ${bucketInfo}`,
                    metadata.path,
                    displayValue,
                    point.timestamp,
                    ema,
                    sma
                );
            });
        }

        // Enhanced polling function that shows real time-bucketed streaming data points
        function startLiveDataPolling() {
            
            let pollCount = 0;
            
            setInterval(async () => {
                if (liveDataPaused) return;

                pollCount++;

                // Streaming functionality has been disabled - no running streams
                return;
            }, 3000); // Check every 3 seconds
        }

        // Initialize WebSocket connection when page loads  
        setTimeout(() => {
            connectWebSocket();
        }, 1000);

        // ===========================================
        // CLAUDE AI INTEGRATION FUNCTIONS
        // ===========================================

        // Test Claude API connection
        async function testClaudeConnection() {
            const btn = document.getElementById('testConnectionBtn');
            const result = document.getElementById('claudeConnectionResult');
            
            btn.disabled = true;
            btn.innerHTML = 'üîÑ Testing...';
            result.innerHTML = '';
            
            try {
                const response = await fetch('/plugins/signalk-parquet/api/analyze/test-connection', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    result.innerHTML = `<div style="color: green; padding: 10px; background: #d4edda; border-radius: 5px;">
                        ‚úÖ Claude API connection successful!<br>
                        Model: ${data.model}<br>
                        Response time: ${data.responseTime}ms
                    </div>`;
                } else {
                    result.innerHTML = `<div style="color: red; padding: 10px; background: #f8d7da; border-radius: 5px;">
                        ‚ùå Connection failed: ${data.error}
                    </div>`;
                }
            } catch (error) {
                result.innerHTML = `<div style="color: red; padding: 10px; background: #f8d7da; border-radius: 5px;">
                    ‚ùå Error: ${error.message}
                </div>`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üîó Test Claude Connection';
            }
        }

        // ===========================================
        // VESSEL CONTEXT FUNCTIONS
        // ===========================================

        // Load vessel context when AI tab is initialized
        async function loadVesselContext() {
            try {
                console.log('Loading vessel context...');
                const response = await fetch('/plugins/signalk-parquet/api/vessel-context');
                console.log('Vessel context response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Vessel context data:', data);
                
                if (data.success && data.data) {
                    const context = data.data;
                    
                    // Update auto-extracted vessel info display
                    displayVesselInfo(context.vesselInfo);
                    
                    // Update custom context textarea
                    const customContextTextarea = document.getElementById('customVesselContext');
                    if (customContextTextarea) {
                        customContextTextarea.value = context.customContext || '';
                    }
                    
                    // Show last updated info
                    updateVesselContextStatus(`Last updated: ${new Date(context.lastUpdated).toLocaleString()}`);
                } else {
                    console.log('No vessel context data found, showing empty state');
                    displayVesselInfo({});
                    updateVesselContextStatus('No vessel context found - click Refresh to extract from SignalK');
                }
            } catch (error) {
                console.error('Error loading vessel context:', error);
                const autoInfoDiv = document.getElementById('autoVesselInfo');
                if (autoInfoDiv) {
                    autoInfoDiv.innerHTML = `<div style="color: red;">Error loading vessel context: ${error.message}</div>`;
                }
                updateVesselContextStatus('Error loading vessel context: ' + error.message, true);
            }
        }

        // Display vessel information in the UI
        function displayVesselInfo(vesselInfo) {
            const autoInfoDiv = document.getElementById('autoVesselInfo');
            if (!autoInfoDiv) return;
            
            if (!vesselInfo || Object.keys(vesselInfo).length === 0) {
                autoInfoDiv.innerHTML = `
                    <div style="color: #666; font-style: italic; text-align: center; padding: 20px;">
                        No vessel information found.<br>
                        <small>Click "Refresh from SignalK" to extract vessel data automatically.</small>
                    </div>`;
                return;
            }
            
            const sections = [];
            
            // Basic identification
            if (vesselInfo.name || vesselInfo.callsign || vesselInfo.mmsi) {
                const items = [];
                if (vesselInfo.name) items.push(`<strong>Name:</strong> ${vesselInfo.name}`);
                if (vesselInfo.callsign) items.push(`<strong>Call Sign:</strong> ${vesselInfo.callsign}`);
                if (vesselInfo.mmsi) items.push(`<strong>MMSI:</strong> ${vesselInfo.mmsi}`);
                if (vesselInfo.flag) items.push(`<strong>Flag:</strong> ${vesselInfo.flag}`);
                sections.push(`<div><strong>üÜî Identification:</strong> ${items.join(', ')}</div>`);
            }
            
            // Physical characteristics
            const physical = [];
            
            // Handle length - could be number or object with overall property
            if (vesselInfo.length) {
                const lengthValue = typeof vesselInfo.length === 'object' && vesselInfo.length.overall 
                    ? vesselInfo.length.overall 
                    : vesselInfo.length;
                if (lengthValue) physical.push(`${lengthValue}m LOA`);
            }
            
            if (vesselInfo.beam) physical.push(`${vesselInfo.beam}m beam`);
            
            // Handle draft - could be number or object with maximum property  
            if (vesselInfo.draft) {
                const draftValue = typeof vesselInfo.draft === 'object' && vesselInfo.draft.maximum
                    ? vesselInfo.draft.maximum
                    : vesselInfo.draft;
                if (draftValue) physical.push(`${draftValue}m draft`);
            }
            
            if (vesselInfo.height) physical.push(`${vesselInfo.height}m height`);
            if (vesselInfo.displacement) physical.push(`${vesselInfo.displacement}t displacement`);
            if (physical.length > 0) {
                sections.push(`<div><strong>üìè Physical:</strong> ${physical.join(', ')}</div>`);
            }
            
            // Vessel type
            if (vesselInfo.vesselType) {
                sections.push(`<div><strong>üö¢ Type:</strong> ${vesselInfo.vesselType}</div>`);
            }
            
            // Technical specs
            const technical = [];
            if (vesselInfo.grossTonnage) technical.push(`${vesselInfo.grossTonnage} GT`);
            if (vesselInfo.netTonnage) technical.push(`${vesselInfo.netTonnage} NT`);
            if (vesselInfo.deadWeight) technical.push(`${vesselInfo.deadWeight}t DWT`);
            if (technical.length > 0) {
                sections.push(`<div><strong>‚öñÔ∏è Tonnage:</strong> ${technical.join(', ')}</div>`);
            }
            
            // Build info
            const build = [];
            if (vesselInfo.builder) build.push(`Built by ${vesselInfo.builder}`);
            if (vesselInfo.buildYear) build.push(`in ${vesselInfo.buildYear}`);
            if (vesselInfo.hullNumber) build.push(`(Hull: ${vesselInfo.hullNumber})`);
            if (build.length > 0) {
                sections.push(`<div><strong>üî® Build:</strong> ${build.join(' ')}</div>`);
            }
            
            if (sections.length === 0) {
                autoInfoDiv.innerHTML = `<div style="color: #666; font-style: italic;">No vessel details available - try refreshing from SignalK</div>`;
            } else {
                autoInfoDiv.innerHTML = sections.join('<br style="margin: 8px 0;">');
            }
        }

        // Refresh vessel information from SignalK
        async function refreshVesselInfo() {
            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = 'üîÑ Refreshing...';
            
            try {
                console.log('Refreshing vessel info from SignalK...');
                const response = await fetch('/plugins/signalk-parquet/api/vessel-context/refresh', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                console.log('Refresh response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Refresh data:', data);
                
                if (data.success && data.data) {
                    displayVesselInfo(data.data.vesselInfo);
                    updateVesselContextStatus('Vessel information refreshed from SignalK data');
                } else {
                    console.error('Refresh failed:', data);
                    updateVesselContextStatus('Failed to refresh: ' + (data.error || 'Unknown error'), true);
                }
            } catch (error) {
                console.error('Error refreshing vessel info:', error);
                updateVesselContextStatus('Error refreshing vessel information: ' + error.message, true);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üîÑ Refresh from SignalK';
            }
        }

        // Save vessel context (both auto-extracted and custom)
        async function saveVesselContext() {
            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = 'üíæ Saving...';
            
            try {
                const customContext = document.getElementById('customVesselContext').value;
                
                const response = await fetch('/plugins/signalk-parquet/api/vessel-context', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        customContext: customContext
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    updateVesselContextStatus('Context saved successfully ‚úÖ');
                } else {
                    updateVesselContextStatus('Failed to save: ' + (data.error || 'Unknown error'), true);
                }
            } catch (error) {
                console.error('Error saving vessel context:', error);
                updateVesselContextStatus('Error saving context: ' + error.message, true);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üíæ Save Context';
            }
        }

        // Preview Claude context
        async function previewClaudeContext() {
            try {
                console.log('Generating Claude context preview...');
                const response = await fetch('/plugins/signalk-parquet/api/vessel-context/claude-preview');
                console.log('Preview response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Preview data:', data);
                
                if (data.success && data.data) {
                    const modal = document.getElementById('contextPreviewModal');
                    const content = document.getElementById('contextPreviewContent');
                    
                    content.textContent = data.data.contextText;
                    modal.style.display = 'block';
                } else {
                    console.error('Preview failed:', data);
                    updateVesselContextStatus('Failed to generate preview: ' + (data.error || 'Unknown error'), true);
                }
            } catch (error) {
                console.error('Error previewing context:', error);
                updateVesselContextStatus('Error generating preview: ' + error.message, true);
            }
        }

        // Close context preview modal
        function closeContextPreview() {
            const modal = document.getElementById('contextPreviewModal');
            modal.style.display = 'none';
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const contextModal = document.getElementById('contextPreviewModal');
            const historyModal = document.getElementById('analysisHistoryModal');
            const viewModal = document.getElementById('analysisViewModal');
            
            if (event.target === contextModal) {
                contextModal.style.display = 'none';
            } else if (event.target === historyModal) {
                historyModal.style.display = 'none';
            } else if (event.target === viewModal) {
                viewModal.style.display = 'none';
            }
        }

        // Update vessel context status message
        function updateVesselContextStatus(message, isError = false) {
            const statusDiv = document.getElementById('vesselContextStatus');
            if (statusDiv) {
                statusDiv.innerHTML = `<span style="color: ${isError ? 'red' : 'green'};">${message}</span>`;
                
                // Clear status after 5 seconds
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 5000);
            }
        }

        // Toggle vessel context section
        function toggleVesselContext() {
            const content = document.getElementById('vesselContextContent');
            const icon = document.getElementById('vesselContextToggleIcon');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

        // ===========================================
        // END VESSEL CONTEXT FUNCTIONS
        // ===========================================

        // Load analysis templates and populate UI
        async function loadAnalysisTemplates() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/analyze/templates');
                const data = await response.json();
                
                if (data.success && data.templates) {
                    // Flatten template categories into a single array
                    const allTemplates = [];
                    data.templates.forEach(category => {
                        if (category.templates) {
                            allTemplates.push(...category.templates);
                        }
                    });
                    populateTemplateCards(allTemplates);
                    populateTemplateDropdown(allTemplates);
                }
            } catch (error) {
                console.error('Error loading analysis templates:', error);
            }
        }


        // Populate template dropdown
        function populateTemplateDropdown(templates) {
            const select = document.getElementById('analysisTemplate');
            select.innerHTML = '<option value="">Select a template...</option>';
            
            templates.forEach(template => {
                const option = document.createElement('option');
                option.value = template.id;
                option.textContent = `${template.icon} ${template.name}`;
                select.appendChild(option);
            });
        }

        // Run quick analysis WITHOUT templates - just analyze data directly
        async function runQuickAnalysis(dataPath) {
            const result = document.getElementById('analysisResults');
            const content = document.getElementById('analysisContent');
            
            result.style.display = 'block';
            content.innerHTML = '<div style="text-align: center; padding: 20px;">üîÑ Running direct analysis...</div>';
            
            try {
                // Skip templates entirely - use custom analysis with generic prompt
                const analysisRequest = {
                    dataPath,
                    analysisType: 'custom',
                    customPrompt: `Analyze this maritime sensor data and provide insights. Focus on:
1. Data patterns and trends over time
2. Any anomalies or unusual readings  
3. Statistical summary of the data
4. Practical insights for maritime operations
5. Data quality assessment

Provide actionable insights based on what you observe in the data.`,
                    timeRange: {
                        start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(), // Last 7 days
                        end: new Date().toISOString()
                    }
                };
                
                console.log(`üöÄ Running template-free analysis for: ${dataPath}`);
                
                const response = await fetch('/plugins/signalk-parquet/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisRequest)
                });
                
                const data = await response.json();
                
                if (data.success && data.data) {
                    displayAnalysisResult(data.data);
                } else {
                    content.innerHTML = `<div style="color: red;">‚ùå Analysis failed: ${data.error}</div>`;
                }
                
            } catch (error) {
                content.innerHTML = `<div style="color: red;">‚ùå Error: ${error.message}</div>`;
            }
        }

        // Get selected data paths
        function getSelectedDataPaths() {
            const checkboxes = document.querySelectorAll('#analysisDataPathContainer input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(checkbox => checkbox.value);
        }

        // Update selected path count
        function updateSelectedPathCount() {
            const selectedPaths = getSelectedDataPaths();
            document.getElementById('selectedPathCount').textContent = selectedPaths.length;
        }

        // Handle path checkbox change
        function handlePathCheckboxChange() {
            updateSelectedPathCount();
        }

        // Select all paths
        function selectAllPaths() {
            const checkboxes = document.querySelectorAll('#analysisDataPathContainer input[type="checkbox"]');
            checkboxes.forEach(checkbox => checkbox.checked = true);
            updateSelectedPathCount();
        }

        // Clear all paths
        function clearAllPaths() {
            const checkboxes = document.querySelectorAll('#analysisDataPathContainer input[type="checkbox"]');
            checkboxes.forEach(checkbox => checkbox.checked = false);
            updateSelectedPathCount();
        }

        // Get path icon based on path name
        function getPathIcon(path) {
            let icon = 'üìä';
            if (path.includes('wind')) icon = 'üí®';
            else if (path.includes('navigation')) icon = 'üß≠';
            else if (path.includes('position')) icon = 'üìç';
            else if (path.includes('temperature')) icon = 'üå°Ô∏è';
            else if (path.includes('battery') || path.includes('electrical')) icon = 'üîã';
            else if (path.includes('command')) icon = '‚öôÔ∏è';
            return icon;
        }

        // Populate analysis path checkboxes
        function populateAnalysisPathCheckboxes(paths) {
            const container = document.getElementById('analysisDataPathContainer');
            
            if (!paths || paths.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic;">No data paths available</div>';
                return;
            }
            
            container.innerHTML = ''; // Clear loading message
            
            paths.forEach((pathInfo, index) => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'path-checkbox-row';
                
                const pathInfoDiv = document.createElement('div');
                pathInfoDiv.className = 'path-info';
                
                const iconSpan = document.createElement('span');
                iconSpan.className = 'path-icon';
                iconSpan.textContent = getPathIcon(pathInfo.path);
                
                const label = document.createElement('label');
                label.htmlFor = `path_${pathInfo.path.replace(/[^a-zA-Z0-9]/g, '_')}`;
                label.textContent = `${pathInfo.path} (${pathInfo.fileCount} files)`;
                label.style.cssText = 'cursor: pointer; margin: 0;';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = pathInfo.path;
                checkbox.id = `path_${pathInfo.path.replace(/[^a-zA-Z0-9]/g, '_')}`;
                checkbox.onchange = handlePathCheckboxChange;
                checkbox.className = 'path-checkbox';
                
                pathInfoDiv.appendChild(iconSpan);
                pathInfoDiv.appendChild(label);
                checkboxDiv.appendChild(pathInfoDiv);
                checkboxDiv.appendChild(checkbox);
                container.appendChild(checkboxDiv);
            });
            
            updateSelectedPathCount();
        }

        // Run custom analysis
        async function runCustomAnalysis() {
            const selectedPaths = getSelectedDataPaths();
            const customPrompt = document.getElementById('customPrompt').value;
            const startDate = document.getElementById('analysisStartDate').value;
            const endDate = document.getElementById('analysisEndDate').value;
            const aggregationMethod = document.getElementById('aggregationMethod').value;
            const resolution = document.getElementById('resolution').value;
            const claudeModel = document.getElementById('claudeModelMain').value;
            const enableDatabaseAccess = document.getElementById('enableDatabaseAccess').checked;
            
            // Skip path validation in database access mode - Claude can access all data
            if (!enableDatabaseAccess && (!selectedPaths || selectedPaths.length === 0)) {
                alert('Please select at least one data path');
                return;
            }
            
            const result = document.getElementById('analysisResults');
            const content = document.getElementById('analysisContent');
            
            result.style.display = 'block';
            
            // Start timer
            const startTime = new Date();
            const timerElement = document.createElement('div');
            timerElement.id = 'analysisTimer';
            timerElement.style.cssText = 'background: #e3f2fd; border: 1px solid #2196f3; border-radius: 5px; padding: 10px; margin-bottom: 15px; text-align: center; font-family: monospace;';
            
            content.innerHTML = '';
            content.appendChild(timerElement);
            
            const loadingElement = document.createElement('div');
            loadingElement.style.cssText = 'text-align: center; padding: 20px;';
            loadingElement.innerHTML = 'üîÑ Running custom analysis...';
            content.appendChild(loadingElement);
            
            // Update timer every 100ms
            const timerInterval = setInterval(() => {
                const elapsed = (new Date() - startTime) / 1000;
                timerElement.innerHTML = `
                    <strong>‚è±Ô∏è Analysis Timer</strong><br>
                    Prompt sent: ${startTime.toLocaleTimeString()}<br>
                    Elapsed: ${elapsed.toFixed(1)}s
                `;
            }, 100);
            
            try {
                const analysisRequest = {
                    dataPath: enableDatabaseAccess ? 'database_access_mode' : selectedPaths.join(','), // REST API supports comma-separated paths
                    analysisType: 'custom',
                    customPrompt: customPrompt || `Analyze this maritime sensor data and provide insights. Focus on:
1. Data patterns and trends over time
2. Any anomalies or unusual readings  
3. Statistical summary of the data
4. Practical insights for maritime operations
5. Data quality assessment

Provide actionable insights based on what you observe in the data.`,
                    timeRange: {
                        start: startDate ? new Date(startDate).toISOString() : new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
                        end: endDate ? new Date(endDate).toISOString() : new Date().toISOString()
                    },
                    aggregationMethod: aggregationMethod || 'average',
                    resolution: resolution || '',  // Empty string = Auto
                    claudeModel: claudeModel || 'claude-sonnet-4-20250514',
                    useDatabaseAccess: enableDatabaseAccess,
                };
                
                console.log(`üöÄ Running custom analysis for paths: ${selectedPaths.join(', ')}`);
                
                const response = await fetch('/plugins/signalk-parquet/api/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisRequest)
                });
                
                const data = await response.json();
                
                // Stop timer and show final time
                clearInterval(timerInterval);
                const endTime = new Date();
                const totalTime = (endTime - startTime) / 1000;
                // Debug what we're actually getting
                console.log('Full response data:', JSON.stringify(data, null, 2));
                
                // Get token usage if available
                let tokenInfo = '';
                if (data.usage) {
                    const usage = data.usage;
                    tokenInfo = `<br><strong>Tokens: ${usage.input_tokens || 0} in + ${usage.output_tokens || 0} out = ${(usage.input_tokens || 0) + (usage.output_tokens || 0)} total</strong>`;
                } else {
                    tokenInfo = `<br><small style="color: #666;">No token usage found in response</small>`;
                }
                
                timerElement.innerHTML = `
                    <strong>‚è±Ô∏è Analysis Complete</strong><br>
                    Started: ${startTime.toLocaleTimeString()}<br>
                    Completed: ${endTime.toLocaleTimeString()}<br>
                    <strong>Total Time: ${totalTime.toFixed(1)}s</strong>${tokenInfo}
                `;
                timerElement.style.background = data.success ? '#e8f5e8' : '#ffeaea';
                timerElement.style.borderColor = data.success ? '#4caf50' : '#f44336';
                
                // Remove loading message
                loadingElement.remove();
                
                if (data.success && data.data) {
                    displayAnalysisResult(data.data);
                } else {
                    const errorElement = document.createElement('div');
                    errorElement.style.color = 'red';
                    errorElement.innerHTML = `‚ùå Analysis failed: ${data.error}`;
                    content.appendChild(errorElement);
                }
                
            } catch (error) {
                // Stop timer on error
                clearInterval(timerInterval);
                const endTime = new Date();
                const totalTime = (endTime - startTime) / 1000;
                timerElement.innerHTML = `
                    <strong>‚è±Ô∏è Analysis Failed</strong><br>
                    Started: ${startTime.toLocaleTimeString()}<br>
                    Failed: ${endTime.toLocaleTimeString()}<br>
                    <strong>Total Time: ${totalTime.toFixed(1)}s</strong>
                `;
                timerElement.style.background = '#ffeaea';
                timerElement.style.borderColor = '#f44336';
                
                loadingElement.remove();
                const errorElement = document.createElement('div');
                errorElement.style.color = 'red';
                errorElement.innerHTML = `‚ùå Error: ${error.message}`;
                content.appendChild(errorElement);
            }
        }

        // Display analysis results
        function displayAnalysisResult(analysisResult) {
            const content = document.getElementById('analysisContent');
            
            // Keep the existing timer element at the top
            const existingTimer = document.getElementById('analysisTimer');
            let html = `
                <div style="border-left: 4px solid #667eea; padding-left: 15px; margin-bottom: 20px;">
                    <h4 style="color: #667eea; margin: 0 0 10px 0;">üìä Analysis Summary</h4>
                    <div style="white-space: pre-wrap; line-height: 1.6;">${analysisResult.analysis}</div>
                </div>
            `;
            
            if (analysisResult.insights && analysisResult.insights.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #28a745; margin: 0 0 10px 0;">üí° Key Insights</h4>
                        <ul style="padding-left: 20px;">
                            ${analysisResult.insights.map(insight => `<li style="margin-bottom: 5px;">${insight}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }
            
            if (analysisResult.recommendations && analysisResult.recommendations.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #ffc107; margin: 0 0 10px 0;">üéØ Recommendations</h4>
                        <ul style="padding-left: 20px;">
                            ${analysisResult.recommendations.map(rec => `<li style="margin-bottom: 5px;">${rec}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }
            
            if (analysisResult.anomalies && analysisResult.anomalies.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #dc3545; margin: 0 0 10px 0;">‚ö†Ô∏è Anomalies Detected</h4>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px;">
                            ${analysisResult.anomalies.map(anomaly => `
                                <div style="margin-bottom: 8px; padding: 8px; background: white; border-radius: 4px;">
                                    <strong>${anomaly.severity.toUpperCase()}</strong> - ${anomaly.description}
                                    <br><small style="color: #666;">Timestamp: ${new Date(anomaly.timestamp).toLocaleString()}</small>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            html += `
                <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #dee2e6; font-size: 12px; color: #6c757d;">
                    <strong>Analysis Metadata:</strong><br>
                    Data Path: ${analysisResult.metadata.dataPath}<br>
                    Records Analyzed: ${analysisResult.metadata.recordCount}<br>
                    Confidence: ${(analysisResult.confidence * 100).toFixed(1)}%<br>
                    Data Quality: ${analysisResult.dataQuality}<br>
                    Timestamp: ${new Date(analysisResult.timestamp).toLocaleString()}
                </div>
            `;
            
            // Preserve the timer and append results after it
            if (existingTimer) {
                // Create a results container
                const resultsDiv = document.createElement('div');
                resultsDiv.innerHTML = html;
                
                // Clear content but keep timer, then append results
                const children = Array.from(content.children);
                children.forEach(child => {
                    if (child.id !== 'analysisTimer') {
                        child.remove();
                    }
                });
                content.appendChild(resultsDiv);
            } else {
                content.innerHTML = html;
            }
            
            // Show follow-up section for database access mode and store analysis ID
            if (analysisResult.metadata && analysisResult.metadata.useDatabaseAccess && analysisResult.id) {
                currentAnalysisId = analysisResult.id;
                const followUpSection = document.getElementById('followUpSection');
                if (followUpSection) {
                    followUpSection.style.display = 'block';
                }
            } else {
                currentAnalysisId = null;
                const followUpSection = document.getElementById('followUpSection');
                if (followUpSection) {
                    followUpSection.style.display = 'none';
                }
            }
        }

        // Open analysis history modal
        async function openAnalysisHistoryModal() {
            const modal = document.getElementById('analysisHistoryModal');
            const content = document.getElementById('analysisHistoryModalContent');
            
            // Show modal immediately
            modal.style.display = 'block';
            content.innerHTML = '<div style="text-align: center; padding: 20px;"><div>üîÑ Loading analysis history...</div></div>';
            
            try {
                const response = await fetch('/plugins/signalk-parquet/api/analyze/history?limit=20');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success && data.data && data.data.length > 0) {
                    let html = '<div>';
                    
                    data.data.forEach((analysis, index) => {
                        const date = new Date(analysis.timestamp);
                        const isRecent = (Date.now() - date.getTime()) < 24 * 60 * 60 * 1000; // Less than 24 hours
                        
                        html += `
                            <div style="background: ${isRecent ? '#f0f8ff' : 'white'}; border: 1px solid #ddd; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                                    <div>
                                        <h4 style="margin: 0 0 5px 0; color: #333; font-size: 1.1em;">${analysis.metadata.analysisType || 'Custom Analysis'}</h4>
                                        <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">
                                            <strong>Path:</strong> ${analysis.metadata.dataPath}
                                        </div>
                                        <div style="font-size: 0.85em; color: #888;">
                                            ${date.toLocaleString()} ${isRecent ? '(Recent)' : ''}
                                        </div>
                                    </div>
                                    <div style="display: flex; gap: 8px;">
                                        <button onclick="viewAnalysis('${analysis.id}')" style="background: #2196F3; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em;">
                                            üëÅÔ∏è View
                                        </button>
                                        <button onclick="deleteAnalysis('${analysis.id}')" style="background: #f44336; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em;">
                                            üóëÔ∏è Delete
                                        </button>
                                    </div>
                                </div>
                                <div style="font-size: 0.9em; color: #555; line-height: 1.4; max-height: 80px; overflow: hidden; position: relative;">
                                    ${analysis.analysis.substring(0, 300)}${analysis.analysis.length > 300 ? '...' : ''}
                                </div>
                                ${analysis.insights && analysis.insights.length > 0 ? `
                                    <div style="margin-top: 10px; font-size: 0.85em; color: #666;">
                                        <strong>Key Insights:</strong> ${analysis.insights.slice(0, 2).join(', ')}${analysis.insights.length > 2 ? '...' : ''}
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                    content.innerHTML = html;
                } else {
                    content.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #666;">
                            <div style="font-size: 3em; margin-bottom: 20px;">üìà</div>
                            <h3>No Analysis History Found</h3>
                            <p>Your Claude AI analyses will appear here once you start running them.</p>
                        </div>
                    `;
                }
                
            } catch (error) {
                content.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #d32f2f;">
                        <div style="font-size: 3em; margin-bottom: 20px;">‚ö†Ô∏è</div>
                        <h3>Error Loading History</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        // Close analysis history modal
        function closeAnalysisHistoryModal() {
            document.getElementById('analysisHistoryModal').style.display = 'none';
        }

        // View individual analysis
        async function viewAnalysis(analysisId) {
            const modal = document.getElementById('analysisViewModal');
            const content = document.getElementById('analysisViewContent');
            const title = document.getElementById('analysisViewTitle');
            
            // Show modal
            modal.style.display = 'block';
            content.innerHTML = '<div style="text-align: center; padding: 20px;">üîÑ Loading analysis...</div>';
            
            try {
                // Find the analysis in the current data (could also fetch individually)
                const historyResponse = await fetch('/plugins/signalk-parquet/api/analyze/history');
                const historyData = await historyResponse.json();
                
                if (historyData.success && historyData.data) {
                    const analysis = historyData.data.find(a => a.id === analysisId);
                    if (analysis) {
                        displayFullAnalysis(analysis);
                    } else {
                        content.innerHTML = '<div style="text-align: center; padding: 20px; color: #d32f2f;">Analysis not found.</div>';
                    }
                }
            } catch (error) {
                content.innerHTML = `<div style="text-align: center; padding: 20px; color: #d32f2f;">Error loading analysis: ${error.message}</div>`;
            }
        }

        // Display full analysis in modal
        function displayFullAnalysis(analysis) {
            const content = document.getElementById('analysisViewContent');
            const title = document.getElementById('analysisViewTitle');
            
            title.textContent = `üß† ${analysis.metadata.analysisType || 'Analysis'} - ${new Date(analysis.timestamp).toLocaleDateString()}`;
            
            let html = `
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #2196F3;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">Analysis Metadata</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9em;">
                        <div><strong>Data Path:</strong> ${analysis.metadata.dataPath}</div>
                        <div><strong>Analysis Type:</strong> ${analysis.metadata.analysisType || 'Custom'}</div>
                        <div><strong>Date:</strong> ${new Date(analysis.timestamp).toLocaleString()}</div>
                        <div><strong>Record Count:</strong> ${analysis.metadata.recordCount || 'N/A'}</div>
                        <div><strong>Confidence:</strong> ${Math.round((analysis.confidence || 0) * 100)}%</div>
                        <div><strong>Data Quality:</strong> ${analysis.dataQuality || 'N/A'}</div>
                    </div>
                </div>

                <div style="margin-bottom: 20px;">
                    <h4 style="color: #333; border-bottom: 2px solid #2196F3; padding-bottom: 5px;">üß† Main Analysis</h4>
                    <div style="background: white; padding: 20px; border-radius: 8px; border: 1px solid #ddd; line-height: 1.6; white-space: pre-wrap;">${analysis.analysis}</div>
                </div>
            `;
            
            if (analysis.insights && analysis.insights.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #333; border-bottom: 2px solid #4CAF50; padding-bottom: 5px;">üí° Key Insights</h4>
                        <ul style="background: white; padding: 20px; border-radius: 8px; border: 1px solid #ddd; line-height: 1.6;">
                `;
                analysis.insights.forEach(insight => {
                    html += `<li style="margin-bottom: 8px;">${insight}</li>`;
                });
                html += `</ul></div>`;
            }
            
            if (analysis.recommendations && analysis.recommendations.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #333; border-bottom: 2px solid #FF9800; padding-bottom: 5px;">üéØ Recommendations</h4>
                        <ul style="background: white; padding: 20px; border-radius: 8px; border: 1px solid #ddd; line-height: 1.6;">
                `;
                analysis.recommendations.forEach(rec => {
                    html += `<li style="margin-bottom: 8px;">${rec}</li>`;
                });
                html += `</ul></div>`;
            }
            
            if (analysis.anomalies && analysis.anomalies.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #333; border-bottom: 2px solid #f44336; padding-bottom: 5px;">‚ö†Ô∏è Anomalies Detected</h4>
                        <div style="background: white; padding: 20px; border-radius: 8px; border: 1px solid #ddd;">
                `;
                analysis.anomalies.forEach(anomaly => {
                    html += `
                        <div style="margin-bottom: 15px; padding: 10px; background: #fff3e0; border-left: 4px solid #ff9800; border-radius: 4px;">
                            <div style="font-weight: bold; margin-bottom: 5px;">${new Date(anomaly.timestamp).toLocaleString()}</div>
                            <div style="margin-bottom: 5px;"><strong>Value:</strong> ${anomaly.value} (Expected: ${anomaly.expectedRange.min} - ${anomaly.expectedRange.max})</div>
                            <div style="margin-bottom: 5px;"><strong>Severity:</strong> ${anomaly.severity} (Confidence: ${Math.round(anomaly.confidence * 100)}%)</div>
                            <div>${anomaly.description}</div>
                        </div>
                    `;
                });
                html += `</div></div>`;
            }
            
            // Add copy button
            html += `
                <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd;">
                    <button onclick="deleteAnalysis('${analysis.id}', true)" style="background: #f44336; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer;">
                        üóëÔ∏è Delete Analysis
                    </button>
                </div>
            `;
            
            content.innerHTML = html;
        }

        // Close analysis view modal
        function closeAnalysisViewModal() {
            document.getElementById('analysisViewModal').style.display = 'none';
        }

        // Delete analysis
        async function deleteAnalysis(analysisId, isFullView = false) {
            try {
                if (!confirm('Are you sure you want to delete this analysis? This action cannot be undone.')) {
                    return;
                }

                const response = await fetch(`/plugins/signalk-parquet/api/analyze/history/${analysisId}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                
                if (result.success) {
                    // Close modal if in full view
                    if (isFullView) {
                        closeAnalysisViewModal();
                    }
                    
                    // Refresh the history list
                    openAnalysisHistoryModal();
                } else {
                    alert(`Failed to delete analysis: ${result.error}`);
                }
            } catch (error) {
                console.error('Failed to delete analysis:', error);
                alert('Failed to delete analysis');
            }
        }


        // Analyze data from Data Paths tab
        async function analyzeDataPath(signalkPath, directory) {
            // Switch to AI Analysis tab
            showTab('aiAnalysis');
            
            // Select the checkbox for this path in the custom analysis form
            const checkboxId = `path_${signalkPath.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const checkbox = document.getElementById(checkboxId);
            if (checkbox) {
                // Clear all other selections and select only this path
                const allCheckboxes = document.querySelectorAll('#analysisDataPathContainer input[type="checkbox"]');
                allCheckboxes.forEach(cb => cb.checked = false);
                checkbox.checked = true;
                updateSelectedPathCount();
            }
            
            // Scroll to custom analysis section
            document.getElementById('analysisTemplate').scrollIntoView({ behavior: 'smooth' });
        }

        // Toggle between analysis modes
        function toggleAnalysisMode() {
            const checkbox = document.getElementById('enableDatabaseAccess');
            const legacyDesc = document.getElementById('legacyModeDesc');
            const databaseDesc = document.getElementById('databaseModeDesc');
            const selectionSection = document.getElementById('selectionOptionsSection');
            const selectionSubtext = document.getElementById('selectionToggleSubtext');
            
            if (checkbox.checked) {
                // Show database mode description
                legacyDesc.style.display = 'none';
                databaseDesc.style.display = 'block';
                
                // Grey out selection options for database mode
                selectionSection.style.opacity = '0.5';
                selectionSection.style.pointerEvents = 'none';
                selectionSubtext.textContent = '(Not needed for database access mode)';
                
                console.log('Switched to Direct Database Access mode');
            } else {
                // Show legacy mode description
                legacyDesc.style.display = 'block';
                databaseDesc.style.display = 'none';
                
                // Enable selection options for legacy mode
                selectionSection.style.opacity = '1';
                selectionSection.style.pointerEvents = 'auto';
                selectionSubtext.textContent = '(Advanced options for legacy mode)';
                
                console.log('Switched to Legacy Data Sampling mode');
            }
        }

        // Toggle selection options visibility
        function toggleSelectionOptions() {
            const container = document.getElementById('selectionOptionsContainer');
            const icon = document.getElementById('selectionToggleIcon');
            
            if (container.style.display === 'none' || !container.style.display) {
                // Show options
                container.style.display = 'block';
                icon.textContent = '‚ñº';
                console.log('Selection options expanded');
            } else {
                // Hide options
                container.style.display = 'none';
                icon.textContent = '‚ñ∂';
                console.log('Selection options collapsed');
            }
        }

        // Initialize AI Analysis tab when it becomes active
        function initializeAIAnalysisTab() {
            // Load vessel context
            loadVesselContext();
            
            // Load available data paths for both cards and dropdown
            loadAvailableDataPaths();
            
            // Set default date range (last 24 hours)
            const now = new Date();
            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            
            document.getElementById('analysisEndDate').value = now.toISOString().slice(0, 16);
            document.getElementById('analysisStartDate').value = yesterday.toISOString().slice(0, 16);
            
            // Initialize UI state based on default checkbox state
            toggleAnalysisMode();
        }
        
        // Load available data paths for analysis
        async function loadAvailableDataPaths() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/paths');
                const data = await response.json();
                
                if (data.success && data.paths) {
                    // Populate custom analysis checkboxes
                    populateAnalysisPathCheckboxes(data.paths);
                } else {
                    console.error('Failed to load data paths:', data.error);
                }
            } catch (error) {
                console.error('Error loading available data paths:', error);
            }
        }

        // Load data paths for analysis dropdown
        async function loadDataPathsForAnalysis() {
            try {
                const response = await fetch('/plugins/signalk-parquet/api/paths');
                const data = await response.json();
                
                if (data.success && data.paths) {
                    const container = document.getElementById('analysisDataPathContainer');
                    
                    if (data.paths.length === 0) {
                        container.innerHTML = '<div style="color: #666; font-style: italic;">No data paths available</div>';
                        return;
                    }
                    
                    container.innerHTML = ''; // Clear loading message
                    
                    data.paths.forEach((pathInfo, index) => {
                        const checkboxDiv = document.createElement('div');
                        checkboxDiv.className = 'path-checkbox-row';
                        
                        const pathInfoDiv = document.createElement('div');
                        pathInfoDiv.className = 'path-info';
                        
                        const iconSpan = document.createElement('span');
                        iconSpan.className = 'path-icon';
                        iconSpan.textContent = getPathIcon(pathInfo.path);
                        
                        const label = document.createElement('label');
                        label.htmlFor = `path_${pathInfo.path.replace(/[^a-zA-Z0-9]/g, '_')}`;
                        label.textContent = `${pathInfo.path} (${pathInfo.fileCount} files)`;
                        label.style.cssText = 'cursor: pointer; margin: 0;';
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = pathInfo.path;
                        checkbox.id = `path_${pathInfo.path.replace(/[^a-zA-Z0-9]/g, '_')}`;
                        checkbox.onchange = handlePathCheckboxChange;
                        checkbox.className = 'path-checkbox';
                        
                        pathInfoDiv.appendChild(iconSpan);
                        pathInfoDiv.appendChild(label);
                        checkboxDiv.appendChild(pathInfoDiv);
                        checkboxDiv.appendChild(checkbox);
                        container.appendChild(checkboxDiv);
                    });
                    
                    updateSelectedPathCount();
                }
            } catch (error) {
                console.error('Error loading data paths for analysis:', error);
                const container = document.getElementById('analysisDataPathContainer');
                container.innerHTML = '<div style="color: #d32f2f;">Error loading paths</div>';
            }
        }

        // Ask follow-up question to continue conversation
        async function askFollowUpQuestion() {
            const questionTextarea = document.getElementById('followUpQuestion');
            const askButton = document.getElementById('askFollowUpBtn');
            const question = questionTextarea.value.trim();
            
            if (!question) {
                alert('Please enter a question.');
                return;
            }
            
            if (!currentAnalysisId) {
                alert('No active conversation. Please run a database analysis first.');
                return;
            }
            
            // Disable UI during request
            askButton.disabled = true;
            askButton.textContent = 'üí¨ Asking...';
            questionTextarea.disabled = true;
            
            // Start timer for follow-up
            const startTime = new Date();
            const content = document.getElementById('analysisContent');
            const followUpTimerElement = document.createElement('div');
            followUpTimerElement.id = 'followUpTimer';
            followUpTimerElement.style.cssText = 'background: #fff3e0; border: 1px solid #ff9800; border-radius: 5px; padding: 10px; margin-bottom: 15px; text-align: center; font-family: monospace;';
            content.appendChild(followUpTimerElement);
            
            // Update timer every 100ms
            const timerInterval = setInterval(() => {
                const elapsed = (new Date() - startTime) / 1000;
                followUpTimerElement.innerHTML = `
                    <strong>‚è±Ô∏è Follow-up Timer</strong><br>
                    Question sent: ${startTime.toLocaleTimeString()}<br>
                    Elapsed: ${elapsed.toFixed(1)}s
                `;
            }, 100);
            
            try {
                const response = await fetch(`${getPluginPath()}/api/analyze/followup`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        conversationId: currentAnalysisId,
                        question: question
                    })
                });
                
                const result = await response.json();
                
                // Stop timer and show final time
                clearInterval(timerInterval);
                const endTime = new Date();
                const totalTime = (endTime - startTime) / 1000;
                
                // Get token usage if available
                let tokenInfo = '';
                if (result.usage) {
                    const usage = result.usage;
                    tokenInfo = `<br><strong>Tokens: ${usage.input_tokens || 0} in + ${usage.output_tokens || 0} out = ${(usage.input_tokens || 0) + (usage.output_tokens || 0)} total</strong>`;
                }
                
                followUpTimerElement.innerHTML = `
                    <strong>‚è±Ô∏è Follow-up Complete</strong><br>
                    Started: ${startTime.toLocaleTimeString()}<br>
                    Completed: ${endTime.toLocaleTimeString()}<br>
                    <strong>Total Time: ${totalTime.toFixed(1)}s</strong>${tokenInfo}
                `;
                followUpTimerElement.style.background = result.success ? '#e8f5e8' : '#ffeaea';
                followUpTimerElement.style.borderColor = result.success ? '#4caf50' : '#f44336';
                
                if (result.success) {
                    // Display the follow-up response in the analysis content area
                    const followUpHtml = `
                        <div style="border-left: 4px solid #1976d2; padding-left: 15px; margin-bottom: 20px; background: #f8fdff;">
                            <h4 style="color: #1976d2; margin: 0 0 10px 0;">üí¨ Follow-up Question</h4>
                            <div style="font-style: italic; color: #666; margin-bottom: 10px;">${question}</div>
                            <div style="white-space: pre-wrap; line-height: 1.6;">${result.data.analysis}</div>
                        </div>
                    `;
                    
                    // Append to existing content
                    content.innerHTML += followUpHtml;
                    
                    // Clear the question input
                    questionTextarea.value = '';
                    
                    // Scroll to show the new response
                    content.scrollIntoView({ behavior: 'smooth', block: 'end' });
                } else {
                    const errorElement = document.createElement('div');
                    errorElement.style.color = 'red';
                    errorElement.innerHTML = `‚ùå Follow-up failed: ${result.error}`;
                    content.appendChild(errorElement);
                }
            } catch (error) {
                // Stop timer on error
                clearInterval(timerInterval);
                const endTime = new Date();
                const totalTime = (endTime - startTime) / 1000;
                
                // Try to get token usage even on error (in case it's a partial failure)
                let tokenInfo = '';
                try {
                    if (error.response && error.response.usage) {
                        const usage = error.response.usage;
                        tokenInfo = `<br><strong>Tokens: ${usage.input_tokens || 0} in + ${usage.output_tokens || 0} out = ${(usage.input_tokens || 0) + (usage.output_tokens || 0)} total</strong>`;
                    }
                } catch (e) {
                    // Ignore token parsing errors
                }
                
                followUpTimerElement.innerHTML = `
                    <strong>‚è±Ô∏è Follow-up Failed</strong><br>
                    Started: ${startTime.toLocaleTimeString()}<br>
                    Failed: ${endTime.toLocaleTimeString()}<br>
                    <strong>Total Time: ${totalTime.toFixed(1)}s</strong>${tokenInfo}
                `;
                followUpTimerElement.style.background = '#ffeaea';
                followUpTimerElement.style.borderColor = '#f44336';
                
                console.error('Follow-up question error:', error);
                alert('Failed to ask follow-up question. Please try again.');
            } finally {
                // Re-enable UI
                askButton.disabled = false;
                askButton.textContent = 'üí¨ Ask';
                questionTextarea.disabled = false;
                questionTextarea.focus();
            }
        }

    </script>

    <!-- Analysis History Modal -->
    <div id="analysisHistoryModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1001; overflow-y: auto;">
        <div style="max-width: 900px; margin: 30px auto; background: white; border-radius: 10px; max-height: 90vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 20px; border-bottom: 1px solid #ddd; position: sticky; top: 0; background: white; border-radius: 10px 10px 0 0;">
                <h3 style="margin: 0;">üìà Analysis History</h3>
                <button onclick="closeAnalysisHistoryModal()" style="background: #f44336; color: white; padding: 5px 10px; border-radius: 3px; font-size: 16px;">&times;</button>
            </div>
            <div id="analysisHistoryModalContent" style="padding: 20px;">
                <!-- Analysis history content will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Individual Analysis View Modal -->
    <div id="analysisViewModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1002; overflow-y: auto;">
        <div style="max-width: 1000px; margin: 20px auto; background: white; border-radius: 10px; max-height: 95vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 20px; border-bottom: 1px solid #ddd; position: sticky; top: 0; background: white; border-radius: 10px 10px 0 0;">
                <h3 style="margin: 0;" id="analysisViewTitle">üß† Analysis Details</h3>
                <button onclick="closeAnalysisViewModal()" style="background: #f44336; color: white; padding: 5px 10px; border-radius: 3px; font-size: 16px;">&times;</button>
            </div>
            <div id="analysisViewContent" style="padding: 20px;">
                <!-- Individual analysis content will be loaded here -->
            </div>
        </div>
    </div>

</body>
</html>